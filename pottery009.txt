// ==UserScript==
// @name        dev
// @namespace   dev
// @match       https://*.bloxd.io/*
// @version     009
// @author      Developed by skidmus, wang, simple/5eqnMVZDg1cezjZh, chatGPT, Arthur, and ENTITY.
// @description 🟢https://discord.gg/G6ksFfQdaW🟢
// ==/UserScript==
//
//⚠️⚠️ALWAYS USE ALTS⚠️⚠️
//
//⚠️⚠IN DEVELOPMENT⚠️⚠️
//
// 🟢https://discord.gg/G6ksFfQdaW join this for updates please.🟢
//(() => {

// Message to Arthur/bloxd devs: NOBODY ELSE WILL KEEP YOU SAFE

//__START__SETTINGS______________________________________________


let Fuxny = {};
let defaultAccent = "#FF0000";

const TITLE = "Midnight__" //-----------------------Title

const changeHealthBar = true // --------------------Change health bar color to gradient color
const spoofRanksEnabled = true; // -----------------Gives you all ranks (YT, Super, Developer)
const ATTACK_INTERVAL_MS = 20; // -----------------How fast to hit players with triggerbot/killAura    LOW = BAN
let desiredPotionSlot = 1 //------------------------What slot should potions go to? Numbers start at zero! 0-9
let spikeSlot = 8 //--------------------------------What slot do spikes automatically go in? 0-9
let webSlot = 9 //----------------------------------What slot do webs / nets automatically go in? 0-9


let alreadyConnected = null;
let colyRoom = null;
let sendBytesName = null;
let injectedBool = false;
let myId = 1
let isInitializing = true;
let clientOptions = null;
let noaParent = null;
let noaKeyInParent = null;
let blinkState = {
    enabled: false,
    originalSendBytes: null,
    queued: [],
    interval: 0,
    noPacket: false
};

let everEnabled = {};

let wallJumpInterval = null;
let wallJumpRunning = false;


let lockPlayerWaterStateInterval = null;
let waterJumpingEnabled = false


let wireFramesBool = false;


let espEnabled = false;

let chestESPEnabled = false;
let oreESPEnabled = false;
let chestOreInterval = null;
let chestBoxes = {};



let isSkyboxHidden = false;


let triggerBotEnabled = false;
let toggleTriggerBotInterval = null;


const possibleNames = [
    //"LegLeftMesh",
    //"LegRightMesh",
    //"TorsoNode",
    //"ArmLeftMesh",
    //"ArmRightMesh",
    "BodyMesh",
    'Body|Armour',
    //"HeadMesh"
]; // Potential detection: If the player has leg armour there is no way leftLegMesh could have been hit.
let killAuraEnabled = false
let killAuraIntervalId = null
let lastClosestId = null
let newBox = null;
let newBoxId = null;
let __nullKey = null; //Entity enabled key
let __stringKey = null; //Entity ID key "Then why didn't you just label them that?"
let animationFrameId = null;
let hitBoxEnabled = false;
const hitboxes = {};


let cachedNameTagParent = null;
let cachedBHOPParent = null;


let autoPotionEnabled = false;
let autoPotionInterval = null;


let nameTagsEnabled = false;
let nameTagsIntervalId = null;
let nameTagParent = null;


let bhopEnabled = false;
let bhopIntervalId = null;

let enemyHealthGuiEnabled = false;
let healthWatcherInterval = null;
let lastPercent = null;
let lastChangeTime = Date.now();
let resetTimeout = null;


let eIdKey = null;
let targetEntity = null;
let targetEntityDistance = null;


let pickupReachEnabled = false; //Credits to wang!!!!
let originalGetEntitiesInAABB = null;
const RANGE_MULTIPLIER = 5;
let ghMethodKey = null;
let proto = null;


let bhopKnifeEnabled = false;
let spaceVid;
let fadeVolumeInterval;
let spaceHeld = false;
let bigHeadsEnabled = false;


const scannedChunks = new Set();
let chunkDataField = null;

// ETC
let playerKey = null;
let moveState = null;
let physState = null;
let humanoidMeshlist = null;

// Variables and helper functions outside the object
let distance = 0.1;
let moveInterval = null;
let lastUpTime = 0;



var r = { //WANG
    keys(e) {
        var t = [],
            o = 0;
        for (var s in e) e != null && (t[o] = s, o++);
        return t
    },
    values(e) {
        for (var t = this.keys(e), o = [], s = 0, i = 0; s < t.length;) {
            var l = t[s],
                d = e[l];
            o[i] = d, i++, s++
        }
        return o
    },
    assign(e, ...t) {
        let o = Object(e);
        for (let s = 0; s < t.length; s++) {
            let i = t[s];
            if (i != null)
                for (let l in i) o[l] = i[l]
        }
        return o
    }
};


function fadeVolume(from, to, duration) {
  const steps = 30;
  const stepTime = duration / steps;
  let current = 0;

  if (fadeVolumeInterval) clearInterval(fadeVolumeInterval);

  fadeVolumeInterval = setInterval(() => {
    current++;
    const progress = current / steps;
    spaceVid.volume = from + (to - from) * progress;

    if (current >= steps) {
      clearInterval(fadeVolumeInterval);
      fadeVolumeInterval = null;
    }
  }, stepTime * 1000);
}

function onKeyDown(e) {
  if (e.code === 'Space' && !spaceHeld) {
    spaceHeld = true;
    spaceVid.style.opacity = '1';
    spaceVid.play();
    fadeVolume(spaceVid.volume, 0.1, 2.5); // fade in to 0.8 over 2 seconds
  }
}

function onKeyUp(e) {
  if (e.code === 'Space') {
    spaceHeld = false;
    spaceVid.style.opacity = '0';
    fadeVolume(spaceVid.volume, 0.1, 2.5); //
    setTimeout(() => {
      if (!spaceHeld) spaceVid.pause();
    }, 500);
  }
}


function showTemporaryNotification(message, duration = 1500) {
    const defaultBackGroundColor = 'rgba(0, 0, 0, 0.5)'; // semi-transparent black
    const defaultBackGroundBlur = 9;
    const defaultAccent = "#FF0000"; // HEX accent color

    // Create a notification container if it doesn't exist
    let notificationContainer = document.getElementById('notification-container');
    if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notification-container';
        notificationContainer.style.position = 'fixed';
        notificationContainer.style.bottom = '20px';
        notificationContainer.style.right = '20px';
        notificationContainer.style.zIndex = '132';
        document.body.appendChild(notificationContainer);
    }

    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = message;

    // Style the notification
    notification.style.padding = '12px';
    notification.style.color = '#fff';
    notification.style.borderRadius = '4px';
    notification.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
    notification.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
    notification.style.opacity = '0';
    notification.style.transform = 'translateY(20px)';
    notification.style.marginBottom = '10px';
    notification.style.backgroundColor = defaultBackGroundColor;
    notification.style.backdropFilter = `blur(${defaultBackGroundBlur}px)`;
    
    // Border using accent color
    notification.style.border = `2px solid ${defaultAccent}`;

    // Optional: give it a slight gradient inner glow (if you want it fancier)
    // notification.style.boxShadow = `0 0 12px ${defaultAccent}, 0 4px 8px rgba(0,0,0,0.2)`;

    // Add to container
    notificationContainer.appendChild(notification);

    // Trigger the fade-in effect
    setTimeout(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translateY(0)';
    }, 10);

    // Set up the fade-out and removal
    setTimeout(() => {
        notification.style.opacity = '0';
        // No translateY(-20px) because you disliked that

        setTimeout(() => {
            notification.remove();
            if (notificationContainer.children.length === 0) {
                notificationContainer.remove();
            }
        }, 500);
    }, duration);
}

function clearESPBoxes() {
    for (const key in chestBoxes) {
        for (const {
                mesh,
                id
            }
            of chestBoxes[key]) {
            mesh.dispose();
            Fuxny.entities.deleteEntity(id);
        }
    }
    scannedChunks.clear();
    chestBoxes = {};
}

function reverseIndex(i, stride) {
    const x = Math.floor(i / stride[0]);
    const remX = i % stride[0];
    const y = Math.floor(remX / stride[1]);
    const z = remX % stride[1];
    return [x, y, z];
}

function getChunkKey(chunk) {
    const [wx, wy, wz] = chunk.pos || [0, 0, 0];
    const cx = Math.floor(wx / 32);
    const cy = Math.floor(wy / 32);
    const cz = Math.floor(wz / 32);
    return `${cx}|${cy}|${cz}|overworld`;
}

function scanChunk(chunk, blockIDs) {
    const blockData = chunk[chunkDataField];
    if (!blockData) return;

    const {
        data,
        stride
    } = blockData;

    const pos = chunk.pos || [0, 0, 0];
    if (!data || !stride) return;

    const chunkKey = getChunkKey(chunk);
    for (let i = 0; i < data.length; i++) {
        const blockID = data[i];
        if (!blockIDs.includes(blockID)) continue;




        const [x, y, z] = reverseIndex(i, stride);
        const worldX = pos[0] + x + 0.5;
        const worldY = pos[1] + y + 0.5;
        const worldZ = pos[2] + z + 0.5;

        const mesh = Fuxny.Lion.Mesh.CreateBox("espbox", 0.5, false, 1, Fuxny.Lion.scene);
        mesh.position.set(worldX, worldY, worldZ);
        mesh.renderingGroupId = 1;

        mesh.material = new Fuxny.Lion.StandardMaterial("mat", Fuxny.Lion.scene)

        const id = Fuxny.entities.add([worldX, worldY, worldZ], null, null, mesh);
        if (!chestBoxes[chunkKey]) chestBoxes[chunkKey] = [];
        chestBoxes[chunkKey].push({
            mesh,
            id
        });


        if ([204, 205, 206, 207].includes(blockID)) {
            console.log("FOUNDCHEST")

            mesh.material.diffuseColor = new Fuxny.Lion.Color3(1, 0.5, 0); // orange
            mesh.material.emissiveColor = new Fuxny.Lion.Color3(1, 0.5, 0); // makes it glow orange
        }
        if (blockID === 45) {
            mesh.material.diffuseColor = new Fuxny.Lion.Color3(0, 0, 1); // blue
            mesh.material.emissiveColor = new Fuxny.Lion.Color3(0, 0, 1); // makes it glow blue
        }

        if (blockID === 465) {
            mesh.material.diffuseColor = new Fuxny.Lion.Color3(0.7, 0.5, 1); // pale purple
            mesh.material.emissiveColor = new Fuxny.Lion.Color3(0.7, 0.5, 1); // makes it glow pale purple
        }




    }
}

function scanAllChunks() {
    if (!Fuxny?.world || !Fuxny?.world?.[Fuxny.impKey]?.hash) return;
    const chunkHash = Fuxny.world[Fuxny.impKey].hash;
    // Step 1: Remove boxes for chunks no longer loaded
    for (const scannedKey of scannedChunks) {
        if (!(scannedKey in chestBoxes)) continue;

        if (!Object.values(chunkHash).some(chunk => getChunkKey(chunk) === scannedKey)) {
            // Delete all meshes for this chunk
            for (const {
                    mesh,
                    id
                }
                of chestBoxes[scannedKey]) {
                mesh.dispose(); // remove from scene
                Fuxny.entities.deleteEntity(id); // remove from entity system if needed
            }
            delete chestBoxes[scannedKey];
            scannedChunks.delete(scannedKey);
        }
    }

    // Step 2: Scan newly loaded chunks
    for (const chunkKey in chunkHash) {

        const chunk = chunkHash[chunkKey];
        if (!chunkDataField) {
            autoDetectChunkDataField(chunk);
            if (!chunkDataField) continue; // Skip if still not found
        }

        const blockData = chunk[chunkDataField];
        if (!blockData?.data || !blockData.stride || !chunk.pos) continue;


        const key = getChunkKey(chunk);
        if (scannedChunks.has(key)) continue;
        scannedChunks.add(key);
        if (chestESPEnabled) scanChunk(chunk, [204, 205, 206, 207]);
        if (oreESPEnabled) scanChunk(chunk, [44, 45, 465, 50]);
    }
}

function stopMoving() {
  if (moveInterval) {
    clearInterval(moveInterval);
    moveInterval = null;
  }
}

function startMoving() {
  if (moveInterval) return; // Already moving

  moveInterval = setInterval(() => {
    let pos = Fuxny.entities.getState(1, 'position').position;
    let h = Fuxny.camera.heading;
    let p = Fuxny.camera.pitch;

    let newX = pos[0];
    let newY = pos[1];
    let newZ = pos[2];

    const now = Date.now();

    if (p < -1) {
      // Looking up: move up only if 500ms have passed
      if (now - lastUpTime >= 500) {
        newY += distance + 0.9;
        lastUpTime = now;
      }
    } else if (p > 1) {
      // Looking down: move down
      newY -= distance;
    } else {
      // Move forward horizontally
      newX += Math.sin(h) * distance;
      newZ += Math.cos(h) * distance;
    }

    Fuxny.entities.setPosition(1, newX, newY, newZ);
  }, 20);
}

function dumpAllFunctions(obj, includePrototype = false) {
    const seen = new Set();
    let current = obj;
    let index = 1;

    console.group(`📦 Function Dump`);

    do {
        const props = Object.getOwnPropertyNames(current);
        for (const key of props) {
            if (seen.has(key)) continue;
            seen.add(key);

            try {
                const val = obj[key];
                if (typeof val === "function") {
                    console.groupCollapsed(`🔹 [${index++}] ${key}()`);
                    console.log(val.toString());
                    console.groupEnd();
                }
            } catch (e) {
                console.warn(`⚠️ Could not access function '${key}':`, e);
            }
        }

        current = includePrototype ? Object.getPrototypeOf(current) : null;

    } while (current && current !== Object.prototype);

    console.groupEnd();
}

function searchForTerm(obj, term) {
    const results = [];
    const visited = new WeakSet();

    function recurse(current, path = []) {
        if (typeof current !== 'object' || current === null) return;

        if (visited.has(current)) return;
        visited.add(current);

        for (const key in current) {
            if (!Object.hasOwn(current, key)) continue;

            const value = current[key];
            const keyMatch = key.toLowerCase().includes(term.toLowerCase());
            const valMatch = (
                typeof value === 'string' ||
                typeof value === 'number' ||
                typeof value === 'boolean'
            ) && String(value).toLowerCase().includes(term.toLowerCase());

            if (keyMatch || valMatch) {
                results.push({
                    path: [...path, key].join('.'),
                    key: key,
                    value: value
                });
            }

            if (typeof value === 'object' && value !== null) {
                recurse(value, [...path, key]);
            }
        }
    }

    recurse(obj);
    return results;
}

function matchesAllPatterns(fn) {
    const patterns = ["this.names.position", ".base[0]"].map(p => p.replace(/\s+/g, ''));
    try {
        const src = fn.toString().replace(/\s+/g, '');
        return patterns.every(p => src.includes(p));
    } catch {
        return false;
    }
}

function findClassConstructor(obj) {
    let current = obj;
    while (current) {
        for (const key of Reflect.ownKeys(current)) {
            let val;
            try {
                const desc = Object.getOwnPropertyDescriptor(current, key);
                val = desc?.value ?? current[key];
            } catch {
                continue;
            }
            if (typeof val === "function" && matchesAllPatterns(val)) {
                return val;
            }
        }
        current = Object.getPrototypeOf(current);
    }
    return null;
}

function findGhMethod(clsConstructor) {
    const protoLocal = clsConstructor?.prototype;
    if (!protoLocal) return null;

    for (const key of Reflect.ownKeys(protoLocal)) {
        if (key === "constructor") continue;
        const fn = protoLocal[key];
        if (typeof fn === "function" && matchesAllPatterns(fn)) {
            return {
                fn,
                key
            };
        }
    }
    return null;
}

const toggleBlink = (interval = 0, noPacket = false) => {
    blinkState.enabled = !blinkState.enabled;
    blinkState.interval = interval;
    blinkState.noPacket = noPacket;

    if (blinkState.enabled) {
        console.log(`[Blink] ENABLED — interval: ${interval}, noPacket: ${noPacket}`);

        colyRoom[sendBytesName] = (...args) => {

            const [J, T] = args;
            const send = () => blinkState.originalSendBytes.call(colyRoom, J, T);

            if (interval > 0) {
                setTimeout(send, interval);
            } else {
                blinkState.queued.push([J, T]);
            }
        };
    } else {
        console.log(`[Blink] DISABLED — sending ${blinkState.queued.length} packets.`);

        for (const [J, T] of blinkState.queued) {
            blinkState.originalSendBytes.call(colyRoom, J, T);
        }

        colyRoom[sendBytesName] = blinkState.originalSendBytes;
        blinkState.queued = [];
    }
};

function wangPlace(position) {

    let heldBlock = r.values(Fuxny.noa.entities[Fuxny.impKey])[22].list[0]._blockItem;
    let worldInstanceKey = Object.keys(heldBlock)[0];
    let worldInstance = Object.values(heldBlock)[0];
    let targetedBlockKey = Object.keys(worldInstance)[25];
    let targetedBlock = worldInstance[targetedBlockKey];

    function spoofTargetedBlock(position) {
        return new Proxy({}, {
            get(target, prop, receiver) {
                if (prop === worldInstanceKey) {
                    return new Proxy(worldInstance, {
                        get(inner, key) {
                            if (key === targetedBlockKey) {
                                let spoofedTargetedBlock = structuredClone(targetedBlock) || {};
                                spoofedTargetedBlock.position = position;
                                return spoofedTargetedBlock;
                            }
                            return worldInstance[key];
                        },
                    });
                }

                if (prop == "checkTargetedBlockCanBePlacedOver") {
                    return () => true;
                }

                if (typeof heldBlock[prop] == "function") {
                    return heldBlock[prop].bind(heldBlock);
                } else {
                    return heldBlock[prop];
                }
            },
        });
    }

    heldBlock.placeBlock.call(spoofTargetedBlock(position));
}

function placeToPlayer(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 3, blockZ]) || r.values(Fuxny.world)[47].call(Fuxny.world, blockX, blockY - 3, blockZ) === 0) {
        wangPlace([blockX, blockY - 3, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 2, blockZ]) || r.values(Fuxny.world)[47].call(Fuxny.world, blockX, blockY - 2, blockZ) === 0) {
        wangPlace([blockX, blockY - 2, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 1, blockZ]) || r.values(Fuxny.world)[47].call(Fuxny.world, blockX, blockY - 1, blockZ) === 0) {
        wangPlace([blockX, blockY - 1, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY, blockZ]) || r.values(Fuxny.world)[47].call(Fuxny.world, blockX, blockY, blockZ) === 0) {
        wangPlace([blockX, blockY, blockZ])
    }

}

function placeSpike(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY + 1, blockZ]) || r.values(Fuxny.world)[47].call(Fuxny.world, blockX, blockY + 1, blockZ) === 0) {
        wangPlace([blockX, blockY + 1, blockZ])
    }
}

function moveItem(itemName, desiredSlot) {
    if (!playerInventoryParent || !playerInventoryParent.playerInventory?.items) {
        console.warn("❌ playerInventoryParent is not set. Run findAndSavePlayerInventoryParent() first.");
        return false;
    }
    const items = playerInventoryParent.playerInventory.items;
    let oldSlot = null;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];

        if (!item || typeof item.name !== 'string') continue;
        const name = item.name.toLowerCase();
        if (name.includes(itemName)) {


            oldSlot = i;
            break;
        }
    }
    if (oldSlot === null) {
        console.warn(`❌ No ${itemName} found in slot 10 or higher.`);
        return false;
    }
    console.log(`🔁 Swapping ${itemName} from slot ${oldSlot} with slot ${desiredSlot}`);
    playerInventoryParent.swapPosClient(oldSlot, desiredSlot, null);
    return true;
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function bunnyHop() {
    if (!physState.isOnGround?.() || moveState.crouching || moveState.speed < 0.05) return;
    moveState.jumping = true;
    physState._hadJumpInputPrevTick = false;
    setTimeout(() => {
        moveState.jumping = false;
    }, 20);
}

function waitForElement(selector, callback) {
    if (alreadyConnected) {
        injectButton.disabled = false;
        injectButton.textContent = "Click if game loaded."
        startWebSocketWatcher();
        return;
    }
    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            for (const node of mutation.addedNodes) {
                if (node.nodeType === 1 && node.matches(selector)) {
                    observer.disconnect();
                    callback(node);
                    return;
                }
            }
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}

async function autoSW() {
    if (lastClosestId && targetEntityDistance <= 36) { // place web then spikes

        if (moveItem("net", webSlot) || moveItem("web", webSlot)) {
            let enemyPos = Fuxny.entities.getState(lastClosestId, 'position').position;

            Fuxny.noa.inputs.down['_events'][`HotBarSlot${webSlot + 1}`]();

            placeToPlayer(enemyPos);

            await sleep(50); // delay before switching to spikes

            if (moveItem("spikes", spikeSlot)) {
                Fuxny.noa.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                placeSpike(enemyPos);
            }
        } else { // just place spikes
            if (moveItem("spikes", spikeSlot)) {
                Fuxny.noa.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                await sleep(50);

                let enemyPos = Fuxny.entities.getState(lastClosestId, 'position').position;
                placeToPlayer(enemyPos);
            } else {
                console.log("no spikes or webs!");
            }
        }
        Fuxny.noa.inputs.down['_events'].HotBarSlot1();
    } else {
        console.log("No target or too far");
    }
    if (!everEnabled.autoSWUsed) {
        everEnabled.autoSWUsed = true
    };
}

function makeHitboxes() {
    if (!injectedBool) {
        console.log("NOT INJECTED NO TARGET");
        return;
    }

    const rendering = r.values(Fuxny.rendering)[18];
    const objectData = rendering?.objectData;
    if (!objectData || !eIdKey) return;

    const activeEIds = new Set();

    // First, build a set of currently valid entity IDs
    for (const key in objectData) {
        if (key === "1") continue;
        const obj = objectData[key];
        const eId = obj[eIdKey];

        if (
            eId == null ||
            eId === myId ||
            obj.pickable === false ||
            obj.type !== "Player" ||
            !Fuxny.entities.getState(eId, "genericLifeformState")
        ) continue;

        activeEIds.add(eId);

        // If hitbox already exists, skip
        if (hitboxes[eId]) continue;

        // Create the hitbox
        let newBox_00 = Fuxny.Lion.Mesh.CreateBox("mesh", 1, false, 1, Fuxny.Lion.scene);
        newBox_00.renderingGroupId = 2;

        newBox_00.material = new Fuxny.Lion.StandardMaterial("mat", Fuxny.Lion.scene);
        newBox_00.material.diffuseColor = new Fuxny.Lion.Color3(1, 1, 1);
        newBox_00.material.emissiveColor = new Fuxny.Lion.Color3(1, 1, 1);
        newBox_00.name = '_';
        newBox_00.id = '__' + eId;

        let defaultPosition = new newBox_00.position.constructor(0, 0.32, 0);
        newBox_00.position = defaultPosition.clone();
        newBox_00._scaling._y = 2.2;
        newBox_00.material.alpha = 0.5;
        newBox_00.isVisible = hitBoxEnabled;

        rendering.attachTransformNode(newBox_00, key, 13);
        r.values(Fuxny.rendering)[27].call(Fuxny.rendering, newBox_00);

        Object.defineProperty(newBox_00._nodeDataStorage, '_isEnabled', {
            get: () => true,
            set: (v) => {},
            configurable: false
        });

        hitboxes[eId] = newBox_00;
    }

    // Cleanup hitboxes of players no longer present
    for (const eId in hitboxes) {
        if (!activeEIds.has(eId)) {
            hitboxes[eId]?.dispose();
            delete hitboxes[eId];
        }
    }

    // Visibility toggle based on node[0].enabled and hitBoxEnabled
    for (const key in objectData) {
        const obj = objectData[key];
        const eId = obj?.[eIdKey];
        if (!eId || !hitboxes[eId]) continue;

        const baseNode = obj.nodes?.[0];
        if (!baseNode) continue;

        hitboxes[eId].isVisible = baseNode.enabled && hitBoxEnabled;
    }
}

function startHealthWatcher() {
    everEnabled.enemyHealthGuiEnabled = true;
    if (healthWatcherInterval) clearInterval(healthWatcherInterval);

    healthWatcherInterval = setInterval(() => {
        const list = Fuxny.entities[Fuxny.impKey].entityName.list;
        let percent = null;
        let foundTarget = false;


        for (let i = 0; i < list.length; i++) {
            const targetEntity = list[i];
            if (r.values(targetEntity)[0] === lastClosestId) {
                percent = r.values(targetEntity)[7];
                foundTarget = true;
                break;
            }
        }

        // Hide health bar if not found, or at full/near full
        if (!foundTarget || percent === 0 || percent >= 1) { // ) {
            if (resetTimeout) {
                clearTimeout(resetTimeout)
            };
            setHealthBar(100, false);
            lastPercent = null;
            return;
        }

        // Update bar only if changed
        if (percent !== null) {
            lastPercent = percent;
            lastChangeTime = Date.now();
            setHealthBar(percent * 100, true);

            if (resetTimeout) clearTimeout(resetTimeout);
            resetTimeout = setTimeout(() => {
                setHealthBar(100, false);
                lastPercent = null;
            }, 10000);
        }
    }, 300);
}

(() => {
    // Remove if already present
    const old = document.getElementById("vertical-health-bar");
    if (old) old.remove();

    // Create bar container
    const container = document.createElement("div");
    container.id = "vertical-health-bar";
    Object.assign(container.style, {
        position: "fixed",
        left: "calc(50% - 200px)", // 100px left of center
        top: "50%",
        transform: "translateY(-50%)",
        width: "4px",
        height: "200px",
        background: "#000",
        border: "2px solid black",
        zIndex: 120,
        pointerEvents: "none",
        display: "flex",
        alignItems: "flex-end",
        overflow: "hidden"
    });

    // Create fill element
    const fill = document.createElement("div");
    Object.assign(fill.style, {
        width: "100%",
        height: "100%",
        background: "limegreen",
        transform: "scaleY(1)",
        transformOrigin: "bottom",
        transition: "transform 0.2s ease, background 0.2s ease", // <-- add comma here
    });

    container.appendChild(fill);
    document.body.appendChild(container);

    // Function to compute smooth gradient color from green → red
    function getHealthColor(health) {
        const ratio = health / 100;

        if (ratio > 0.5) {
            // Bright green → orange
            const t = (ratio - 0.5) * 2;
            const r = Math.round(255 * (1 - t));
            const g = 255;
            return `rgb(${r}, ${g}, 0)`; // green to yellow to orange
        } else {
            // Orange → red
            const t = ratio * 2;
            const r = 255;
            const g = Math.round(255 * t);
            return `rgb(${r}, ${g}, 0)`; // orange to red
        }
    }


    // Global health setter and show/hide toggle
    setHealthBar = function(health, show = true) {
        const clamped = Math.max(0, Math.min(health, 100));
        fill.style.transform = `scaleY(${clamped / 100})`;
        fill.style.background = getHealthColor(clamped);
        container.style.display = show ? "flex" : "none";
    };
    setHealthBar(100, false)
})();

//Main
(function() {
    if (window.blurWall) {
        console.warn("Blur wall already exists.");
        return;
    }


    class KeybindManager {
        constructor(moduleManager) {
            this.moduleManager = moduleManager;
            this.keybinds = new Map();
            this.isBinding = false;
            this.currentBindModule = null;
            this.onBindSetCallback = null;
            this.onKeyDown = this.onKeyDown.bind(this);

            this.loadBinds(); // Load from localStorage on init
        }

        saveBinds() {
            const json = JSON.stringify(Object.fromEntries(this.keybinds));
            localStorage.setItem("blurWallKeybinds", json);
        }

        loadBinds() {
            const raw = localStorage.getItem("blurWallKeybinds");
            if (!raw) return;
            try {
                const obj = JSON.parse(raw);
                for (const [key, mod] of Object.entries(obj)) {
                    this.keybinds.set(key, mod);
                }
            } catch (e) {
                console.warn("Failed to load keybinds from localStorage:", e);
            }
        }

        setBind(moduleName, keyCode) {
            this.removeBind(moduleName);
            const existing = this.getModuleForKey(keyCode);
            if (existing) this.removeBind(existing);
            this.keybinds.set(keyCode, moduleName);
            this.saveBinds(); // Save after setting
        }

        removeBind(moduleName) {
            for (const [key, val] of this.keybinds.entries()) {
                if (val === moduleName) {
                    this.keybinds.delete(key);
                    this.saveBinds(); // Save after removal
                    break;
                }
            }
        }


        start() {
            window.addEventListener('keydown', this.onKeyDown);
        }

        stop() {
            window.removeEventListener('keydown', this.onKeyDown);
        }

        onKeyDown(event) {
            if (document.querySelector('.serenity-config-popup')) return;

            if (this.isBinding && this.currentBindModule) {
                event.preventDefault();
                event.stopPropagation();
                const keyCode = event.code;
                if (keyCode === 'Escape') return this.stopBinding(true);
                if (keyCode === 'Delete' || keyCode === 'Backspace') {
                    this.removeBind(this.currentBindModule);
                    return this.stopBinding(false, null);
                }
                this.setBind(this.currentBindModule, keyCode);
                this.stopBinding(false, keyCode);
                return;
            }

            const moduleName = this.keybinds.get(event.code);
            if (moduleName) {
                const isTyping = document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                if (isTyping) return;
                this.moduleManager.toggle(moduleName);
            }
        }

        startBinding(moduleName, callback) {
            this.isBinding = true;
            this.currentBindModule = moduleName;
            this.onBindSetCallback = callback;
        }

        stopBinding(wasCancelled, newKey = null) {
            if (this.onBindSetCallback) {
                this.onBindSetCallback(this.currentBindModule, wasCancelled, newKey);
            }
            this.isBinding = false;
            this.currentBindModule = null;
            this.onBindSetCallback = null;
        }


        getBind(moduleName) {
            for (const [key, val] of this.keybinds.entries()) {
                if (val === moduleName) return key;
            }
            return null;
        }

        getModuleForKey(keyCode) {
            return this.keybinds.get(keyCode);
        }

        getBinds() {
            return Object.fromEntries(this.keybinds);
        }
    }

    const keybindManager = new KeybindManager({
        toggle(moduleName) {
            const mod = blurWall.modules[moduleName];
            if (!mod) return;
            if (mod.type === "toggle") mod.toggle.click();
            else if (mod.type === "button") mod.onEnable();
        }
    });

    keybindManager.start();

    window.blurWall = {
        modules: {},
        categories: {},
        accentColor: defaultAccent,
        setAccent(color) {
            this.accentColor = color;
            document.querySelectorAll(".blurWall-toggle[data-active='true']").forEach(el => {
                el.style.backgroundColor = color;
            });
            const bar = document.getElementById("blur-wall-titlebar");
            if (bar) bar.style.borderTop = `1px solid ${color}`;
        },

        registerModule(module) {
            const {
                name,
                category = "Misc",
                description = "No description",
                enabled = false,
                onEnable = () => {},
                onDisable = () => {},
                type = "toggle",
                defaultBind = null,
                bindless = false,
				suppressNotifications = false
            } = module;

            if (!name) return console.warn("Module missing 'name'");
            if (this.modules[name]) return console.warn(`Module '${name}' already exists.`);

            const container = document.createElement("div");
            Object.assign(container.style, {
                display: "flex",
                flexDirection: "column",
                padding: "8px 14px",
                margin: "6px",
                backgroundColor: "#1f1f1f",
                borderRadius: "0px",
                color: "white",
                fontFamily: "sans-serif",
                fontSize: "14px",
                width: "240px",
                boxShadow: "0 0 6px rgba(0,0,0,0.9)", //0px 0px 7px 1px rgba(45,255,196,0.9
                userSelect: "none",
                cursor: "pointer"
            });
			
			container.addEventListener("click", (e) => {
				e.stopPropagation(); // stop the click from reaching the overlay
			});

			
            const topRow = document.createElement("div");
            topRow.style.display = "flex";
            topRow.style.justifyContent = "space-between";
            topRow.style.alignItems = "center";

            const label = document.createElement("span");
            label.textContent = name;
            label.style.pointerEvents = "none";

            topRow.appendChild(label);

            let toggle = null;
            if (type === "toggle") {
                toggle = document.createElement("div");
                toggle.className = "blurWall-toggle";
                toggle.dataset.active = String(enabled);
                Object.assign(toggle.style, {
                    width: "36px",
                    height: "18px",
                    borderRadius: "9px",
                    backgroundColor: enabled ? blurWall.accentColor : "#555",
                    position: "relative",
                    cursor: "pointer",
                    transition: "background 0.2s",
                    flexShrink: 0,
                });

                const knob = document.createElement("div");
                Object.assign(knob.style, {
                    width: "14px",
                    height: "14px",
                    borderRadius: "50%",
                    backgroundColor: "#fff",
                    position: "absolute",
                    top: "2px",
                    left: enabled ? "20px" : "2px",
                    transition: "left 0.2s",
                });

                toggle.appendChild(knob);
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    const isActive = toggle.dataset.active === "true";
                    toggle.dataset.active = String(!isActive);
                    toggle.style.backgroundColor = !isActive ? blurWall.accentColor : "#555";
                    knob.style.left = !isActive ? "20px" : "2px";
                    module.enabled = !isActive;
					if (!isActive) {
						if (!suppressNotifications) showTemporaryNotification(`${name} enabled`);
						onEnable({ module, element: container });
					} else {
						if (!suppressNotifications) showTemporaryNotification(`${name} disabled`);
						onDisable({ module, element: container });
					}


                };
                topRow.appendChild(toggle);
            } else if (type === "button") {
                const btn = document.createElement("button");
                btn.textContent = "Run";
                Object.assign(btn.style, {
                    fontSize: "12px",
                    padding: "2px 8px",
                    backgroundColor: "#444",
                    color: "#fff",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer"
                });
                btn.onclick = (e) => {
                    e.stopPropagation();
                    onEnable({
                        module,
                        element: container
                    });
                };
                topRow.appendChild(btn);
            }

            container.appendChild(topRow);

            if (!bindless) {
                const bindRow = document.createElement("div");
                bindRow.style.display = "none";
                bindRow.style.marginTop = "8px";
                bindRow.style.justifyContent = "space-between";
                bindRow.style.alignItems = "center";
                bindRow.style.fontSize = "12px";
                bindRow.style.color = "#ccc";

                const bindLabel = document.createElement("span");
                bindLabel.textContent = "Keybind:";

                const bindButton = document.createElement("button");
                bindButton.textContent = keybindManager.getBind(name) || defaultBind || "None";
                Object.assign(bindButton.style, {
                    marginLeft: "10px",
                    backgroundColor: "#333",
                    border: "none",
                    color: "white",
                    padding: "4px 10px",
                    borderRadius: "4px",
                    cursor: "pointer",
                    fontSize: "12px"
                });

                if (defaultBind && !keybindManager.getBind(name)) {
                    keybindManager.setBind(name, defaultBind);
                    bindButton.textContent = defaultBind;
                }

                bindButton.onclick = (e) => {
                    e.stopPropagation();
                    bindButton.textContent = "Press key...";
                    keybindManager.startBinding(name, (modName, cancelled, newKey) => {
                        bindButton.textContent = cancelled ? (keybindManager.getBind(name) || "None") : newKey;
                    });
                };

                bindRow.appendChild(bindLabel);
                bindRow.appendChild(bindButton);
                container.appendChild(bindRow);

                container.onclick = () => {
                    bindRow.style.display = bindRow.style.display === "none" ? "flex" : "none";
                };
            }

            const cat = this.categories[category] || this.categories["Misc"];
            cat.appendChild(container);

this.modules[name] = {
    name,
    category,
    description,
    enabled,
    onEnable,
    onDisable,
    type,
    defaultBind,
    bindless,
    suppressNotifications,
    element: container,
    toggle
};


			if (enabled && type === "toggle") {
				if (!suppressNotifications) showTemporaryNotification(`${name} enabled`);
				onEnable({ module, element: container });
			}
        }
    };

    const overlay = document.createElement("div");
    overlay.id = "blur-wall-overlay";
    Object.assign(overlay.style, {
        position: "fixed",
        top: "0",
        left: "0",
        width: "100vw",
        height: "100vh",
        backdropFilter: "blur(1px)", // Optional: adjust blur
        backgroundColor: "rgba(0, 0, 0, 0.05)", // Optional: adjust transparency
        zIndex: "99",
        display: "flex",
        flexDirection: "column",
        userSelect: "none",
    });

overlay.addEventListener("click", () => {
    const hideModule = blurWall.modules["hide GUI"];
    if (!hideModule) return; // Still skip if not registered yet

    // Use the same toggle logic as keybindManager
    if (hideModule.type === "toggle") {
        hideModule.toggle?.click();
    } else if (typeof hideModule.onEnable === "function") {
        hideModule.onEnable();
    }
});

    const sectionRow = document.createElement("div");
    Object.assign(sectionRow.style, {
        position: "absolute",
        top: "0",
        left: "0",
        right: "0",
        bottom: "40px",
        overflowY: "auto",
        padding: "14px",
        display: "flex",
        justifyContent: "flex-start",
        gap: "20px",
        alignItems: "flex-start",
        flexWrap: "nowrap",
        width: "fit-content", // 👈 Add this
        margin: "0 auto" // 👈 And this
    });




    const categoryNames = ["Murder", "Shifts", "Awareness", "Plane", "Misc", "Settings"];
    for (const name of categoryNames) {
        const section = document.createElement("div");
        Object.assign(section.style, {
            display: "flex",
            flexDirection: "column",
            alignItems: "flex-start", // 👈 Align modules to the top-left
            justifyContent: "flex-start", // 👈 Start at top
            gap: "6px",
            overflowY: "auto", // Optional: if you want scroll for too many modules
            maxHeight: "90vh" // Optional: prevents off-screen overflow
        });

        blurWall.categories[name] = section;
        sectionRow.appendChild(section);
    }

    const titleBar = document.createElement("div");
    titleBar.id = "blur-wall-titlebar";
    titleBar.textContent = "StopPanel";
    Object.assign(titleBar.style, {
        position: "absolute",
        bottom: "0",
        left: "0",
        width: "100%",
        height: "40px",
        backgroundColor: "rgba(0, 0, 0, 0.7)",
        color: "white",
        textAlign: "center",
        lineHeight: "40px",
        fontFamily: "sans-serif",
        fontSize: "14px",
        borderTop: `1px solid ${blurWall.accentColor}`,
        backdropFilter: "blur(5px)",
        userSelect: "none",
    });


    overlay.appendChild(sectionRow);
    overlay.appendChild(titleBar);
    document.body.appendChild(overlay);
})();

// Inject
blurWall.registerModule({
    name: "inject",
    category: "Settings",
    type: "button",
    bindless: true,
	suppressNotifications: true,
    onEnable() {


        function inject() {
            let winDescriptors = Object.getOwnPropertyDescriptors(window);
            let wpName = Object.keys(winDescriptors).find(key => winDescriptors[key]?.set?.toString().includes("++"));
            let wpInstance = window[wpName] = window[wpName];

            // HILOCATOR push
            wpInstance.push([
                [Math.floor(Math.random() * 90000) + 10000], {},
                function(wpRequire) {
                    Fuxny.findModule = (code) => wpRequire(Object.keys(wpRequire.m)[Object.values(wpRequire.m).findIndex(m => m.toString().includes(code))]);
                    Fuxny.Props = Object.values(Fuxny.findModule("nonBlocksClient:")).find(prop => typeof prop == "object");
                    Fuxny.noa = Object.values(Fuxny.Props).find(prop => prop?.entities);
                    //Credits to, you guessed it wang!
                }
            ]);


            const targetValue = r.values(Fuxny.noa.entities)[2];
            const entityEntries = Object.entries(Fuxny.noa.entities);
            Fuxny.impKey = entityEntries.find(([_, val]) => val === targetValue)?.[0];
            Fuxny.registry = r.values(Fuxny.noa)[17]
            Fuxny.rendering = r.values(Fuxny.noa)[12]
            Fuxny.entities = Fuxny.noa.entities;


            Fuxny.ECS = r.values(Fuxny.noa)[19]

            if (Fuxny.impKey) {
                console.log("importantList identified:", Fuxny.impKey);

                // Attempt to find BHOP references
                const key = Fuxny.impKey;
                if (key) {
                    const entity = Fuxny.noa.entities?.[key];
                    if (entity?.moveState?.list?.[0] && entity?.movement?.list?.[0]) {
                        playerKey = key;
                        moveState = entity.moveState.list[0];
                        physState = entity.movement.list[0];
                        cachedBHOPParent = entity;
                        console.log("✅ Cached BHOP entity data");
                    } else {
                        console.warn("⚠️ Found key but missing BHOP components");
                    }
                } else {
                    console.warn("❌ BHOP player key not found");
                }
            }

            function findeIdKey() {

                const rendering = r.values(Fuxny.rendering)[18];
                const objectData = rendering?.objectData;
                if (!objectData) return;

                const sample = objectData[1];
                for (const key in sample) {
                    if (sample[key] === 1) {
                        eIdKey = key;
                        break;
                    }
                }
            }

            findeIdKey();

            let mesh = r.values(Fuxny.rendering)[7].meshes[0];
            let scene = r.values(Fuxny.rendering)[7];
            let engine = scene.getEngine();
            let StandardMaterial = mesh.material.constructor;
            let Color3 = mesh.material.diffuseColor.constructor;
			let sceneLoaderMod = Fuxny.findModule("getEngine().displayLoadingUI()");
            const addKey = r.values(Fuxny.entities)[10]
            const addComponent = Fuxny.noa.entities[addKey];
            Fuxny.world = r.values(Fuxny.noa)[11]
            Fuxny.physics = Fuxny.noa.physics
            Fuxny.camera = Fuxny.noa.camera
            Fuxny.bloxd = Fuxny.noa.bloxd
            Fuxny.clientOptions = r.values(Fuxny.noa)[29]
            Fuxny.Lion = {
                scene,
                engine,
                InstancedMesh: mesh.constructor,
                Mesh: mesh.constructor,
                Scene: scene.constructor,
                Engine: engine.constructor,
				sceneLoader: Object.values(sceneLoaderMod).find(mod => typeof mod.ImportMesh === "function"),
                Color3,
                StandardMaterial,
                addComponent,
                addKey
            };
            playerInventoryParent = Fuxny.entities[Fuxny.impKey].inventory.list[0].opWrapper

            function autoDetectChunkDataField(chunk) {
                for (const key of Object.keys(chunk)) {
                    const val = chunk[key];
                    if (!val) continue;

                    if (
                        typeof val === "object" &&
                        Array.isArray(val.stride) &&
                        val.stride.length === 3 &&
                        (
                            Array.isArray(val.data) ||
                            ArrayBuffer.isView(val.data) // covers Uint16Array etc.
                        )
                    ) {
                        console.log("✅ Detected chunk data field:", key);
                        chunkDataField = key;
                        return key;
                    }
                }

                console.warn("❌ Failed to auto-detect chunk data field");
                return null;
            }

            autoDetectChunkDataField(Object.values(Fuxny.world[Fuxny.impKey].hash)[0]);


            const maybeEntity = r.values(r.values(Fuxny.entities[Fuxny.impKey])[22].list[0])[1];

            const hasDoAttackDirect = typeof maybeEntity?.doAttack === 'function';
            const hasDoAttackBreakingItem = typeof maybeEntity?.breakingItem?.doAttack === 'function';

            if (hasDoAttackDirect) {
                console.log("maybeEntity has doAttack");
                playerEntity = maybeEntity;
            } else if (hasDoAttackBreakingItem) {
                console.log("maybeEntity.breakingItem has doAttack");
                playerEntity = maybeEntity.breakingItem;
            } else {
                console.warn("Neither maybeEntity nor its breakingItem has doAttack");
                playerEntity = null;
            }

            function findOnlysendBytes(obj) {
                if (!obj) {
                    console.warn("❌ Provided object is null or undefined.");
                    return null;
                }

                const proto = Object.getPrototypeOf(obj);
                const props = Object.getOwnPropertyNames(proto);

                for (const key of props) {
                    if (key === 'constructor') continue;

                    const val = proto[key];
                    if (typeof val === 'function') {
                        const str = val.toString();

                        // Looser but effective pattern detection
                        const looksLikesendBytes =
                            val.length === 2 &&
                            /Protocol\.ROOM_DATA_BYTES/i.test(str) &&
                            str.includes('Uint8Array') &&
                            /typeof/.test(str) && // just check any typeof usage
                            str.includes('.encode') &&
                            (str.includes('.byteLength') || str.includes('.length')) &&
                            str.includes('.set');

                        if (looksLikesendBytes) {
                            console.log(`✅ Real sendBytes found: ${key}`);
                            return key;
                        }
                    }
                }

                console.warn("❌ sendBytes function not found.");
                return null;
            }

            // Usage
            colyRoom = r.values(Fuxny.bloxd.client.msgHandler)[0];
            sendBytesName = findOnlysendBytes(colyRoom);

            if (!colyRoom || typeof colyRoom[sendBytesName] !== "function") {
                console.warn("[Blink] colyRoom or sendBytes not ready.");
            }

            blinkState = {
                enabled: false,
                originalSendBytes: colyRoom[sendBytesName],
                queued: [],
                interval: 0,
                noPacket: false
            };




            cachedNameTagParent = Fuxny.Lion.scene
            injectedBool = true;
        }

        function setupKillAuraBox() {


            newBox = Fuxny.Lion.Mesh.CreateBox("mesh", 1, false, 1, Fuxny.Lion.scene);
            newBox.renderingGroupId = 1;
            newBoxId = Fuxny.entities.add([0, 10, 0], null, null, newBox);

            //newBox.Da = true;
            newBox.material = new Fuxny.Lion.StandardMaterial("mat", Fuxny.Lion.scene);
            newBox.material.diffuseColor = new Fuxny.Lion.Color3(1, 1, 1);
            newBox.material.emissiveColor = new Fuxny.Lion.Color3(1, 1, 1);
            newBox.name = 'BodyMesh';
            newBox.id = 'BodyMesh';
            newBox.isVisible = false;

            // Find null key
            __nullKey = null;
            for (const key in newBox) {
                if (key.length === 2 && newBox[key] === null) {
                    __nullKey = key;
                    break;
                }
            }
            if (__nullKey) {
                newBox[__nullKey] = false;
            }

            Fuxny.entityList = r.values(Fuxny.noa)[30]

            humanoidMeshlist = Fuxny.entities[Fuxny.impKey]?.humanoidMesh?.list;
            __stringKey = null;
            if (Array.isArray(humanoidMeshlist)) {
                outerLoop: for (const obj of humanoidMeshlist) {
                    for (const key in obj) {
                        if (typeof obj[key] === "string") {
                            __stringKey = key;
                            break outerLoop;
                        }
                    }
                }
            }
            else {
                console.error("❌ Invalid humanoidMeshlist path.");
            }

            // Follow loop
            function followHeadLoop() {
                if (newBox) {
                    const playerId = 1;
                    const playerPosState = Fuxny.entities.getState(playerId, "position");

                    if (playerPosState && Array.isArray(playerPosState.position)) {
                        const [x, y, z] = playerPosState.position;
                        const newPos = [x, y + 1.5, z];
                        Fuxny.entities.setPosition(newBoxId, newPos);
                    } else {
                        console.error("Player position not found or invalid");
                    }
                }

                animationFrameId = requestAnimationFrame(followHeadLoop);
            }

            // Start the loop
            animationFrameId = requestAnimationFrame(followHeadLoop);
        }

        function startTargetFinder() {
            let armourNodeNum = r.values(Fuxny.rendering)[18].getNamedNode(1, "Body|Armour")
            let closestObj = null;
            targetFinderId = setInterval(() => {
                if (!injectedBool) {

                    console.log("NOT INJECTED NO TARGET")
                }

                if (!Fuxny.entities.getState(1, "genericLifeformState").isAlive) return;

                const myPos = Fuxny.entities.getState?.(myId, 'position')?.position;
                if (!myPos) return;

                const rendering = r.values(Fuxny.rendering)[18];
                const objectData = rendering?.objectData;
                if (!objectData) return;

                if (!eIdKey) return;

                let closestId = null;
                let minDist = 100;


                for (const key in objectData) {
                    const obj = objectData[key];
                    const eId = obj[eIdKey];

                    if (
                        eId == null ||
                        obj.type !== "Player" ||
                        obj.pickable === false ||
                        eId === myId ||
                        !Fuxny.entities.getState(eId, "genericLifeformState") ||
                        !Fuxny.entities.getState(eId, "genericLifeformState").isAlive
                    ) continue;


                    if (!eId || eId === myId || obj.pickable === false || obj.type !== "Player") continue;

                    const state = Fuxny.entities.getState(eId, "genericLifeformState");
                    if (!state || !state.isAlive) continue;

                    const ent = r.values(Fuxny.entityList)?.[1]?.[eId];
                    if (!ent || ent.canAttack !== true) continue;

                    const pos = Fuxny.entities.getState(eId, 'position')?.position;
                    if (!pos) continue;

                    const dx = pos[0] - myPos[0];
                    const dy = pos[1] - myPos[1];
                    const dz = pos[2] - myPos[2];

                    if (Math.abs(dy) > 3) continue; // optional Y-axis restriction

                    const dist = dx * dx + dy * dy + dz * dz;
                    if (dist < minDist) {
                        minDist = dist;
                        closestId = eId;
                        closestObj = obj;
                    }

                }

                const armourNode = closestObj?.nodes?.[armourNodeNum];
                if (armourNode?.actuallyEnabled) {
                    newBox.name = possibleNames[1];
                    newBox.id = possibleNames[1];
                } else {
                    newBox.name = possibleNames[0];
                    newBox.id = possibleNames[0];
                }


                if (closestId != null) {
                    if (!newBox.metadata) newBox.metadata = {};
                    newBox.metadata.eId = closestId;
                    //console.log(newBox.id,"  ",closestId)
                    if (closestId !== lastClosestId) {
                        if (hitboxes[closestId]) {
                            hitboxes[closestId].material.diffuseColor = new Fuxny.Lion.Color3(1, 0, 0);
                            hitboxes[closestId].material.emissiveColor = new Fuxny.Lion.Color3(1, 0, 0);
                            for (const id in hitboxes) {
                                if (id !== closestId && hitboxes[id]) {
                                    hitboxes[id].material.diffuseColor = new Fuxny.Lion.Color3(1, 1, 1);
                                    hitboxes[id].material.emissiveColor = new Fuxny.Lion.Color3(1, 1, 1);
                                }
                            }
                        }

                        lastClosestId = closestId;
                    }
                } else {
                    lastClosestId = null;
                }

                // Final visibility and distance logic
                if (killAuraEnabled && closestId != null && minDist < 16) { //16 for now
                    newBox[__nullKey] = true;
                    targetEntityDistance = Math.floor(Math.sqrt(minDist));
                } else {
                    newBox[__nullKey] = false;
                    targetEntityDistance = null;
                }


            }, 100);
        }
        inject();
        setupKillAuraBox();
        startTargetFinder();
        setInterval(makeHitboxes, 1000);
    },

});

// Hide GUI toggle
blurWall.registerModule({
    name: "hide GUI",
    category: "Settings",
    type: "toggle",
    defaultBind: "KeyH",
	suppressNotifications: true,
    onEnable() {
        document.getElementById("blur-wall-overlay").style.display = "none";
        if (Fuxny.Props) {
            Fuxny.Props.pointerLockWrapper.removePointerUnlockRequest("Menu")
        }

    },
    onDisable() {
        document.getElementById("blur-wall-overlay").style.display = "flex";
        if (Fuxny.Props) {
            Fuxny.Props.pointerLockWrapper.requestPointerUnlock("Menu")
        }

    }
});

// Accent Color Picker button
blurWall.registerModule({
    name: "change accent",
    category: "Settings",
    type: "button",
    bindless: true,
    onEnable() {
        const input = document.createElement("input");
        input.type = "color";
        input.style.position = "fixed";
        input.style.left = "-9999px";
        document.body.appendChild(input);
        input.click();
        input.onchange = () => {
            const selectedColor = input.value;
            blurWall.setAccent(selectedColor);
            defaultAccent = selectedColor; // ✅ Save as defaultAccent
            input.remove();
        };
    }
});

// espEnabled
blurWall.registerModule({
    name: "ESP",
    category: "Awareness",
    type: "toggle",
    bindless: false,
    onEnable() {
        everEnabled.espEnabled = true;
        if (!Fuxny.impKey) return;
        espEnabled = !espEnabled;
        const groupId = espEnabled ? 2 : 0;

        if (Array.isArray(r.values(Fuxny.rendering)[18].thinMeshes)) {
            for (const thinMesh of r.values(Fuxny.rendering)[18].thinMeshes) {
                if (thinMesh?.mesh && typeof thinMesh.mesh.renderingGroupId === "number") {
                    thinMesh.mesh.renderingGroupId = groupId;
                }
            }
            console.log(`✅ Thin meshes render group set to ${groupId}`);
        } else {
            console.error("❌ thinMeshes array not found.");
        }
    },
    onDisable() {
        everEnabled.espEnabled = true;
        if (!Fuxny.impKey) return;
        espEnabled = !espEnabled;
        const groupId = espEnabled ? 2 : 0;

        if (Array.isArray(r.values(Fuxny.rendering)[18].thinMeshes)) {
            for (const thinMesh of r.values(Fuxny.rendering)[18].thinMeshes) {
                if (thinMesh?.mesh && typeof thinMesh.mesh.renderingGroupId === "number") {
                    thinMesh.mesh.renderingGroupId = groupId;
                }
            }
            console.log(`✅ Thin meshes render group set to ${groupId}`);
        } else {
            console.error("❌ thinMeshes array not found.");
        }
    },
});

// Pickup Reach
blurWall.registerModule({
    name: "pickup reach",
    category: "Plane",
    type: "toggle",
    bindless: false,
    defaultBind: null,
    onEnable() {
        if (!proto || !originalGetEntitiesInAABB) {
            const cls = findClassConstructor(Fuxny.noa.entities);
            if (!cls) {
                console.warn("[pickupReach] Could not find class constructor");
                return;
            }

            const ghMethod = findGhMethod(cls);
            if (!ghMethod) {
                console.warn("[pickupReach] Could not find getEntitiesInAABB method");
                return;
            }

            proto = cls.prototype;
            originalGetEntitiesInAABB = ghMethod.fn;
            ghMethodKey = ghMethod.key;
        }

        everEnabled.pickupReachEnabled = true;
        // Enable patch
        proto[ghMethodKey] = function(box, name) {
            const center = [
                (box.base[0] + box.max[0]) / 2,
                (box.base[1] + box.max[1]) / 2,
                (box.base[2] + box.max[2]) / 2,
            ];
            const halfSize = [
                (box.max[0] - box.base[0]) / 2,
                (box.max[1] - box.base[1]) / 2,
                (box.max[2] - box.base[2]) / 2,
            ];

            const enlarged = {
                base: center.map((c, i) => c - halfSize[i] * RANGE_MULTIPLIER),
                max: center.map((c, i) => c + halfSize[i] * RANGE_MULTIPLIER)
            };

            return originalGetEntitiesInAABB.call(this, enlarged, name);
        };
        pickupReachEnabled = true;
        console.log("[pickupReach] Patch enabled");

    },
    onDisable() {
        // Disable patch
        proto[ghMethodKey] = originalGetEntitiesInAABB;
        pickupReachEnabled = false;
        console.log("[pickupReach] Patch disabled");
    }
});

// Pickup Reach
blurWall.registerModule({
    name: "autoSW",
    category: "Murder",
    type: "button",
    bindless: false,
    defaultBind: "KeyF",
    onEnable() {
        autoSW();
    },
});

// /spawn teleport
blurWall.registerModule({
    name: "/spawn teleport",
    category: "Shifts",
    type: "button",
    bindless: false,
    onEnable() {
        function findElementByText(text) {
            const all = document.querySelectorAll('div, span, button, a');
            for (const el of all)
                if (el.textContent.trim() === text) return el;
            return null;
        }
        const teleportButtonText = findElementByText('Teleport To Lobby Spawn');
        if (teleportButtonText) {
            let clickable = teleportButtonText;
            while (clickable && !clickable.onclick && clickable.tagName !== 'BUTTON') clickable = clickable.parentElement;
            if (clickable) {
                console.log('Clicking teleport button:', clickable);
                clickable.click();
            } else {
                console.warn('No clickable parent found, trying to click text element itself');
                teleportButtonText.click();
            }
        } else console.warn('Teleport button text not found in DOM');

    },
});

// scaffold
blurWall.registerModule({
    name: "scaffold",
    category: "Plane",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        scaffoldIntervalId = setInterval(() => {
            everEnabled.scaffoldEnabled = true;
            const pos = Fuxny.entities.getState(1, 'position').position;
            if (!pos || playerEntity.heldItemState.heldType !== "CubeBlock") return;


            const exactX = pos[0];
            const exactZ = pos[2];

            const blockX = Math.floor(exactX);
            const blockY = Math.floor(pos[1]);
            const blockZ = Math.floor(exactZ);

            const checkPlace = (x, y, z) => {
                return (
                    playerEntity.checkTargetedBlockCanBePlacedOver([x, y, z]) ||
                    r.values(Fuxny.world)[47].call(Fuxny.world, x, y, z) === 0
                );
            };

            // Step 1: try block directly below
            if (checkPlace(blockX, blockY - 1, blockZ)) {
                wangPlace([blockX, blockY - 1, blockZ]);
                return;
            }

            // Step 2: check lean direction (just 4 directions)
            const dx = exactX - blockX;
            const dz = exactZ - blockZ;

            const offsets = [];

            if (dx < 0.3) offsets.push([-1, 0]); // leaning west
            if (dx > 0.7) offsets.push([1, 0]); // leaning east
            if (dz < 0.3) offsets.push([0, -1]); // leaning north
            if (dz > 0.7) offsets.push([0, 1]); // leaning south

            for (const [ox, oz] of offsets) {
                const nx = blockX + ox;
                const nz = blockZ + oz;
                if (checkPlace(nx, blockY - 1, nz)) {
                    wangPlace([nx, blockY - 1, nz]);
                    return;
                }
            }

        }, 50);
    },
    onDisable() {
        clearInterval(scaffoldIntervalId);
        scaffoldIntervalId = null;
    },
});

// Shows enemy health
blurWall.registerModule({
    name: "enemy health",
    category: "Plane",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        startHealthWatcher();
    },

    onDisable() {
        // Toggle off: clean up everything
        if (healthWatcherInterval) clearInterval(healthWatcherInterval);
        if (resetTimeout) clearTimeout(resetTimeout);
        setHealthBar(100, false); // hide bar
        lastPercent = null;
    },
});

// Sets health bar color
blurWall.registerModule({
    name: "health color",
    category: "Settings",
    type: "button",
    bindless: true,
    onEnable({
        module
    }) {

        (function() { // FROM ENTITY
            'use strict';

            const healthBar = document.getElementsByClassName("BottomScreenStatBar")[0];

            if (healthBar) {
                // Clear all conflicting styles
                healthBar.style.background = defaultAccent;
                healthBar.style.backgroundColor = 'transparent';
                healthBar.style.boxShadow = 'none';
                healthBar.style.border = 'none';
                healthBar.style.backgroundRepeat = 'no-repeat';
                healthBar.style.backgroundSize = '100% 100%';
                healthBar.style.outline = 'none';

                // Also fix child elements (some bars use internal fill divs)
                for (const child of healthBar.children) {
                    child.style.background = 'transparent';
                    child.style.backgroundColor = 'transparent';
                    child.style.boxShadow = 'none';
                    child.style.border = 'none';
                }

                // Force override with CSS injection if still persists
                const style = document.createElement('style');
                style.textContent = `
            .BottomScreenStatBar {
                background: ${defaultAccent} !important;
                background-size: 100% 100% !important;
                background-repeat: no-repeat !important;
                box-shadow: none !important;
                border: none !important;
            }
            .BottomScreenStatBar * {
                background: transparent !important;
                background-color: transparent !important;
                box-shadow: none !important;
                border: none !important;
            }
			`;
                document.head.appendChild(style);

                console.log("✅ Applied clean default gradient to health bar");
            } else {
                console.warn("❌ Could not find health bar element");
            }
        })();
    },


});

// Webs do not change player speed
blurWall.registerModule({
    name: "anti-web",
    category: "Shifts",
    type: "button",
    bindless: true,
    onEnable({
        module
    }) {

        Object.defineProperty(Fuxny.entities[Fuxny.impKey].moveState.list[0].speedMultiplier.multipliers, "inCobweb", {
            configurable: true,
            enumerable: true,
            get() {
                return 1; // always return 1
            },
            set(value) {
                // ignore all attempts to change it
            }
        });
    },


});

// Changes player ranks
blurWall.registerModule({
    name: "ranks",
    category: "Settings",
    type: "button",
    bindless: true,
    onEnable({
        module
    }) {
        Fuxny.entityList[1][1].ranks[0] = "developer";
        Fuxny.entityList[1][1].ranks[1] = "youtuber";
        Fuxny.entityList[1][1].ranks[2] = "super";
    },
});

//nametags
blurWall.registerModule({
    name: "nametags",
    category: "Awareness",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.nameTagsEnabled = true;
        if (!cachedNameTagParent) {
            nameTagsEnabled = false;
            return;
        }
        nameTagParent = cachedNameTagParent;
        nameTagsIntervalId = setInterval(() => {
            const entityList = Fuxny.entityList;
            if (!entityList || typeof entityList !== 'object') return;

            for (const subGroup of Object.values(entityList)) {
                if (!subGroup || typeof subGroup !== 'object') continue;

                for (const obj of Object.values(subGroup)) {
                    if (obj?.lobbyLeaderboardValues) {
                        try {
                            const descTag = Object.getOwnPropertyDescriptor(obj, 'hasPriorityNametag');
                            if (!descTag || descTag.configurable) {
                                Object.defineProperty(obj, 'hasPriorityNametag', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                            const descSee = Object.getOwnPropertyDescriptor(obj, 'canSee');
                            if (!descSee || descSee.configurable) {
                                Object.defineProperty(obj, 'canSee', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                        } catch (e) {}
                    }
                }
            }

            for (const key in nameTagParent) {
                const tag = nameTagParent;
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const descVisible = Object.getOwnPropertyDescriptor(tag, '_isVisible');
                        if (!descVisible || descVisible.configurable) {
                            Object.defineProperty(tag, '_isVisible', {
                                get() {
                                    return true;
                                },
                                set(val) {
                                    if (val !== true) {}
                                },
                                configurable: true
                            });
                        }

                        const descRenderGroup = Object.getOwnPropertyDescriptor(tag, 'renderingGroupId');
                        if (!descRenderGroup || descRenderGroup.configurable) {
                            Object.defineProperty(tag, 'renderingGroupId', {
                                get() {
                                    return 3;
                                },
                                set(val) {
                                    if (val !== 3) {}
                                },
                                configurable: true
                            });
                        }
                    } catch (e) {}
                }
            }
        }, 15000);
        console.log("✅ NameTag visibility lock: ON");
    },

    onDisable({
        module
    }) {
        clearInterval(nameTagsIntervalId);
        nameTagsIntervalId = null;
        if (nameTagParent) {
            for (const key in nameTagParent) {
                const tag = nameTagParent[key];
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const current = tag._isVisible;
                        delete tag._isVisible;
                        tag._isVisible = current;
                    } catch (e) {
                        console.warn("Failed to unlock _isVisible on", tag);
                    }
                }
            }
        }
        nameTagParent = null;
        console.log("🟡 NameTag visibility lock: OFF");
    },
});

// Bunny hop
blurWall.registerModule({
    name: "bhop",
    category: "Shifts",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.bhopEnabled = true;
        if (!moveState || !physState) {
            console.warn("❌ BHOP references not initialized. Did you inject?");
            bhopEnabled = false;
            return;
        }
        bhopIntervalId = setInterval(bunnyHop, 10); //was 60
        console.log("BHOP: ON");

    },
    onDisable() {
        clearInterval(bhopIntervalId);
        bhopIntervalId = null;
        console.log("BHOP: OFF");
    },
});

// Stops talking to the server
blurWall.registerModule({
    name: "blink",
    category: "Shifts",
    type: "toggle",
    bindless: false,
    defaultBind: null,
    onEnable({
        module
    }) {
        toggleBlink();
    },
    onDisable() {
        toggleBlink();
    },
});

// Turns off skyBox
blurWall.registerModule({
    name: "night",
    category: "Plane",
    type: "toggle",
    bindless: true,
    onEnable({
        module
    }) {
        everEnabled.skyBoxEnabled = true;
        (function saveSkyboxEntity() {
            for (let i = 0; i < 10000; i++) {
                const meshState = Fuxny.entities.getState(i, "mesh");
                if (meshState?.mesh?.id === "skyBox") {
                    console.log(`✔ Found skyBox entity: ${i}`);
                    skyboxEntity = i; // Save globally
                    skyboxMesh = meshState.mesh; // Optional: save mesh reference too
                    break;
                }
            }
        })();
        skyboxMesh.isVisible = false
    },
    onDisable() {
        skyboxMesh.isVisible = true;
    },
});

// No need to aim
blurWall.registerModule({
    name: "kill aura",
    category: "Murder",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.killAuraEnabled = true;
        killAuraEnabled = true;
    },
    onDisable() {
        killAuraEnabled = false;
    },
});

// Enlarges heads
blurWall.registerModule({
    name: "bigheads",
    category: "Murder",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.bigHeadsEnabled = true;
        const objectData = r.values(Fuxny.rendering)[18].objectData;
        // Initial scale-up
        for (let key in objectData) {
            let obj = objectData[key];

            if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
                let node = obj.nodes[16];

                node.scale._x = 6;
                node.scale._y = 6;
                node.scale._z = 6;

                node.position._y = -1;
            }
        }

        // Start periodic check every 10 seconds
        bigHeadsInterval = setInterval(() => {
            for (let key in objectData) {
                let obj = objectData[key];

                if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
                    let node = obj.nodes[16];

                    // Only update if scale hasn't already been changed
                    if (node.scale._x === 1 && node.scale._y === 1 && node.scale._z === 1) {
                        node.scale._x = 6;
                        node.scale._y = 6;
                        node.scale._z = 6;

                        node.position._y = -1;
                    }
                }
            }
        }, 10000); // 10 seconds
    },
    onDisable() {
        const objectData = r.values(Fuxny.rendering)[18].objectData;
        // Restore original size
        for (let key in objectData) {
            let obj = objectData[key];

            if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
                let node = obj.nodes[16];

                node.scale._x = 1;
                node.scale._y = 1;
                node.scale._z = 1;

                node.position._y = 0.7199999690055847;
            }
        }

        // Clear the interval
        clearInterval(bigHeadsInterval);
        bigHeadsInterval = null;
    },
});

// Show hitboxes
blurWall.registerModule({
    name: "hitboxes",
    category: "Murder",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        hitBoxEnabled = true;
        // Toggle visibility on all hitboxes
        for (const eId in hitboxes) {
            const box = hitboxes[eId];
            if (box && box.isVisible !== hitBoxEnabled) {
                box.isVisible = true;
            }
        }
    },
    onDisable() {
        // Toggle visibility on all hitboxes
        for (const eId in hitboxes) {
            const box = hitboxes[eId];
            if (box && box.isVisible !== hitBoxEnabled) {
                box.isVisible = false;
            }
        }
        hitBoxEnabled = false;
    },
});

// Show chests
blurWall.registerModule({
    name: "chestESP",
    category: "Awareness",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.chestESPEnabled = true;
        chestESPEnabled = !chestESPEnabled;
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    },
    onDisable({
        module
    }) {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time

    },
});

// Show ores
blurWall.registerModule({
    name: "oreESP",
    category: "Awareness",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        everEnabled.oreESPEnabled = true;
        oreESPEnabled = !oreESPEnabled;
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    },
    onDisable({
        module
    }) {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time
    },
});

// Slow hit speed
blurWall.registerModule({
    name: "kill softly",
    category: "Murder",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
        playerEntity.heldItemState.swingDuration = 1500
    },
    onDisable() {
        playerEntity.heldItemState.swingDuration = 200
    },
});

// Show player coords in Leaderboards
blurWall.registerModule({
    name: "playercoords",
    category: "Awareness",
    type: "button",
    bindless: false,
    defaultBind: "KeyG",
	onEnable({ module } = {}) {
        for (const key in Fuxny.bloxd.entityNames) {
            if (key === "1") continue;

            const nameObj = Fuxny.bloxd.entityNames[key];
            const state = Fuxny.entities.getState(key, 'position');
            if (!state || !state.position) continue;

            const pos = state.position;
            const x = Math.round(pos[0]);
            const y = Math.round(pos[1]);
            const z = Math.round(pos[2]);

            // Remove existing position suffix if any (like "Name (x, y, z)")
            const baseName = nameObj.entityName.replace(/\s*\(\-?\d+,\s*\-?\d+,\s*\-?\d+\)$/, "");

            // Update with new position
            nameObj.entityName = `${baseName} (${x}, ${y}, ${z})`;
        }
    },
});

// Removes cookies and resets page
blurWall.registerModule({
    name: "purge cookies",
    category: "Settings",
    type: "button",
    bindless: true,
    onEnable({
        module
    }) {
    window.onbeforeunload = null; // Disable unload warning

    const deleteCookie = (name, path = "/", domain = "") => {
        let cookieStr = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path};`;
        if (domain) cookieStr += `domain=${domain};`;
        document.cookie = cookieStr;
    };

    const cookies = document.cookie.split(";");
    cookies.forEach(cookie => {
        const eqPos = cookie.indexOf("=");
        const name = eqPos > -1 ? cookie.slice(0, eqPos).trim() : cookie.trim();

        // Try to delete with several likely paths
        deleteCookie(name, "/");
        deleteCookie(name, "/path"); // if your site uses a subpath

        // Optional: attempt with domain if you're on a subdomain
        const hostname = location.hostname;
        const domainParts = hostname.split(".");
        if (domainParts.length > 2) {
            // Try to delete with base domain
            const baseDomain = domainParts.slice(-2).join(".");
            deleteCookie(name, "/", baseDomain);
        }
    });

    setTimeout(() => location.reload(), 150);
    },
});

// Opens the discord
blurWall.registerModule({
    name: "❗discord❗",
    category: "Settings",
    type: "button",
    bindless: true,
    onEnable({
        module
    }) {
	window.open("https://discord.gg/G6ksFfQdaW", "_blank");
    },
});

// Execute recommended
blurWall.registerModule({
    name: "recommended Broken",
    category: "Settings",
    type: "button",
    bindless: false,
    onEnable({
        module
    }) {
        blurWall.modules["hitboxes"].onEnable()
        blurWall.modules["bhop"].onEnable()
        blurWall.modules["enemy health"].onEnable()
        blurWall.modules["ranks"].onEnable()
        blurWall.modules["anti-web"].onEnable()
        blurWall.modules["ESP"].onEnable()
        blurWall.modules["nametags"].onEnable()
        blurWall.modules["kill softly"].onEnable()
    },
});

// Execute recommended
blurWall.registerModule({
    name: "bhop knife",
    category: "Murder",
    type: "toggle",
    bindless: false,
    onEnable({
        module
    }) {
			everEnabled.bhopKnifeEnabled = true;
			bhopKnifeEnabled = true;

			spaceVid = document.createElement('video');
			spaceVid.src = 'https://files.catbox.moe/6tm4e7.webm';
			spaceVid.preload = 'auto';
			spaceVid.loop = true;
			spaceVid.muted = false;
			spaceVid.volume = 0;
			spaceVid.playbackRate = 1;
			spaceVid.playsInline = true;

			Object.assign(spaceVid.style, {
			  position: 'fixed',
			  top: '50%',
			  left: '50%',
			  width: '100vw',
			  height: '100vh',
			  objectFit: 'cover',
			  transform: 'translate(-50%, -50%) scaleX(1.4)', // Stretch only width
			  zIndex: 21,
			  pointerEvents: 'none',
			  opacity: '0',
			  transition: 'opacity 2.5s ease',
			});

			document.body.appendChild(spaceVid);

			window.addEventListener('keydown', onKeyDown);
			window.addEventListener('keyup', onKeyUp);
    },
	onDisable() {
	
    bhopKnifeEnabled = false;

    window.removeEventListener('keydown', onKeyDown);
    window.removeEventListener('keyup', onKeyUp);

    if (spaceVid) {
      spaceVid.pause();
      if (spaceVid.parentNode) spaceVid.parentNode.removeChild(spaceVid);
      spaceVid = null;
    }

    spaceHeld = false;
    if (fadeVolumeInterval) clearInterval(fadeVolumeInterval);
	},
});


blurWall.registerModule({
  name: "noclipmove",
  category: "Shifts",
  type: "toggle",
  bindless: false,
  defaultBind: null,

  onEnable({ module }) {
    startMoving();
  },

  onDisable({ module }) {
    stopMoving();
  }
});

blurWall.registerModule({
  name: "noclipplace",
  category: "Shifts",
  type: "button",
  bindless: false,
  defaultBind: null,

  onEnable({ module } = {}) {

    let pos = Fuxny.entities.getState(1, 'position').position;
    Fuxny.entities.setPosition(1, pos[0], pos[1], pos[2] + 1);

    let playerEntity = r.values(Fuxny.entities[Fuxny.impKey])[22].list[0];
    playerEntity._blockItem.placeBlock();
  },
});

blurWall.registerModule({
    name: "clear all keybinds",
    category: "Settings",
    type: "button",
    bindless: true, // no keybind for this action
    suppressNotifications: false,

    onEnable() {
        // 1. Clear localStorage entry
        localStorage.removeItem("blurWallKeybinds");

        // 2. Clear in-memory keybind map
        if (window.keybindManager) {
            keybindManager.keybinds.clear();
        }

        // 3. Update all bind buttons in the UI to say "None"
        document.querySelectorAll("#blur-wall-overlay button").forEach(btn => {
            if (btn.textContent !== "Run" && btn.textContent !== "Press key...") {
                btn.textContent = "None";
            }
        });

        showTemporaryNotification("All keybinds cleared");
    }
});

blurWall.registerModule({
    name: "walljump",
    category: "Shifts",
    type: "toggle",
    bindless: false,
    suppressNotifications: false,

    onEnable() {
        const client = Fuxny?.clientOptions;
        const body = Fuxny?.physics?.bodies?.[0];
        if (!client || !body) return;

        // Lock airJumpCount based on body.resting direction
        Object.defineProperty(client, "airJumpCount", {
            get() {
                if (!body.resting) return 0;
                const [rx, , rz] = body.resting;
                // Wall jump if touching wall (X or Z), else no jumps
                return (rx === 1 || rx === -1 || rz === 1 || rz === -1) ? 999 : 0;
            },
            set(_) {}, // Ignore writes
            configurable: true
        });
    },

    onDisable() {
        const client = Fuxny?.clientOptions;
        if (!client) return;

        // Restore airJumpCount as writable normal property
        Object.defineProperty(client, "airJumpCount", {
            value: 0,
            writable: true,
            configurable: true
        });
    }
});

blurWall.registerModule({
    name: "waterjump",
    category: "Shifts",
    type: "toggle",
    bindless: false,
    suppressNotifications: false,

    onEnable() {
        if (!injectedBool) {
            showTemporaryNotification('You need to inject first habibi!');
            return;
        }

        everEnabled.waterJumpingEnabled = true;

        const movementList = Fuxny?.entities?.[Fuxny.impKey]?.movement?.list;
        if (!Array.isArray(movementList) || movementList.length === 0) return;

        const c = movementList[0];

        try {
            Object.defineProperty(c, "inAirFromWater", {
                get: () => false,
                set: () => {},
                configurable: true
            });

            Object.defineProperty(c, "_jumpCount", {
                get: () => 0,
                set: () => {},
                configurable: true
            });

            Object.defineProperty(c, "_ticksOutOfWater", {
                get: () => 346,
                set: () => {},
                configurable: true
            });

            Object.defineProperty(c, "isOnIce", {
                get: () => true,
                set: () => {},
                configurable: true
            });

            console.log("🔒 Player water state locked");
        } catch (e) {
            console.error("Error locking player water state:", e);
        }
    },

    onDisable() {
        const movementList = Fuxny?.entities?.[Fuxny.impKey]?.movement?.list;
        if (!Array.isArray(movementList) || movementList.length === 0) return;

        const c = movementList[0];

        // Restore properties to writable defaults
        try {
            Object.defineProperty(c, "inAirFromWater", {
                value: false,
                writable: true,
                configurable: true
            });

            Object.defineProperty(c, "_jumpCount", {
                value: 0,
                writable: true,
                configurable: true
            });

            Object.defineProperty(c, "_ticksOutOfWater", {
                value: 0,
                writable: true,
                configurable: true
            });

            Object.defineProperty(c, "isOnIce", {
                value: false,
                writable: true,
                configurable: true
            });

            console.log("🔓 Player water state unlocked");
        } catch (e) {
            console.error("Error unlocking player water state:", e);
        }
    }
});


waitForElement('div.MainLoadingState.FullyFancyText', (el) => {
    console.log('Target div appeared:', el);
    blurWall.modules["inject"].onEnable();
	if (!injectedBool) {
	showTemporaryNotification("injection failed");
	} else {
		showTemporaryNotification("injection successful");
	}
});