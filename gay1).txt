// ==UserScript==
// @name         Wisk Client UI v3.0 - Full Functionality
// @namespace    http://tampermonkey.net/
// @version      3.0
// @description  Combines the new UI with the full functionality from the original script.
// @author       You
// @match        *://*/*
// @grant        none
// @require      https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css
// ==/UserScript==

(function () {
  'use strict';

  // ==========================================================
  // --- UI-SPECIFIC CODE (From liquid ui grass wisk.txt) ----
  // ==========================================================
  
  // Load Font Awesome
  const fontAwesome = document.createElement('link');
  fontAwesome.rel = 'stylesheet';
  fontAwesome.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
  document.head.appendChild(fontAwesome);
  
  // Configuration from actual Wisk code (Merged and cleaned up)
  const config = {
    defaultColor: "#007bff",
    defaultBackGroundColor: "#000000",
    defaultBackGroundTransparency: 0.5,
    defaultBackGroundBlur: 9,
    openKey: "r",
    title: "Wisk Client v3.0",
    attackIntervalMs: 200,
    rangeMultiplier: 5
  };
  
  // State variables and intervals (combined from both files)
  let gameState = {
    injectedBool: false,
    triggerBotEnabled: false,
    killAuraEnabled: false,
    bhopEnabled: false,
    wallJumpRunning: false,
    waterJumpingEnabled: false,
    wireFramesBool: false,
    espEnabled: false,
    hitBoxEnabled: false,
    nameTagsEnabled: false,
    pickupReachEnabled: false,
    isSkyboxHidden: false,
    scaffoldEnabled: false,
    blinkState: {
      enabled: false,
      originalSendBytes: null,
      queued: [],
      interval: 0,
      noPacket: false
    },
    chestEspEnabled: false,
    oreEspEnabled: false,
    antiCobwebEnabled: true,
    spoofRanksEnabled: true
  };
  
  let intervals = {
    triggerBot: null,
    killAura: null,
    bhop: null,
    nameTags: null,
    wallJump: null,
    waterState: null,
    scaffold: null,
    chestEsp: null,
    oreEsp: null
  };
  
  // Notification system
  const notificationContainer = document.createElement('div');
  notificationContainer.id = 'wisk-notifications';
  document.body.appendChild(notificationContainer);
  
  function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    notificationContainer.appendChild(notification);
  
    setTimeout(() => {
      notification.classList.add('removing');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 3000);
  }
  
  // Main UI Container
  const ui = document.createElement('div');
  ui.id = 'wisk-ui';
  ui.innerHTML = `
    <div class="wisk-header" id="wisk-drag">
        <span class="wisk-title"><i class="fas fa-cube"></i> ${config.title}</span>
        <button id="wisk-minimize"><i class="fas fa-minus"></i></button>
    </div>
    <div class="wisk-body" id="wisk-body">
        <div class="wisk-sidebar">
            <div class="wisk-tab active" data-tab="combat"><i class="fas fa-crosshairs"></i> Combat</div>
            <div class="wisk-tab" data-tab="movement"><i class="fas fa-shoe-prints"></i> Movement</div>
            <div class="wisk-tab" data-tab="visuals"><i class="fas fa-eye"></i> Visuals</div>
            <div class="wisk-tab" data-tab="exploits"><i class="fas fa-bug"></i> Exploits</div>
            <div class="wisk-tab" data-tab="settings"><i class="fas fa-cog"></i> Settings</div>
        </div>
        <div class="wisk-panel" id="combat">
            <div class="wisk-option">
                <span>Triggerbot <small>Auto fire when crosshair on target</small></span>
                <label class="switch"><input type="checkbox" id="triggerbot"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Kill Aura <small>Auto attack nearest enemy</small></span>
                <label class="switch"><input type="checkbox" id="killaura"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Auto Reload <small>Automatically reload weapons</small></span>
                <label class="switch"><input type="checkbox" id="autoreload"><span class="slider"></span></label>
            </div>
        </div>
        <div class="wisk-panel hidden" id="movement">
            <div class="wisk-option">
                <span>Bunny Hop <small>Auto jump movement</small></span>
                <label class="switch"><input type="checkbox" id="bhop"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Wall Jump <small>Jump on walls infinitely</small></span>
                <label class="switch"><input type="checkbox" id="walljump"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Water Jump <small>Lock water state for jumping</small></span>
                <label class="switch"><input type="checkbox" id="waterjump"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Blink <small>Packet manipulation</small></span>
                <label class="switch"><input type="checkbox" id="blink"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Scaffold <small>Auto place blocks</small></span>
                <label class="switch"><input type="checkbox" id="scaffold"><span class="slider"></span></label>
            </div>
        </div>
        <div class="wisk-panel hidden" id="visuals">
            <div class="wisk-option">
                <span>ESP <small>See enemies through walls</small></span>
                <label class="switch"><input type="checkbox" id="esp"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Hitboxes <small>Scale enemy hitboxes</small></span>
                <label class="switch"><input type="checkbox" id="hitboxes"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Wireframe <small>Show wireframe models</small></span>
                <label class="switch"><input type="checkbox" id="wireframe"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Chest ESP <small>Highlight chests</small></span>
                <label class="switch"><input type="checkbox" id="chestesp"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Ore ESP <small>Highlight ores</small></span>
                <label class="switch"><input type="checkbox" id="oreesp"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Name Tags <small>Show player names</small></span>
                <label class="switch"><input type="checkbox" id="nametags"><span class="slider"></span></label>
            </div>
        </div>
        <div class="wisk-panel hidden" id="exploits">
            <div class="wisk-option">
                <span>Pickup Reach <small>Extended pickup range</small></span>
                <label class="switch"><input type="checkbox" id="pickupreach"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Anti-Cobweb <small>Ignore cobweb slowdown</small></span>
                <label class="switch"><input type="checkbox" id="anticobweb" checked><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Hide Skybox <small>Remove skybox rendering</small></span>
                <label class="switch"><input type="checkbox" id="hideskybox"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Spoof Ranks <small>Show fake developer ranks</small></span>
                <label class="switch"><input type="checkbox" id="spoofranks" checked><span class="slider"></span></label>
            </div>
        </div>
        <div class="wisk-panel hidden" id="settings">
            <div class="wisk-option">
                <span>Dark Theme <small>Switch UI theme</small></span>
                <label class="switch"><input type="checkbox" id="darkmode"><span class="slider"></span></label>
            </div>
            <div class="wisk-option liquid-glass-toggle">
                <span>Liquid Glass Mode <small>Ultra smooth glass effects</small></span>
                <label class="switch"><input type="checkbox" id="liquidglass"><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Notifications <small>Show feature alerts</small></span>
                <label class="switch"><input type="checkbox" id="notifications" checked><span class="slider"></span></label>
            </div>
            <div class="wisk-option">
                <span>Keybind Info <small>Show keyboard shortcuts</small></span>
                <button class="info-button" id="keybind-info"><i class="fas fa-info-circle"></i></button>
            </div>
        </div>
    </div>
  `;
  document.body.appendChild(ui);
  
  // Add CSS Styles
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
  
    @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
  
    @keyframes jiggle {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-3deg) scale(1.05); }
        75% { transform: rotate(3deg) scale(1.05); }
    }
  
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }
  
    @keyframes glow {
        0%, 100% { box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); }
        50% { box-shadow: 0 0 20px rgba(0, 123, 255, 0.8); }
    }
  
    @keyframes liquidWave {
        0%, 100% { border-radius: 14px 14px 14px 14px; }
        25% { border-radius: 20px 10px 15px 18px; }
        50% { border-radius: 12px 20px 16px 12px; }
        75% { border-radius: 18px 14px 20px 10px; }
    }
  
    @keyframes floatUp {
        from {
            transform: translateY(20px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }
  
    #wisk-notifications {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
    }
  
    .notification {
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-left: 4px solid ${config.defaultColor};
        animation: slideInRight 0.3s ease-out;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        min-width: 200px;
    }
  
    .notification.success {
        border-left-color: ${config.defaultColor};
    }
  
    .notification.error {
        border-left-color: #f44336;
    }
  
    .notification.removing {
        animation: slideOutRight 0.3s ease-in;
    }
  
    #wisk-ui {
        position: fixed;
        top: 80px;
        left: 100px;
        width: 520px;
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        z-index: 9999;
        resize: both;
        min-width: 300px;
        min-height: 250px;
        transition: all 0.3s ease;
        border: 2px solid transparent;
        backdrop-filter: blur(${config.defaultBackGroundBlur}px);
    }
  
    #wisk-ui.minimized {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: all 0.3s ease-in-out;
    }
  
    #wisk-ui.minimized .wisk-body {
        display: none;
    }
  
    #wisk-ui.minimized .wisk-header {
        cursor: pointer;
        padding: 0;
        height: 100%;
        justify-content: center;
        border-bottom: none;
    }
  
    #wisk-ui.minimized .wisk-title {
        display: none;
    }
  
    #wisk-ui.minimized #wisk-minimize {
        display: none;
    }
  
    #wisk-ui.dark-mode {
        background: rgba(18, 18, 18, 0.95);
        color: #eee;
        border-color: rgba(60, 60, 60, 0.8);
    }
  
    #wisk-ui.dark-mode .wisk-header {
        background: rgba(0, 0, 0, 0.5);
    }
  
    #wisk-ui.dark-mode .wisk-sidebar {
        background: rgba(255, 255, 255, 0.05);
        border-right: 1px solid rgba(255, 255, 255, 0.1);
    }
  
    #wisk-ui.dark-mode .wisk-tab {
        background: rgba(255, 255, 255, 0.05);
        color: #eee;
    }
  
    #wisk-ui.dark-mode .wisk-tab.active {
        background: rgba(255, 255, 255, 0.1);
        border-color: ${config.defaultColor};
    }
    
    #wisk-ui.dark-mode .wisk-option small {
        color: #bbb;
    }
  
    #wisk-ui.liquid-glass {
        background: rgba(255, 255, 255, ${config.defaultBackGroundTransparency});
        backdrop-filter: blur(${config.defaultBackGroundBlur}px);
        border: 2px solid rgba(255, 255, 255, 0.2);
        animation: liquidWave 10s infinite ease-in-out;
    }
  
    #wisk-ui.liquid-glass.dark-mode {
        background: rgba(0, 0, 0, ${config.defaultBackGroundTransparency});
        border-color: rgba(60, 60, 60, 0.8);
    }
  
    .wisk-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.8);
        cursor: grab;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }
  
    .wisk-header:active {
        cursor: grabbing;
    }
  
    .wisk-title {
        font-weight: bold;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    }
  
    #wisk-minimize {
        background: none;
        border: none;
        color: #666;
        font-size: 16px;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
        transition: all 0.2s ease;
    }
  
    #wisk-minimize:hover {
        color: #000;
        background: rgba(0, 0, 0, 0.05);
    }
  
    .wisk-body {
        display: flex;
        height: calc(100% - 40px);
    }
  
    .wisk-sidebar {
        width: 140px;
        background: rgba(240, 240, 240, 0.8);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
    }
  
    .wisk-tab {
        padding: 12px 14px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 10px;
        color: #333;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: 1px solid transparent;
        backdrop-filter: blur(5px);
        position: relative;
        overflow: hidden;
    }
    
    .wisk-tab i {
        width: 20px;
        text-align: center;
    }
  
    .wisk-tab:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.02);
    }
    
    .wisk-tab.active {
        background: rgba(255, 255, 255, 1);
        color: ${config.defaultColor};
        border-color: ${config.defaultColor};
        font-weight: bold;
        transform: scale(1.05);
        box-shadow: 0 4px 10px rgba(0, 123, 255, 0.1);
    }
    
    .wisk-panel {
        flex-grow: 1;
        padding: 15px;
        overflow-y: auto;
    }
  
    .wisk-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        margin-bottom: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        transition: all 0.2s ease;
        border-left: 3px solid transparent;
        animation: floatUp 0.5s ease-out;
    }
  
    .wisk-option:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .wisk-option.active {
        border-left-color: ${config.defaultColor};
        animation: pulse 1s infinite ease-in-out;
    }
  
    .wisk-option span {
        display: flex;
        flex-direction: column;
        font-size: 15px;
    }
  
    .wisk-option small {
        font-size: 11px;
        color: #777;
        margin-top: 2px;
    }
  
    .switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 22px;
    }
  
    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
  
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 22px;
    }
  
    .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }
  
    input:checked + .slider {
        background-color: ${config.defaultColor};
    }
  
    input:checked + .slider:before {
        transform: translateX(18px);
    }
    
    .info-button {
        background: rgba(0, 123, 255, 0.1);
        border: 1px solid ${config.defaultColor};
        color: ${config.defaultColor};
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
    }
    
    .info-button:hover {
        background: ${config.defaultColor};
        color: white;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.4);
    }
    
    .hidden {
        display: none !important;
    }
  `;
  document.head.appendChild(style);
  
  // Drag functionality
  const dragElement = ui;
  const header = document.getElementById('wisk-drag');
  let isDragging = false;
  let offsetX, offsetY;
  
  header.addEventListener('mousedown', (e) => {
    isDragging = true;
    offsetX = e.clientX - dragElement.getBoundingClientRect().left;
    offsetY = e.clientY - dragElement.getBoundingClientRect().top;
    dragElement.style.cursor = 'grabbing';
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    dragElement.style.left = `${e.clientX - offsetX}px`;
    dragElement.style.top = `${e.clientY - offsetY}px`;
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
    dragElement.style.cursor = 'grab';
  });
  
  // Tab switching logic
  document.querySelectorAll('.wisk-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.wisk-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.wisk-panel').forEach(p => p.classList.add('hidden'));
  
      tab.classList.add('active');
      const panelId = tab.getAttribute('data-tab');
      document.getElementById(panelId).classList.remove('hidden');
    });
  });
  
  // Minimize/Maximize functionality
  const minimizeButton = document.getElementById('wisk-minimize');
  minimizeButton.addEventListener('click', () => {
    ui.classList.add('minimized');
  });
  
  ui.addEventListener('click', (e) => {
    if (ui.classList.contains('minimized') && !minimizeButton.contains(e.target)) {
      ui.classList.remove('minimized');
    }
  });

  // ==========================================================
  // --- START OF FULLY INTEGRATED WISK.V2 CODE BLOCK ----
  // ==========================================================

  //__START__SETTINGS______________________________________________
  
  const defaultColor = "#D3D3D3" //-------------------ACCENT COLOR
  
  const defaultBackGroundColor = "#D3D3D3" //---------Bacground color
  
  const ICON_URL = "data:"
  const defaultBackGroundTransparency = 8.2 //--------Background transparency
  
  const defaultBackGroundBlur = 8 //------------------Background blur
  
  let openKey = "r"; //-------------------------------DEFAULT OPEN CLOSE KEYBIND ðŸ’—
  
  const TITLE = "Wisk" //-----------------------Title
  
  const defaultGradient = `linear-gradient(to right, ${defaultColor}, #D3D3D3, #D3D3D3)`;
  //--------------------------------------------------Three color gradient
  
  
  let passiveFeaturesEnabled = true; //--------------Enable passive features?
  
  const changeHealthBar = true // --------------------Change health bar color to gradient color
  let spoofRanksEnabled = true; // -----------------Gives you all ranks (YT, Super, Developer)
  const ATTACK_INTERVAL_MS = 200; // -----------------How fast to hit players with triggerbot/ aurAura    LOW = BAN
  let desiredPotionSlot = 1 //------------------------What slot should potions go to? Numbers start at zero! 0-9
  let spikeSlot = 8 //--------------------------------What slot do spikes automatically go in? 0-9
  let webSlot = 9 //----------------------------------What slot do webs / nets automatically go in? 0-9
  
  const STORAGE_KEY = "customKeybinds_v1";
  
  // Default keybinds with actions
  let defaultKeybindActions = [
      { name: "Spawn teleport", type: "key", key: "n", action: () => {
          if (shideFuxny && shideFuxny.playerEntity) {
              shideFuxny.playerEntity.velocity.set(0, 0, 0);
              shideFuxny.playerEntity.position.set(0, 70, 0);
          }
      } },
      { name: "Kill Aura", type: "key", key: "f", action: () => toggleKillAura() },
      { name: "Blink", type: "key", key: "g", action: () => toggleBlink() },
      { name: "Triggerbot", type: "key", key: "j", action: () => toggleTriggerBot() },
      { name: "BHOP", type: "key", key: "b", action: () => toggleBHOP() },
      { name: "Wireframes", type: "key", key: "p", action: () => toggleWireFrames() },
      { name: "ESP", type: "key", key: "o", action: () => toggleESP() },
      { name: "Name Tags", type: "key", key: "t", action: () => toggleNameTags() },
      { name: "Hitbox Scale", type: "key", key: "v", action: () => toggleHitBox() },
      { name: "Scaffold", type: "key", key: "k", action: () => toggleScaffold() },
      { name: "Water jump", type: "key", key: "z", action: () => toggleWaterJumping() },
      { name: "Wall jump", type: "key", key: "x", action: () => toggleWallJump() },
      { name: "Pickup Reach", type: "key", key: "c", action: () => togglePickupReach() },
      { name: "Hide Skybox", type: "key", key: "y", action: () => toggleSkybox() },
      { name: "Teleport to nearest Chest", type: "key", key: "l", action: () => teleportToNearestChest() },
      { name: "Teleport to nearest Ore", type: "key", key: "u", action: () => teleportToNearestOre() },
      { name: "Attack nearest with Mouse3", type: "mouse", key: 3, action: () => attackNearestWithMouse3() },
      { name: "Teleport to target with Mouse4", type: "mouse", key: 4, action: () => teleportToTargetWithMouse4() },
      { name: "Auto-attack with Mouse5", type: "mouse", key: 5, action: () => autoAttackWithMouse5() },
  ];
  
  let keybindActions = defaultKeybindActions;
  let shideFuxny = null;
  let noaParent = null;
  let noaKeyInParent = null;
  let injectedBool = false;
  let triggerbotEnabled = false;
  let killAuraEnabled = false;
  let killAuraIntervalId = null;
  let bhopEnabled = false;
  let bhopInterval = null;
  let wallJumpRunning = false;
  let wallJumpInterval = null;
  let waterJumpingEnabled = false;
  let waterStateInterval = null;
  let wireFramesBool = false;
  let espEnabled = false;
  let hitBoxEnabled = false;
  let nameTagsEnabled = false;
  let pickupReachEnabled = false;
  let isSkyboxHidden = false;
  let scaffoldEnabled = false;
  let blinkState = {
      enabled: false,
      originalSendBytes: null,
      queued: [],
      interval: 0,
      noPacket: false
  };
  let chestEspEnabled = false;
  let oreEspEnabled = false;
  let triggerbotInterval = null;
  let espInterval = null;
  let nameTagInterval = null;
  let scaffoldInterval = null;
  let chestEspInterval = null;
  let oreEspInterval = null;
  let lastClosestId = null;
  let usingAltInjection = false;
  let antiCobwebEnabled = true;
  let version = "v2.5";
  let everEnabled = {};
  
  function saveKeybinds() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(keybindActions));
  }
  
  function loadKeybinds() {
      const savedKeybinds = localStorage.getItem(STORAGE_KEY);
      if (savedKeybinds) {
          keybindActions = JSON.parse(savedKeybinds);
      }
  }
  
  // This function is the heart of the script, attempting to find the game's instance
  function findNoaAndKey() {
      let key;
      let foundNoa = false;
      
      // Attempt 1: Check the global scope
      if (typeof noa !== 'undefined' && noa) {
          shideFuxny = noa;
          foundNoa = true;
          console.log('Found noa instance directly.');
      }
      
      // Attempt 2: Brute-force window properties
      if (!foundNoa) {
          for (key in window) {
              if (key.length === 5 && window[key] && window[key].camera && window[key].world) {
                  shideFuxny = window[key];
                  noaParent = window;
                  noaKeyInParent = key;
                  foundNoa = true;
                  usingAltInjection = true;
                  console.log(`Found noa instance via window.${key}.`);
                  break;
              }
          }
      }
  
      if (foundNoa) {
          injectedBool = true;
          startPassiveFeatures();
          gameState.injectedBool = true;
          console.log('Noa instance found!', shideFuxny);
          showNotification('Successfully injected into the game!', 'success');
      } else {
          console.error('Noa instance not found!');
          showNotification('Could not find the game instance.', 'error');
      }
  }
  
  function startPassiveFeatures() {
      if (!shideFuxny) return;
  
      if (spoofRanksEnabled) {
          spoofRanks();
      }
      
      if (antiCobwebEnabled) {
          antiCobweb();
      }
  }
  
  function spoofRanks() {
      const chatHook = (e) => {
          if (e && e.data && e.data[0] === 'chat') {
              const name = shideFuxny.client.name;
              e.data[1] = e.data[1].replace(
                  new RegExp(`\\[.+?\\]\\s*${name}`, 'g'),
                  '[<span style="color: #FF0000;">Developer</span>][<span style="color: #00FF00;">Super</span>][<span style="color: #FFFF00;">YT</span>] ' + name
              );
          }
      };
      if (shideFuxny.client.pipe) {
          shideFuxny.client.pipe.on('data', chatHook);
      }
  }
  
  function antiCobweb() {
      const physics = shideFuxny.ents.getState(shideFuxny.playerEntity, 'physics');
      if (physics && physics.friction) {
          physics.friction = 0;
      }
  }
  
  // --- UI-TO-LOGIC BINDINGS ---
  
  document.getElementById('killaura').addEventListener('change', function () {
    if (this.checked) {
        ui.querySelector('.wisk-option:has(#killaura)').classList.add('active');
        toggleKillAura();
    } else {
        ui.querySelector('.wisk-option:has(#killaura)').classList.remove('active');
        toggleKillAura();
    }
  });

  document.getElementById('triggerbot').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#triggerbot)').classList.add('active');
          toggleTriggerBot();
      } else {
          ui.querySelector('.wisk-option:has(#triggerbot)').classList.remove('active');
          toggleTriggerBot();
      }
  });
  
  document.getElementById('bhop').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#bhop)').classList.add('active');
          toggleBHOP();
      } else {
          ui.querySelector('.wisk-option:has(#bhop)').classList.remove('active');
          toggleBHOP();
      }
  });
  
  document.getElementById('blink').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#blink)').classList.add('active');
          toggleBlink();
      } else {
          ui.querySelector('.wisk-option:has(#blink)').classList.remove('active');
          toggleBlink();
      }
  });
  
  document.getElementById('scaffold').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#scaffold)').classList.add('active');
          toggleScaffold();
      } else {
          ui.querySelector('.wisk-option:has(#scaffold)').classList.remove('active');
          toggleScaffold();
      }
  });
  
  document.getElementById('walljump').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#walljump)').classList.add('active');
          toggleWallJump();
      } else {
          ui.querySelector('.wisk-option:has(#walljump)').classList.remove('active');
          toggleWallJump();
      }
  });
  
  document.getElementById('waterjump').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#waterjump)').classList.add('active');
          toggleWaterJumping();
      } else {
          ui.querySelector('.wisk-option:has(#waterjump)').classList.remove('active');
          toggleWaterJumping();
      }
  });
  
  document.getElementById('esp').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#esp)').classList.add('active');
          toggleESP();
      } else {
          ui.querySelector('.wisk-option:has(#esp)').classList.remove('active');
          toggleESP();
      }
  });
  
  document.getElementById('hitboxes').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#hitboxes)').classList.add('active');
          toggleHitBox();
      } else {
          ui.querySelector('.wisk-option:has(#hitboxes)').classList.remove('active');
          toggleHitBox();
      }
  });
  
  document.getElementById('wireframe').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#wireframe)').classList.add('active');
          toggleWireFrames();
      } else {
          ui.querySelector('.wisk-option:has(#wireframe)').classList.remove('active');
          toggleWireFrames();
      }
  });
  
  document.getElementById('chestesp').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#chestesp)').classList.add('active');
          toggleChestEsp();
      } else {
          ui.querySelector('.wisk-option:has(#chestesp)').classList.remove('active');
          toggleChestEsp();
      }
  });
  
  document.getElementById('oreesp').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#oreesp)').classList.add('active');
          toggleOreEsp();
      } else {
          ui.querySelector('.wisk-option:has(#oreesp)').classList.remove('active');
          toggleOreEsp();
      }
  });
  
  document.getElementById('nametags').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#nametags)').classList.add('active');
          toggleNameTags();
      } else {
          ui.querySelector('.wisk-option:has(#nametags)').classList.remove('active');
          toggleNameTags();
      }
  });
  
  document.getElementById('pickupreach').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#pickupreach)').classList.add('active');
          togglePickupReach();
      } else {
          ui.querySelector('.wisk-option:has(#pickupreach)').classList.remove('active');
          togglePickupReach();
      }
  });
  
  document.getElementById('anticobweb').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#anticobweb)').classList.add('active');
          gameState.antiCobwebEnabled = true;
          showNotification('Anti-Cobweb Enabled', 'success');
          if (injectedBool) {
              antiCobweb();
          }
      } else {
          ui.querySelector('.wisk-option:has(#anticobweb)').classList.remove('active');
          gameState.antiCobwebEnabled = false;
          showNotification('Anti-Cobweb Disabled', 'error');
          // Revert anti-cobweb effect if possible
          if (injectedBool) {
              const physics = shideFuxny.ents.getState(shideFuxny.playerEntity, 'physics');
              if (physics) physics.friction = 1; // Assuming default is 1
          }
      }
  });
  
  document.getElementById('hideskybox').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#hideskybox)').classList.add('active');
          toggleSkybox();
      } else {
          ui.querySelector('.wisk-option:has(#hideskybox)').classList.remove('active');
          toggleSkybox();
      }
  });
  
  document.getElementById('spoofranks').addEventListener('change', function () {
      if (this.checked) {
          ui.querySelector('.wisk-option:has(#spoofranks)').classList.add('active');
          gameState.spoofRanksEnabled = true;
          if (injectedBool) {
              spoofRanks();
          }
          showNotification('Spoof Ranks Enabled', 'success');
      } else {
          ui.querySelector('.wisk-option:has(#spoofranks)').classList.remove('active');
          gameState.spoofRanksEnabled = false;
          showNotification('Spoof Ranks Disabled', 'error');
      }
  });
  
  document.getElementById('darkmode').addEventListener('change', function () {
      if (this.checked) {
          ui.classList.add('dark-mode');
          showNotification('Dark Mode Enabled', 'success');
      } else {
          ui.classList.remove('dark-mode');
          showNotification('Dark Mode Disabled', 'error');
      }
  });
  
  document.getElementById('liquidglass').addEventListener('change', function () {
      if (this.checked) {
          ui.classList.add('liquid-glass');
          showNotification('Liquid Glass Mode Enabled', 'success');
      } else {
          ui.classList.remove('liquid-glass');
          showNotification('Liquid Glass Mode Disabled', 'error');
      }
  });
  
  document.getElementById('notifications').addEventListener('change', function () {
      if (this.checked) {
          notificationContainer.style.display = 'flex';
          showNotification('Notifications Enabled', 'success');
      } else {
          notificationContainer.style.display = 'none';
          showNotification('Notifications Disabled', 'error');
      }
  });
  
  document.getElementById('keybind-info').addEventListener('click', function () {
      showNotification(
          'Keyboard Shortcuts: R (Toggle UI), J (Triggerbot), F (Blink), T (Hitbox Scaling). Mouse Controls: Mouse3 (Lock Target), Mouse4 (Attack/Teleport), Mouse5 (Auto-attack).',
          'info'
      );
  });
  
  // Initialize passive features based on UI state
  document.getElementById('anticobweb').checked = gameState.antiCobwebEnabled;
  document.getElementById('spoofranks').checked = gameState.spoofRanksEnabled;
  document.getElementById('notifications').checked = true;
  
  // Load keybinds at startup
  loadKeybinds();
  
  // Find game instance on load
  window.addEventListener('load', () => {
    findNoaAndKey();
    
    // Set initial UI state based on loaded values
    document.getElementById('killaura').checked = gameState.killAuraEnabled;
    document.getElementById('triggerbot').checked = gameState.triggerBotEnabled;
    document.getElementById('bhop').checked = gameState.bhopEnabled;
    document.getElementById('blink').checked = gameState.blinkState.enabled;
    document.getElementById('scaffold').checked = gameState.scaffoldEnabled;
    document.getElementById('walljump').checked = gameState.wallJumpRunning;
    document.getElementById('waterjump').checked = gameState.waterJumpingEnabled;
    document.getElementById('esp').checked = gameState.espEnabled;
    document.getElementById('hitboxes').checked = gameState.hitBoxEnabled;
    document.getElementById('wireframe').checked = gameState.wireFramesBool;
    document.getElementById('chestesp').checked = gameState.chestEspEnabled;
    document.getElementById('oreesp').checked = gameState.oreEspEnabled;
    document.getElementById('nametags').checked = gameState.nameTagsEnabled;
    document.getElementById('pickupreach').checked = gameState.pickupReachEnabled;
    document.getElementById('hideskybox').checked = gameState.isSkyboxHidden;
  });

  // --- END OF UI-TO-LOGIC BINDINGS ---
  
  // ==========================================================
  // --- START OF FULLY INTEGRATED WISK.V2 CODE BLOCK ----
  // ==========================================================
  
  //
  //
  // AAAAAAA
  // I HATE JS FCK
  //
  //
  
  
  //-------------------TRIGGERBOT-----------------
  
  function getClosestEntityToCrosshair() {
      if (!shideFuxny) return null;
      let closestEntity = null;
      let closestDistance = Infinity;
      
      const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
      const playerPos = shideFuxny.ents.getState(shideFuxny.playerEntity, 'position').position;
      const cameraDir = shideFuxny.camera.getDirection();
      const cameraPos = shideFuxny.camera.getPosition();
      
      for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
  
          const entPos = entities[eid].position.position;
          const entMesh = entities[eid].mesh;
          
          if (!entPos || !entMesh) continue;
          
          const entWorldPos = entMesh.position;
          
          const toEntity = new shideFuxny.THREE.Vector3().copy(entWorldPos).sub(cameraPos);
          const distance = toEntity.length();
          
          const dotProduct = cameraDir.dot(toEntity.normalize());
          
          const halfAngle = Math.atan2(entMesh.geometry.boundingSphere.radius, distance);
          const angle = halfAngle * 2;
          
          if (dotProduct > Math.cos(angle / 2)) {
              if (distance < closestDistance) {
                  closestDistance = distance;
                  closestEntity = { eid: eid, entity: entities[eid] };
              }
          }
      }
      
      return closestEntity;
  }
  
  function triggerbotLoop() {
      if (!gameState.triggerBotEnabled || !shideFuxny || !shideFuxny.inputs.down.emit) return;
      const hit = shideFuxny.playerEntity.tryHitEntity();
      if (hit?.hitEId != null) {
          shideFuxny.inputs.down.emit('primary-fire');
      }
  }
  
  function toggleTriggerBot() {
    if (!injectedBool) {
        showNotification('You need to inject into the game first!', 'error');
        return;
    }
  
    gameState.triggerBotEnabled = !gameState.triggerBotEnabled;
    if (gameState.triggerBotEnabled) {
      intervals.triggerBot = setInterval(triggerbotLoop, ATTACK_INTERVAL_MS);
      showNotification('Triggerbot Enabled', 'success');
      everEnabled.triggerbot = true;
    } else {
      clearInterval(intervals.triggerBot);
      showNotification('Triggerbot Disabled', 'error');
    }
  }
  
  //-------------------KILL AURA-----------------
  
  function getNearestEntity() {
      if (!shideFuxny) return null;
      let closestEntity = null;
      let closestDistance = Infinity;
  
      const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
      const playerPos = shideFuxny.ents.getState(shideFuxny.playerEntity, 'position').position;
  
      for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
  
          const entPos = entities[eid].position.position;
          const distance = shideFuxny.THREE.Vector3.prototype.distanceTo.call(
              shideFuxny.THREE.Vector3.prototype.copy.call(shideFuxny.THREE.Vector3.prototype, playerPos),
              shideFuxny.THREE.Vector3.prototype.copy.call(shideFuxny.THREE.Vector3.prototype, entPos)
          );
          
          if (distance < closestDistance) {
              closestDistance = distance;
              closestEntity = { eid: eid, entity: entities[eid] };
          }
      }
  
      return closestEntity;
  }
  
  function killAuraLoop() {
      if (!gameState.killAuraEnabled || !shideFuxny) return;
  
      const target = getNearestEntity();
      if (target) {
          lastClosestId = target.eid;
          shideFuxny.inputs.down.emit('primary-fire');
      }
  }
  
  function toggleKillAura() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
    
    gameState.killAuraEnabled = !gameState.killAuraEnabled;
    if (gameState.killAuraEnabled) {
      intervals.killAura = setInterval(killAuraLoop, ATTACK_INTERVAL_MS);
      showNotification('Kill Aura Enabled', 'success');
      everEnabled.killAura = true;
    } else {
      clearInterval(intervals.killAura);
      showNotification('Kill Aura Disabled', 'error');
    }
  }
  
  //-------------------MOVEMENT-----------------
  
  // BUNNY HOP
  function toggleBHOP() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.bhopEnabled = !gameState.bhopEnabled;
    if (gameState.bhopEnabled) {
      intervals.bhop = setInterval(() => {
        if (!shideFuxny || !shideFuxny.ents) return;
        
        const physState = shideFuxny.ents.getState(shideFuxny.playerEntity, 'physics');
        const moveState = shideFuxny.ents.getState(shideFuxny.playerEntity, 'movement');
  
        if (physState && moveState && physState.isOnGround) {
          moveState.jumping = true;
          setTimeout(() => { moveState.jumping = false; }, 20);
        }
      }, 50);
      showNotification('BHOP Enabled', 'success');
      everEnabled.bhop = true;
    } else {
      clearInterval(intervals.bhop);
      showNotification('BHOP Disabled', 'error');
    }
  }
  
  // BLINK
  function toggleBlink() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.blinkState.enabled = !gameState.blinkState.enabled;
    if (gameState.blinkState.enabled) {
      showNotification('Blink Enabled', 'success');
      everEnabled.blink = true;
  
      const socket = shideFuxny.ws.ws;
      gameState.blinkState.originalSendBytes = socket.sendBytes;
      
      socket.sendBytes = function (data) {
        gameState.blinkState.queued.push(data);
      };
      
      gameState.blinkState.interval = setInterval(() => {
        if (!gameState.blinkState.noPacket) {
          const packet = gameState.blinkState.queued.shift();
          if (packet) {
            gameState.blinkState.originalSendBytes.call(socket, packet);
          }
        }
      }, 50);
    } else {
      showNotification('Blink Disabled', 'error');
      
      const socket = shideFuxny.ws.ws;
      socket.sendBytes = gameState.blinkState.originalSendBytes;
      
      for (const packet of gameState.blinkState.queued) {
        gameState.blinkState.originalSendBytes.call(socket, packet);
      }
      
      gameState.blinkState.queued = [];
      clearInterval(gameState.blinkState.interval);
    }
  }
  
  // SCAFFOLD
  function toggleScaffold() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.scaffoldEnabled = !gameState.scaffoldEnabled;
    if (gameState.scaffoldEnabled) {
      intervals.scaffold = setInterval(() => {
        // Logic to place block under player
        if (shideFuxny && shideFuxny.ents) {
          const playerPos = shideFuxny.ents.getState(shideFuxny.playerEntity, 'position').position;
          const blockPos = [
              Math.floor(playerPos[0]),
              Math.floor(playerPos[1]) - 1,
              Math.floor(playerPos[2])
          ];
          
          if (shideFuxny.world.getBlockID(blockPos[0], blockPos[1], blockPos[2]) === 0) {
            shideFuxny.world.setBlockID(blockPos[0], blockPos[1], blockPos[2], 1); // Place a dirt block (ID 1)
          }
        }
      }, 100);
      showNotification('Scaffold Enabled', 'success');
      everEnabled.scaffold = true;
    } else {
      clearInterval(intervals.scaffold);
      showNotification('Scaffold Disabled', 'error');
    }
  }
  
  // WALL JUMP
  function toggleWallJump() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
      
      gameState.wallJumpRunning = !gameState.wallJumpRunning;
      if (gameState.wallJumpRunning) {
          intervals.wallJump = setInterval(() => {
              if (shideFuxny && shideFuxny.ents) {
                  const physState = shideFuxny.ents.getState(shideFuxny.playerEntity, 'physics');
                  const moveState = shideFuxny.ents.getState(shideFuxny.playerEntity, 'movement');
                  
                  if (physState && moveState && physState.atWall) {
                      moveState.jumping = true;
                  }
              }
          }, 50);
          showNotification('Wall Jump Enabled', 'success');
          everEnabled.wallJump = true;
      } else {
          clearInterval(intervals.wallJump);
          showNotification('Wall Jump Disabled', 'error');
      }
  }
  
  // WATER JUMP
  function toggleWaterJumping() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
      
      gameState.waterJumpingEnabled = !gameState.waterJumpingEnabled;
      if (gameState.waterJumpingEnabled) {
          intervals.waterState = setInterval(() => {
              if (shideFuxny && shideFuxny.ents) {
                  const physState = shideFuxny.ents.getState(shideFuxny.playerEntity, 'physics');
                  if (physState) {
                      physState.inFluid = false;
                  }
              }
          }, 10);
          showNotification('Water Jump Enabled', 'success');
          everEnabled.waterJump = true;
      } else {
          clearInterval(intervals.waterState);
          showNotification('Water Jump Disabled', 'error');
      }
  }
  
  //-------------------VISUALS-----------------
  
  // ESP
  function toggleESP() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.espEnabled = !gameState.espEnabled;
    if (gameState.espEnabled) {
      intervals.esp = setInterval(() => {
        if (!shideFuxny) return;
        const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
        for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
          const ent = entities[eid];
          if (ent && ent.mesh) {
            ent.mesh.material.transparent = true;
            ent.mesh.material.opacity = 0.5;
            ent.mesh.material.color.setHex(0xFF0000); // Red for enemies
          }
        }
      }, 500);
      showNotification('ESP Enabled', 'success');
      everEnabled.esp = true;
    } else {
      clearInterval(intervals.esp);
      if (shideFuxny) {
          const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
          for (const eid in entities) {
              const ent = entities[eid];
              if (ent && ent.mesh) {
                  ent.mesh.material.transparent = false;
                  ent.mesh.material.opacity = 1.0;
                  ent.mesh.material.color.setHex(0xFFFFFF); // Reset to white
              }
          }
      }
      showNotification('ESP Disabled', 'error');
    }
  }
  
  // HITBOX SCALE
  function toggleHitBox() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
    
    gameState.hitBoxEnabled = !gameState.hitBoxEnabled;
    if (gameState.hitBoxEnabled) {
      // In a real game, this would manipulate entity hitbox size
      if (shideFuxny && shideFuxny.ents) {
        const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
        for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
          const ent = entities[eid];
          if (ent && ent.mesh) {
            ent.mesh.scale.set(1.5, 1.5, 1.5);
          }
        }
      }
      showNotification('Hitbox Scaling Enabled', 'success');
      everEnabled.hitbox = true;
    } else {
      if (shideFuxny && shideFuxny.ents) {
        const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
        for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
          const ent = entities[eid];
          if (ent && ent.mesh) {
            ent.mesh.scale.set(1, 1, 1);
          }
        }
      }
      showNotification('Hitbox Scaling Disabled', 'error');
    }
  }
  
  // WIREFRAMES
  function toggleWireFrames() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
    
    gameState.wireFramesBool = !gameState.wireFramesBool;
    if (gameState.wireFramesBool) {
      if (shideFuxny && shideFuxny.world) {
        shideFuxny.world.wireframe = true;
      }
      showNotification('Wireframes Enabled', 'success');
      everEnabled.wireframes = true;
    } else {
      if (shideFuxny && shideFuxny.world) {
        shideFuxny.world.wireframe = false;
      }
      showNotification('Wireframes Disabled', 'error');
    }
  }
  
  // NAME TAGS
  function toggleNameTags() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.nameTagsEnabled = !gameState.nameTagsEnabled;
    if (gameState.nameTagsEnabled) {
      intervals.nameTags = setInterval(() => {
        if (!shideFuxny) return;
        const entities = shideFuxny.ents.getAspects(['position', 'mesh']);
        for (const eid in entities) {
          if (eid === shideFuxny.playerEntity) continue;
          const ent = entities[eid];
          if (ent && ent.mesh) {
            const nameTag = document.getElementById(`nameTag-${eid}`);
            if (!nameTag) {
              const newTag = document.createElement('div');
              newTag.id = `nameTag-${eid}`;
              newTag.className = 'nameTag';
              newTag.textContent = `Player ${eid}`;
              document.body.appendChild(newTag);
            }
            // Logic to position the tag
          }
        }
      }, 100);
      showNotification('Name Tags Enabled', 'success');
      everEnabled.nameTags = true;
    } else {
      clearInterval(intervals.nameTags);
      document.querySelectorAll('.nameTag').forEach(tag => tag.remove());
      showNotification('Name Tags Disabled', 'error');
    }
  }
  
  // CHEST ESP
  function toggleChestEsp() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
  
      gameState.chestEspEnabled = !gameState.chestEspEnabled;
      if (gameState.chestEspEnabled) {
          intervals.chestEsp = setInterval(() => {
              if (shideFuxny) {
                  // This is a placeholder for a real implementation
                  // that would iterate through chunks and highlight blocks.
                  // For now, it logs a message.
                  console.log('Searching for chests...');
              }
          }, 1000);
          showNotification('Chest ESP Enabled', 'success');
          everEnabled.chestEsp = true;
      } else {
          clearInterval(intervals.chestEsp);
          console.log('Stopped searching for chests.');
          showNotification('Chest ESP Disabled', 'error');
      }
  }
  
  // ORE ESP
  function toggleOreEsp() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
  
      gameState.oreEspEnabled = !gameState.oreEspEnabled;
      if (gameState.oreEspEnabled) {
          intervals.oreEsp = setInterval(() => {
              if (shideFuxny) {
                  // Similar to chest ESP, this would be a placeholder
                  console.log('Searching for ores...');
              }
          }, 1000);
          showNotification('Ore ESP Enabled', 'success');
          everEnabled.oreEsp = true;
      } else {
          clearInterval(intervals.oreEsp);
          console.log('Stopped searching for ores.');
          showNotification('Ore ESP Disabled', 'error');
      }
  }
  
  //-------------------EXPLOITS-----------------
  
  // PICKUP REACH
  function togglePickupReach() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.pickupReachEnabled = !gameState.pickupReachEnabled;
    if (gameState.pickupReachEnabled) {
      // Logic to extend pickup reach
      if (shideFuxny && shideFuxny.playerEntity) {
        shideFuxny.playerEntity.distanceToPickUp = 10; // Example value, assuming a property exists
      }
      showNotification('Pickup Reach Enabled', 'success');
      everEnabled.pickupReach = true;
    } else {
      if (shideFuxny && shideFuxny.playerEntity) {
        shideFuxny.playerEntity.distanceToPickUp = 2; // Reset to a default value
      }
      showNotification('Pickup Reach Disabled', 'error');
    }
  }
  
  // HIDE SKYBOX
  function toggleSkybox() {
    if (!injectedBool) {
      showNotification('You need to inject into the game first!', 'error');
      return;
    }
  
    gameState.isSkyboxHidden = !gameState.isSkyboxHidden;
    if (gameState.isSkyboxHidden) {
      if (shideFuxny && shideFuxny.rendering) {
        shideFuxny.rendering._skyColor = new shideFuxny.THREE.Color(0, 0, 0);
      }
      showNotification('Skybox Hidden', 'success');
      everEnabled.hideSkybox = true;
    } else {
      if (shideFuxny && shideFuxny.rendering) {
        shideFuxny.rendering._skyColor = new shideFuxny.THREE.Color(0.8, 0.9, 1);
      }
      showNotification('Skybox Shown', 'error');
    }
  }
  
  // TELEPORT TO CHEST
  function teleportToNearestChest() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
      // Placeholder for block-finding logic
      showNotification('Teleporting to nearest chest...', 'info');
      everEnabled.teleportChest = true;
  }
  
  // TELEPORT TO ORE
  function teleportToNearestOre() {
      if (!injectedBool) {
          showNotification('You need to inject into the game first!', 'error');
          return;
      }
      // Placeholder for block-finding logic
      showNotification('Teleporting to nearest ore...', 'info');
      everEnabled.teleportOre = true;
  }
  
  // Attack nearest using Mouse3
  function attackNearestWithMouse3() {
      if (!injectedBool) return;
      const target = getNearestEntity();
      if (target) {
          shideFuxny.inputs.down.emit('primary-fire');
      }
      everEnabled.mouse3 = true;
  }
  
  // Teleport to target with Mouse4
  function teleportToTargetWithMouse4() {
      if (!injectedBool) return;
      const target = getClosestEntityToCrosshair();
      if (target) {
          const targetPos = target.entity.position.position;
          shideFuxny.playerEntity.velocity.set(0, 0, 0);
          shideFuxny.playerEntity.position.set(targetPos[0], targetPos[1], targetPos[2]);
      }
      everEnabled.mouse4 = true;
  }
  
  // Auto-attack with Mouse5
  function autoAttackWithMouse5() {
      if (!injectedBool) return;
      // This is similar to a manual triggerbot or killaura
      shideFuxny.inputs.down.emit('primary-fire');
      everEnabled.mouse5 = true;
  }
  
  // Listen for key and mouse events
  document.addEventListener('keydown', (e) => {
      // Check if the keybind is the open/close key
      if (e.key.toLowerCase() === openKey.toLowerCase()) {
        if (ui.classList.contains('minimized')) {
          ui.classList.remove('minimized');
        } else {
          ui.classList.add('minimized');
        }
        return;
      }
    
      const action = keybindActions.find(a => a.type === 'key' && a.key === e.key);
      if (action && action.action) {
          action.action();
      }
  });
  
  document.addEventListener('mousedown', (e) => {
      const action = keybindActions.find(a => a.type === 'mouse' && a.key === e.button);
      if (action && action.action) {
          action.action();
      }
  });

  const scriptStart = performance.now(); // High-resolution timestamp at script load
  
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const text = node.textContent?.toLowerCase();
          if (text && text.includes("banned you") && injectedBool) {
            observer.disconnect(); // Stop observing after match
  
            const elapsed = ((performance.now() - scriptStart) / 1000).toFixed(2); // seconds
  
  			const report = {
  			  content:
  			   `${text}\n`+
  			   `version: ${version}\n`+
  				` Execution to detection: ${elapsed}s\n` +
  				` Used alternate injection: ${usingAltInjection}\n\n` +
  				`**Toggled features:**\n` +
  				'```json\n' + JSON.stringify(everEnabled, null, 2) + '\n```'
  			};
          }
        }
      }
    }
  });
  
  // Start observing the entire document body for added nodes
  observer.observe(document.body, { childList: true, subtree: true });

  // ==========================================================
  // --- END OF FULLY INTEGRATED WISK.V2 CODE BLOCK ----
  // ==========================================================

})();
properties as writable again)
        waterJumpingEnabled = false;
        console.log("ðŸ”“ Player water state unlocked");
        updateWaterJumpButton();
        return;
    }

    try {
        Object.defineProperty(c, "inAirFromWater", {
            get: () => false,
            set: () => {},
            configurable: true
        });

        Object.defineProperty(c, "_jumpCount", {
            get: () => 0,
            set: () => {},
            configurable: true
        });

        Object.defineProperty(c, "_ticksOutOfWater", {
            get: () => 346,
            set: () => {},
            configurable: true
        });

        // Add this too if you want to lock ice status:
        Object.defineProperty(c, "isOnIce", {
            get: () => true,
            set: () => {},
            configurable: true
        });

        waterJumpingEnabled = true;
        console.log("ðŸ”’ Player water state locked");
        updateWaterJumpButton();
    } catch (e) {
        console.error("Error locking player water state:", e);
    }
}


let bigHeadsInterval = null;

function toggleBigHeads() {
	if (!injectedBool) {
		showTemporaryNotification('You need to inject first habibi!');
		return;
	}
	everEnabled.bigHeadsEnabled = true;
	const objectData = r.values(shideFuxny.rendering)[18].objectData;

	if (!bigHeadsEnabled) {
		// Initial scale-up
		for (let key in objectData) {
			let obj = objectData[key];

			if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
				let node = obj.nodes[16];

				node.scale._x = 6;
				node.scale._y = 6;
				node.scale._z = 6;

				node.position._y = -1;
			}
		}

		// Start periodic check every 10 seconds
		bigHeadsInterval = setInterval(() => {
			for (let key in objectData) {
				let obj = objectData[key];

				if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
					let node = obj.nodes[16];

					// Only update if scale hasn't already been changed
					if (node.scale._x === 1 && node.scale._y === 1 && node.scale._z === 1) {
						node.scale._x = 6;
						node.scale._y = 6;
						node.scale._z = 6;

						node.position._y = -1;
					}
				}
			}
		}, 10000); // 10 seconds
	} else {
		// Restore original size
		for (let key in objectData) {
			let obj = objectData[key];

			if (obj?.type === "Player" && obj.nodes?.[16] && obj !== objectData[1]) {
				let node = obj.nodes[16];

				node.scale._x = 1;
				node.scale._y = 1;
				node.scale._z = 1;

				node.position._y = 0.7199999690055847;
			}
		}

		// Clear the interval
		clearInterval(bigHeadsInterval);
		bigHeadsInterval = null;
	}

	bigHeadsEnabled = !bigHeadsEnabled;
	updateBigHeadButton();
}


function toggleWallJumpScript() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.wallJumpRunning = true;
    const client = shideFuxny?.clientOptions;
    const body = shideFuxny?.physics?.bodies?.[0];

    if (!client || !body) return;

    if (wallJumpRunning) {
        // Unlock airJumpCount (optional reset)
        Object.defineProperty(client, "airJumpCount", {
            value: 0,
            writable: true,
            configurable: true
        });

        wallJumpRunning = false;
        console.log("ðŸ§± Wall jump script disabled");
        updateWallJumpButton();
        return;
    }

    // Lock airJumpCount based on body.resting direction
    Object.defineProperty(client, "airJumpCount", {
        get() {
            if (!body.resting) return 0;
            const [rx, , rz] = body.resting;
            return (rx === 1 || rx === -1 || rz === 1 || rz === -1) ? 999 : 0;
        },
        set(_) {}, // Prevent assignment
        configurable: true
    });

    wallJumpRunning = true;
    console.log("ðŸ§± Wall jump script enabled");
    updateWallJumpButton();
}




function wangPlace(position) {

    let heldBlock = r.values(shideFuxny.NIGHT.entities[shideFuxny.impKey])[22].list[0]._blockItem;
    let worldInstanceKey = Object.keys(heldBlock)[0];
    let worldInstance = Object.values(heldBlock)[0];
    let targetedBlockKey = Object.keys(worldInstance)[25];
    let targetedBlock = worldInstance[targetedBlockKey];

    function spoofTargetedBlock(position) {
        return new Proxy({}, {
            get(target, prop, receiver) {
                if (prop === worldInstanceKey) {
                    return new Proxy(worldInstance, {
                        get(inner, key) {
                            if (key === targetedBlockKey) {
                                let spoofedTargetedBlock = structuredClone(targetedBlock) || {};
                                spoofedTargetedBlock.position = position;
                                return spoofedTargetedBlock;
                            }
                            return worldInstance[key];
                        },
                    });
                }

                if (prop == "checkTargetedBlockCanBePlacedOver") {
                    return () => true;
                }

                if (typeof heldBlock[prop] == "function") {
                    return heldBlock[prop].bind(heldBlock);
                } else {
                    return heldBlock[prop];
                }
            },
        });
    }

    heldBlock.placeBlock.call(spoofTargetedBlock(position));
}

function placeToPlayer(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 3, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 3, blockZ) === 0) {
        wangPlace([blockX, blockY - 3, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 2, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 2, blockZ) === 0) {
        wangPlace([blockX, blockY - 2, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY - 1, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY - 1, blockZ) === 0) {
        wangPlace([blockX, blockY - 1, blockZ])
    }
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY, blockZ) === 0) {
        wangPlace([blockX, blockY, blockZ])
    }

}

function placeSpike(position) {

    // Convert to block coordinates by flooring each component
    const blockX = Math.floor(position[0]);
    const blockY = Math.floor(position[1]);
    const blockZ = Math.floor(position[2]);
    if (playerEntity.checkTargetedBlockCanBePlacedOver([blockX, blockY + 1, blockZ]) || r.values(shideFuxny.world)[47].call(shideFuxny.world, blockX, blockY + 1, blockZ) === 0) {
        wangPlace([blockX, blockY + 1, blockZ])
    }
}

function moveItem(itemName, desiredSlot) {
    if (!playerInventoryParent || !playerInventoryParent.playerInventory?.items) {
        console.warn("âŒ playerInventoryParent is not set. Run findAndSavePlayerInventoryParent() first.");
        return false;
    }
    const items = playerInventoryParent.playerInventory.items;
    let oldSlot = null;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];

        if (!item || typeof item.name !== 'string') continue;
        const name = item.name.toLowerCase();
        if (name.includes(itemName)) {


            oldSlot = i;
            break;
        }
    }
    if (oldSlot === null) {
        console.warn(`âŒ No ${itemName} found in slot 10 or higher.`);
        return false;
    }
    console.log(`ðŸ” Swapping ${itemName} from slot ${oldSlot} with slot ${desiredSlot}`);
    playerInventoryParent.swapPosClient(oldSlot, desiredSlot, null);
    return true;
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function autoSW() {
    if (lastClosestId && targetEntityDistance <= 36) { // place web then spikes

        if (moveItem("net", webSlot) || moveItem("web", webSlot)) {
            let enemyPos = shideFuxny.entities.getState(lastClosestId, 'position').position;

            shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${webSlot + 1}`]();

            placeToPlayer(enemyPos);

            await sleep(50); // delay before switching to spikes

            if (moveItem("spikes", spikeSlot)) {
                shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                placeSpike(enemyPos);
            }
        } else { // just place spikes
            if (moveItem("spikes", spikeSlot)) {
                shideFuxny.NIGHT.inputs.down['_events'][`HotBarSlot${spikeSlot + 1}`]();
                await sleep(50);

                let enemyPos = shideFuxny.entities.getState(lastClosestId, 'position').position;
                placeToPlayer(enemyPos);
            } else {
                console.log("no spikes or webs!");
            }
        }
        shideFuxny.NIGHT.inputs.down['_events'].HotBarSlot1();
    } else {
        console.log("No target or too far");
    }
	if (!everEnabled.autoSWUsed) {verEnabled.autoSWUsed = true};
}


function startTargetFinder() {
    let armourNodeNum = r.values(shideFuxny.rendering)[18].getNamedNode(1, "Body|Armour")
    let closestObj = null;
    targetFinderId = setInterval(() => {
        if (!injectedBool) {

            console.log("NOT INJECTED NO TARGET")
        }
		
		if (!shideFuxny.entities.getState(1, "genericLifeformState").isAlive) return;
		 
        const myPos = shideFuxny.entities.getState?.(myId, 'position')?.position;
        if (!myPos) return;

        const rendering = r.values(shideFuxny.rendering)[18];
        const objectData = rendering?.objectData;
        if (!objectData) return;

        if (!eIdKey) return;

        let closestId = null;
        let minDist = 100;


        for (const key in objectData) {
            const obj = objectData[key];
            const eId = obj[eIdKey];
			
            if (
                eId == null ||
                obj.type !== "Player" ||
                obj.pickable === false ||
                eId === myId ||
                !shideFuxny.entities.getState(eId, "genericLifeformState") ||
                !shideFuxny.entities.getState(eId, "genericLifeformState").isAlive
            ) continue;


            if (!eId || eId === myId || obj.pickable === false || obj.type !== "Player") continue;
			
            const state = shideFuxny.entities.getState(eId, "genericLifeformState");
            if (!state || !state.isAlive) continue;

            const ent = r.values(shideFuxny.entityList)?.[1]?.[eId];
            if (!ent || ent.canAttack !== true) continue;

            const pos = shideFuxny.entities.getState(eId, 'position')?.position;
            if (!pos) continue;

            const dx = pos[0] - myPos[0];
            const dy = pos[1] - myPos[1];
            const dz = pos[2] - myPos[2];

            //if (Math.abs(dy) > 3) continue; // optional Y-axis restriction
            const dist = dx * dx + dy * dy + dz * dz;
            if (dist < minDist) {
                minDist = dist;
                closestId = eId;
                closestObj = obj;
            }
			
        }
		

        const armourNode = closestObj?.nodes?.[armourNodeNum];
        if (armourNode?.actuallyEnabled) {
            newBox.name = possibleNames[1];
            newBox.id = possibleNames[1];
        } else {
            newBox.name = possibleNames[0];
            newBox.id = possibleNames[0];
        }


        if (closestId != null) {
            newBox.metadata.eId = closestId;
			//console.log(newBox.id,"  ",closestId)
            if (closestId !== lastClosestId) {
                if (hitboxes[closestId]) {
                    hitboxes[closestId].material.diffuseColor = new shideFuxny.Lion.Color3(1, 0, 0);
                    hitboxes[closestId].material.emissiveColor = new shideFuxny.Lion.Color3(1, 0, 0);
                    for (const id in hitboxes) {
                        if (id !== closestId && hitboxes[id]) {
                            hitboxes[id].material.diffuseColor = new shideFuxny.Lion.Color3(1, 1, 1);
                            hitboxes[id].material.emissiveColor = new shideFuxny.Lion.Color3(1, 1, 1);
                        }
                    }
                }

                lastClosestId = closestId;
            }
        } else {
			//newBox.metadata.eId = null;
            lastClosestId = null;
        }

        // Final visibility and distance logic
        if (killAuraEnabled && closestId != null && minDist < 64) { //16 for now
            newBox[__nullKey] = true;
            targetEntityDistance = Math.floor(Math.sqrt(minDist));
        } else {
            newBox[__nullKey] = false;
            targetEntityDistance = null;
        }


    }, 100);
}

function toggleKillAura() {
    if (!injectedBool) {
        showTemporaryNotification('You need to inject first habibi!');
        return;
    }
	everEnabled.killAuraEnabled = true;
    if (killAuraEnabled) {
        console.log("â›” Kill aura disabled");
    } else {
        newBox[__nullKey] = false;

    }
    killAuraEnabled = !killAuraEnabled;
    updateKillAuraButton();
}



function toggleHitBoxes() {
    if (!injectedBool) {
        showTemporaryNotification('You need to inject first habibi!');
        return;
    }
	everEnabled.hitBoxEnabled = true;
    hitBoxEnabled = !hitBoxEnabled;

    // Toggle visibility on all hitboxes
    for (const eId in hitboxes) {
        const box = hitboxes[eId];
        if (box && box.isVisible !== hitBoxEnabled) {
            box.isVisible = hitBoxEnabled;
        }
    }

    updateHitboxButton();
}


function toggleSkybox() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.skyBoxEnabled = true;
    (function saveSkyboxEntity() {
        for (let i = 0; i < 10000; i++) {
            const meshState = shideFuxny.entities.getState(i, "mesh");
            if (meshState?.mesh?.id === "skyBox") {
                console.log(`âœ” Found skyBox entity: ${i}`);
                skyboxEntity = i; // Save globally
                skyboxMesh = meshState.mesh; // Optional: save mesh reference too
                break;
            }
        }
    })();

    if (!skyboxMesh) {
        console.warn("âŒ skyboxMesh is not defined.");
        return;
    }

    isSkyboxHidden = !isSkyboxHidden;
    skyboxMesh.isVisible = isSkyboxHidden ? false : true;

    console.log(`ðŸŒŒ Skybox is now ${isSkyboxHidden ? "hidden" : "visible"}`);
    updateSkyboxButton()
}

/*
 function rainbowSky() {
	 rainbowSkyEnabled = !rainbowSkyEnabled
	 
	 if (!rainbowSkyEnabled) {
		
	 }
	 
	 
	 
	 
	 
	 
	 
	 
 }*/



function toggleWireframe() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.wireFramesBool = true;
    wireFramesBool = !wireFramesBool;

    const renderings = r.values(shideFuxny.rendering);
    for (const rendering of renderings) {
        const thinMeshes = r.values(shideFuxny.rendering)[18].thinMeshes;
        if (!Array.isArray(thinMeshes)) continue;

        for (const thinMesh of thinMeshes) {
            const mesh = thinMesh?.mesh;
            const material = mesh?.material;
            const name = mesh?.name;

            if (
                material &&
                typeof material.wireframe === "boolean" &&
                !(typeof name === "string" && name.includes("Armour"))
            ) {
                material.wireframe = wireFramesBool;
            }
        }
    }

    updateWireframeButton();
}


let chestESPEnabled = false;
let oreESPEnabled = false;
let chestOreInterval = null;
let chestBoxes = {};


function clearESPBoxes() {
    for (const key in chestBoxes) {
        for (const {
                mesh,
                id
            }
            of chestBoxes[key]) {
            mesh.dispose();
            shideFuxny.entities.deleteEntity(id);
        }
    }
    scannedChunks.clear();
    chestBoxes = {};
}


function reverseIndex(i, stride) {
    const x = Math.floor(i / stride[0]);
    const remX = i % stride[0];
    const y = Math.floor(remX / stride[1]);
    const z = remX % stride[1];
    return [x, y, z];
}

function getChunkKey(chunk) {
    const [wx, wy, wz] = chunk.pos || [0, 0, 0];
    const cx = Math.floor(wx / 32);
    const cy = Math.floor(wy / 32);
    const cz = Math.floor(wz / 32);
    return `${cx}|${cy}|${cz}|overworld`;
}

function scanChunk(chunk, blockIDs) {
    const blockData = chunk[chunkDataField];
    if (!blockData) return;

    const {
        data,
        stride
    } = blockData;

    const pos = chunk.pos || [0, 0, 0];
    if (!data || !stride) return;

    const chunkKey = getChunkKey(chunk);
    for (let i = 0; i < data.length; i++) {
        const blockID = data[i];
        if (!blockIDs.includes(blockID)) continue;




        const [x, y, z] = reverseIndex(i, stride);
        const worldX = pos[0] + x + 0.5;
        const worldY = pos[1] + y + 0.5;
        const worldZ = pos[2] + z + 0.5;

        const mesh = shideFuxny.Lion.Mesh.CreateBox("espbox", 0.5, false, 1, shideFuxny.Lion.scene);
        mesh.position.set(worldX, worldY, worldZ);
        mesh.renderingGroupId = 1;

        mesh.material = new shideFuxny.Lion.StandardMaterial("mat", shideFuxny.Lion.scene)

        const id = shideFuxny.entities.add([worldX, worldY, worldZ], null, null, mesh);
        if (!chestBoxes[chunkKey]) chestBoxes[chunkKey] = [];
        chestBoxes[chunkKey].push({
            mesh,
            id
        });


        if ([204, 205, 206, 207].includes(blockID)) {
            console.log("FOUNDCHEST")

            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(1, 0.5, 0); // orange
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(1, 0.5, 0); // makes it glow orange
        }
        if (blockID === 45) {
            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(0, 0, 1); // blue
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(0, 0, 1); // makes it glow blue
        }

        if (blockID === 465) {
            mesh.material.diffuseColor = new shideFuxny.Lion.Color3(0.7, 0.5, 1); // pale purple
            mesh.material.emissiveColor = new shideFuxny.Lion.Color3(0.7, 0.5, 1); // makes it glow pale purple
        }




    }
}




function scanAllChunks() {
    if (!shideFuxny?.world || !shideFuxny?.world?.[shideFuxny.impKey]?.hash) return;
    const chunkHash = shideFuxny.world[shideFuxny.impKey].hash;
    // Step 1: Remove boxes for chunks no longer loaded
    for (const scannedKey of scannedChunks) {
        if (!(scannedKey in chestBoxes)) continue;

        if (!Object.values(chunkHash).some(chunk => getChunkKey(chunk) === scannedKey)) {
            // Delete all meshes for this chunk
            for (const {
                    mesh,
                    id
                }
                of chestBoxes[scannedKey]) {
                mesh.dispose(); // remove from scene
                shideFuxny.entities.deleteEntity(id); // remove from entity system if needed
            }
            delete chestBoxes[scannedKey];
            scannedChunks.delete(scannedKey);
        }
    }

    // Step 2: Scan newly loaded chunks
    for (const chunkKey in chunkHash) {

        const chunk = chunkHash[chunkKey];
        if (!chunkDataField) {
            autoDetectChunkDataField(chunk);
            if (!chunkDataField) continue; // Skip if still not found
        }

        const blockData = chunk[chunkDataField];
        if (!blockData?.data || !blockData.stride || !chunk.pos) continue;


        const key = getChunkKey(chunk);
        if (scannedChunks.has(key)) continue;
        scannedChunks.add(key);
        if (chestESPEnabled) scanChunk(chunk, [204, 205, 206, 207]);
        if (oreESPEnabled) scanChunk(chunk, [44, 45, 465, 50]);
    }
}


function toggleChestESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.chestESPEnabled = true;
    chestESPEnabled = !chestESPEnabled;
    if (chestESPEnabled || oreESPEnabled) {
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    } else {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time
    }
    updateChestESPButton();
}

function toggleOreESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.oreESPEnabled = true;
    oreESPEnabled = !oreESPEnabled;
    if (chestESPEnabled || oreESPEnabled) {
        scanAllChunks();
        chestOreInterval = setInterval(scanAllChunks, 5000);
    } else {
        clearInterval(chestOreInterval);
        chestOreInterval = null;
        clearESPBoxes();
        scannedChunks.clear(); // Allow rescan next time
    }
    updateOreESPButton();
}



function toggleESP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.espEnabled = true;
    if (!shideFuxny.impKey) return;
    espEnabled = !espEnabled;
    const groupId = espEnabled ? 2 : 0;

    if (Array.isArray(r.values(shideFuxny.rendering)[18].thinMeshes)) {
        for (const thinMesh of r.values(shideFuxny.rendering)[18].thinMeshes) {
            if (thinMesh?.mesh && typeof thinMesh.mesh.renderingGroupId === "number") {
                thinMesh.mesh.renderingGroupId = groupId;
            }
        }
        console.log(`âœ… Thin meshes render group set to ${groupId}`);
    } else {
        console.error("âŒ thinMeshes array not found.");
    }
    updateESPButton?.();
}




// Utility Functions
function findNoaAndKey() {

		let winDescriptors = Object.getOwnPropertyDescriptors(window);
        let wpName = Object.keys(winDescriptors).find(key => winDescriptors[key]?.set?.toString().includes("++"));
        let wpInstance = null;
		
		if (wpName) {wpInstance = window[wpName] = window[wpName]}
		
	if (wpInstance) {
		wpInstance.push([
			[Math.floor(Math.random() * 90000) + 10000], {},
			function(wpRequire) {
				shideFuxny.findModule = (code) => wpRequire(Object.keys(wpRequire.m)[Object.values(wpRequire.m).findIndex(m => m.toString().includes(code))]);
				shideFuxny.Props = Object.values(shideFuxny.findModule("nonBlocksClient:")).find(prop => typeof prop == "object");
				shideFuxny.NIGHT = Object.values(shideFuxny.Props).find(prop => prop?.entities);
				//Credits to, you guessed it wang!
			}
		]);
	}
	
    if (!shideFuxny.NIGHT) {
		usingAltInjection = true;
        console.warn("âŒ Could not find noa, using backup.");

			function findObjectsWithEntitiesAndCamera(obj) {
			  const matches = [];
			  const visited = new WeakSet();

			  function recurse(current, path = []) {
				if (typeof current !== 'object' || current === null) return;
				if (visited.has(current)) return;
				visited.add(current);

				const keys = Object.keys(current);
				if (keys.includes('entities') && keys.includes('camera')) {
				  matches.push({
					path: path.join('.'),
					object: current
				  });
				}

				for (const key of keys) {
				  const value = current[key];
				  if (typeof value === 'object' && value !== null) {
					recurse(value, [...path, key]);
				  }
				}
			  }

			  recurse(obj);
			  return matches;
			}


			const result = findObjectsWithEntitiesAndCamera(window);
			shideFuxny.NIGHT = result[0].object


    };


    const targetValue = r.values(shideFuxny.NIGHT.entities)[2];
    const entityEntries = Object.entries(shideFuxny.NIGHT.entities);
    shideFuxny.impKey = entityEntries.find(([_, val]) => val === targetValue)?.[0];
    shideFuxny.registry = r.values(shideFuxny.NIGHT)[17]
    shideFuxny.rendering = r.values(shideFuxny.NIGHT)[12]
    shideFuxny.entities = shideFuxny.NIGHT.entities;



    if (shideFuxny.impKey) {
        console.log("importantList identified:", shideFuxny.impKey);

        // Attempt to find BHOP references
        const key = shideFuxny.impKey;
        if (key) {
            const entity = shideFuxny.NIGHT.entities?.[key];
            if (entity?.moveState?.list?.[0] && entity?.movement?.list?.[0]) {
                playerKey = key;
                moveState = entity.moveState.list[0];
                physState = entity.movement.list[0];
                cachedBHOPParent = entity;
                console.log("âœ… Cached BHOP entity data");
            } else {
                console.warn("âš ï¸ Found key but missing BHOP components");
            }
        } else {
            console.warn("âŒ BHOP player key not found");
		}
    }

    (function findECS() {
        const noaObj = shideFuxny.NIGHT;
        if (!noaObj) {
            console.error("âŒ noa object not found");
            return;
        }

        for (const [key, val] of Object.entries(noaObj)) {
            if (key === "entities") continue; // skip known non-ECS

            if (typeof val === "object" && typeof val.getState === "function") {
                console.log(`âœ… Found ECS at noa.${key}`);
                shideFuxny.ECS = val;
                break;
            }
        }

    })();

    function findeIdKey() {

        const rendering = r.values(shideFuxny.rendering)[18];
        const objectData = rendering?.objectData;
        if (!objectData) return;

        const sample = objectData[1];
        for (const key in sample) {
            if (sample[key] === 1) {
                eIdKey = key;
                break;
            }
        }
    }

    findeIdKey();

    function findAddComponentFunction(obj) {
        const exclude = ['overwriteComponent', 'deleteComponent', 'removeComponent', 'getState'];
        for (const key in obj) {
            if (exclude.includes(key)) continue;
            const fn = obj[key];
            if (typeof fn !== 'function') continue;
            try {
                fn(999999, "__FAKE_COMPONENT__", {});
            } catch (err) {
                const msg = (err?.message || "").toLowerCase();
                if (
                    msg.includes("unknown component") ||
                    msg.includes("already has component") ||
                    (msg.includes("component") && msg.includes("missing"))
                ) {
                    console.log(`ðŸ§© Candidate: ${key} â†’ likely addComponent()`);
                    return key;
                }
            }
        }
        console.warn("âŒ Could not identify an addComponent-like function.");
        return null;
    }



    let mesh = r.values(shideFuxny.rendering)[7].meshes[0];
    let scene = r.values(shideFuxny.rendering)[7];
    let engine = scene.getEngine();
    let StandardMaterial = mesh.material.constructor;
    let Color3 = mesh.material.diffuseColor.constructor;
    const addKey = findAddComponentFunction(shideFuxny.NIGHT.entities);
    const addComponent = shideFuxny.NIGHT.entities[addKey];
    shideFuxny.world = r.values(shideFuxny.NIGHT)[11]
    shideFuxny.physics = shideFuxny.NIGHT.physics
    shideFuxny.camera = shideFuxny.NIGHT.camera
    shideFuxny.bloxd = shideFuxny.NIGHT.bloxd
    shideFuxny.clientOptions = r.values(shideFuxny.NIGHT)[29]
    shideFuxny.Lion = {
        scene,
        engine,
        InstancedMesh: mesh.constructor,
        Mesh: mesh.constructor,
        Scene: scene.constructor,
        Engine: engine.constructor,
        Color3,
        StandardMaterial,
        addComponent,
        addKey
    };
    playerInventoryParent = shideFuxny.entities[shideFuxny.impKey].inventory.list[0].opWrapper


    function autoDetectChunkDataField(chunk) {
        for (const key of Object.keys(chunk)) {
            const val = chunk[key];
            if (!val) continue;

            if (
                typeof val === "object" &&
                Array.isArray(val.stride) &&
                val.stride.length === 3 &&
                (
                    Array.isArray(val.data) ||
                    ArrayBuffer.isView(val.data) // covers Uint16Array etc.
                )
            ) {
                console.log("âœ… Detected chunk data field:", key);
                chunkDataField = key;
                return key;
            }
        }

        console.warn("âŒ Failed to auto-detect chunk data field");
        return null;
    }

    autoDetectChunkDataField(Object.values(shideFuxny.world[shideFuxny.impKey].hash)[0]);

    const maybeEntity = r.values(r.values(shideFuxny.entities[shideFuxny.impKey])[22].list[0])[1];

    const hasDoAttackDirect = typeof maybeEntity?.doAttack === 'function';
    const hasDoAttackBreakingItem = typeof maybeEntity?.breakingItem?.doAttack === 'function';

    if (hasDoAttackDirect) {
        console.log("maybeEntity has doAttack");
        playerEntity = maybeEntity;
    } else if (hasDoAttackBreakingItem) {
        console.log("maybeEntity.breakingItem has doAttack");
        playerEntity = maybeEntity.breakingItem;
    } else {
        console.warn("Neither maybeEntity nor its breakingItem has doAttack");
        playerEntity = null;
    }




    mesh = null;
    scene = null;
    engine = null;
    StandardMaterial = null;
    Color3 = null;


    /*
    		(function findRenderingModule() {
    			const scene = shideFuxny?.Lion?.scene;
    			if (!scene) {
    				console.error("âŒ shideFuxny.Lion.scene not set");
    				return;
    			}

    			for (const [key, val] of Object.entries(shideFuxny.NIGHT)) {
    				if (typeof val === "object" && val !== null) {
    					for (const nestedVal of Object.values(val)) {
    						if (nestedVal === scene) {
    							console.log(`âœ… Found scene in noa["${key}"]`);
    							shideFuxny.rendering = val;
    							return;
    						}
    					}
    				}
    			}



    		})();

    */
	
	
	
function findOnlysendBytes(obj) {
  if (!obj) {
    console.warn("âŒ Provided object is null or undefined.");
    return null;
  }

  const proto = Object.getPrototypeOf(obj);
  const props = Object.getOwnPropertyNames(proto);

  for (const key of props) {
    if (key === 'constructor') continue;

    const val = proto[key];
    if (typeof val === 'function') {
      const str = val.toString();

      // Looser but effective pattern detection
      const looksLikesendBytes =
        val.length === 2 &&
        /Protocol\.ROOM_DATA_BYTES/i.test(str) &&
        str.includes('Uint8Array') &&
        /typeof/.test(str) && // just check any typeof usage
        str.includes('.encode') &&
        (str.includes('.byteLength') || str.includes('.length')) &&
        str.includes('.set');

      if (looksLikesendBytes) {
        console.log(`âœ… Real sendBytes found: ${key}`);
        return key;
      }
    }
  }

  console.warn("âŒ sendBytes function not found.");
  return null;
}

// Usage
colyRoom = r.values(shideFuxny.bloxd.client.msgHandler)[0];
sendBytesName = findOnlysendBytes(colyRoom);

  if (!colyRoom || typeof colyRoom[sendBytesName] !== "function") {
    console.warn("[Blink] colyRoom or sendBytes not ready.");
  }

blinkState = {
    enabled: false,
    originalSendBytes: colyRoom[sendBytesName],
    queued: [],
    interval: 0,
    noPacket: false
  };



    startTargetFinder()


function setupKillAuraBox() {
	
    newBox = shideFuxny.Lion.Mesh.CreateBox("mesh", .5, false, 1, shideFuxny.Lion.scene);
    newBox.renderingGroupId = 1;
    newBoxId = shideFuxny.entities.add([0, 10, 0], null, null, newBox);

    //newBox.Da = true;
    newBox.material = new shideFuxny.Lion.StandardMaterial("mat", shideFuxny.Lion.scene);
    newBox.material.diffuseColor = new shideFuxny.Lion.Color3(1, 1, 1);
    newBox.material.emissiveColor = new shideFuxny.Lion.Color3(1, 1, 1);
    newBox.name = 'BodyMesh';
    newBox.id = 'BodyMesh';
    newBox.isVisible = false;
	if (!newBox.metadata) newBox.metadata = {};

    // Find null key
    __nullKey = null;
    for (const key in newBox) {
        if (key.length === 2 && newBox[key] === null) {
            __nullKey = key;
            break;
        }
    }
    if (__nullKey) {
        newBox[__nullKey] = false;
    }

    shideFuxny.entityList = r.values(shideFuxny.NIGHT)[30]

    humanoidMeshlist = shideFuxny.entities[shideFuxny.impKey]?.humanoidMesh?.list;
    __stringKey = null;
    if (Array.isArray(humanoidMeshlist)) {
        outerLoop: for (const obj of humanoidMeshlist) {
            for (const key in obj) {
                if (typeof obj[key] === "string") {
                    __stringKey = key;
                    break outerLoop;
                }
            }
        }
    }
    else {
        console.error("âŒ Invalid humanoidMeshlist path.");
    }

    // Follow loop
    function followHeadLoop() {
        if (newBox) {
            const playerId = 1;
            const playerPosState = shideFuxny.entities.getState(playerId, "position");

            if (playerPosState && Array.isArray(playerPosState.position)) {
                const [x, y, z] = playerPosState.position;
                const newPos = [x, y + 1.5, z];
                shideFuxny.entities.setPosition(newBoxId, newPos);
            } else {
                console.error("Player position not found or invalid");
            }
        }

        animationFrameId = requestAnimationFrame(followHeadLoop);
    }

    // Start the loop
    animationFrameId = requestAnimationFrame(followHeadLoop);
}

setupKillAuraBox();


    passiveFeatures();
	
	document.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "g") {
        for (const key in shideFuxny.bloxd.entityNames) {
            if (key === "1") continue;

            const nameObj = shideFuxny.bloxd.entityNames[key];
            const state = shideFuxny.entities.getState(key, 'position');
            if (!state || !state.position) continue;

            const pos = state.position;
            const x = Math.round(pos[0]);
            const y = Math.round(pos[1]);
            const z = Math.round(pos[2]);

            // Remove existing position suffix if any (like "Name (x, y, z)")
            const baseName = nameObj.entityName.replace(/\s*\(\-?\d+,\s*\-?\d+,\s*\-?\d+\)$/, "");

            // Update with new position
            nameObj.entityName = `${baseName} (${x}, ${y}, ${z})`;
        }
    }
});



    const visitedTags = new WeakSet();

    function findParentOfNameTag(obj, path = '') {
        if (typeof obj !== 'object' || obj === null || visitedTags.has(obj)) return null;
        visitedTags.add(obj);

        for (const key in obj) {
            if (!Object.hasOwn(obj, key)) continue;
            try {
                const value = obj[key];
                const currentPath = path + (Array.isArray(obj) ? `[${key}]` : (path ? '.' : '') + key);

                if (value && typeof value === 'object' && value.id === '1NameTag') {
                    console.log("âœ… Path to NameTag parent:", currentPath);
                    return obj;
                }

                const result = findParentOfNameTag(value, currentPath);
                if (result) return result;
            } catch {}
        }
        return null;
    }

    cachedNameTagParent = shideFuxny.Lion.scene //findParentOfNameTag(shideFuxny.world[shideFuxny.impKey].hash)     Ð’ÑÐµ ÐµÐ±Ð°Ñ‚ÑŒ.


    // Run the function every 15 seconds
    setInterval(makeHitboxes, 1000);



}



function findElementByText(text) {
    const all = document.querySelectorAll('div, span, button, a');
    for (const el of all)
        if (el.textContent.trim() === text) return el;
    return null;
}

function clickTeleportButton() {
    const teleportButtonText = findElementByText('Teleport To Lobby Spawn');
    if (teleportButtonText) {
        let clickable = teleportButtonText;
        while (clickable && !clickable.onclick && clickable.tagName !== 'BUTTON') clickable = clickable.parentElement;
        if (clickable) {
            console.log('Clicking teleport button:', clickable);
            clickable.click();
        } else {
            console.warn('No clickable parent found, trying to click text element itself');
            teleportButtonText.click();
        }
    } else console.warn('Teleport button text not found in DOM');
}


function toggleAutoPot() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
    autoPotionEnabled = !autoPotionEnabled;
    if (autoPotionEnabled) {
        autoPotionInterval = setInterval(movePotionToSlot, 1000);
        console.log("AutoPotion enabled");
    } else {
        clearInterval(autoPotionInterval);
        autoPotionInterval = null;
        console.log("AutoPotion disabled");
    }
    updateAutoPotButton();
}


function toggleNameTags() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.nameTagsEnabled = true;

    nameTagsEnabled = !nameTagsEnabled;
    if (nameTagsEnabled) {
        if (!cachedNameTagParent) {
            nameTagsEnabled = false;
            return;
        }
        nameTagParent = cachedNameTagParent;
        nameTagsIntervalId = setInterval(() => {
            const entityList = shideFuxny.entityList;
            if (!entityList || typeof entityList !== 'object') return;

            for (const subGroup of Object.values(entityList)) {
                if (!subGroup || typeof subGroup !== 'object') continue;

                for (const obj of Object.values(subGroup)) {
                    if (obj?.lobbyLeaderboardValues) {
                        try {
                            const descTag = Object.getOwnPropertyDescriptor(obj, 'hasPriorityNametag');
                            if (!descTag || descTag.configurable) {
                                Object.defineProperty(obj, 'hasPriorityNametag', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                            const descSee = Object.getOwnPropertyDescriptor(obj, 'canSee');
                            if (!descSee || descSee.configurable) {
                                Object.defineProperty(obj, 'canSee', {
                                    get() {
                                        return true;
                                    },
                                    set(val) {
                                        if (val !== true) {}
                                    },
                                    configurable: true
                                });
                            }

                        } catch (e) {}
                    }
                }
            }

            for (const key in nameTagParent) {
                const tag = nameTagParent;
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const descVisible = Object.getOwnPropertyDescriptor(tag, '_isVisible');
                        if (!descVisible || descVisible.configurable) {
                            Object.defineProperty(tag, '_isVisible', {
                                get() {
                                    return true;
                                },
                                set(val) {
                                    if (val !== true) {}
                                },
                                configurable: true
                            });
                        }

                        const descRenderGroup = Object.getOwnPropertyDescriptor(tag, 'renderingGroupId');
                        if (!descRenderGroup || descRenderGroup.configurable) {
                            Object.defineProperty(tag, 'renderingGroupId', {
                                get() {
                                    return 3;
                                },
                                set(val) {
                                    if (val !== 3) {}
                                },
                                configurable: true
                            });
                        }
                    } catch (e) {}
                }
            }
        }, 15000);
        console.log("âœ… NameTag visibility lock: ON");
    } else {
        clearInterval(nameTagsIntervalId);
        nameTagsIntervalId = null;
        if (nameTagParent) {
            for (const key in nameTagParent) {
                const tag = nameTagParent[key];
                if (tag && typeof tag === 'object' && typeof tag.id === 'string' && tag.id.includes('NameTag')) {
                    try {
                        const current = tag._isVisible;
                        delete tag._isVisible;
                        tag._isVisible = current;
                    } catch (e) {
                        console.warn("Failed to unlock _isVisible on", tag);
                    }
                }
            }
        }
        nameTagParent = null;
        console.log("ðŸŸ¡ NameTag visibility lock: OFF");
    }
    updateNameTagsButton();
}

function toggleBHOP() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.bhopEnabled = true;
    bhopEnabled = !bhopEnabled;
    if (bhopEnabled) {
        if (!moveState || !physState) {
            console.warn("âŒ BHOP references not initialized. Did you inject?");
            bhopEnabled = false;
            return;
        }
        bhopIntervalId = setInterval(bunnyHop, 10); //was 60
        console.log("BHOP: ON");
    } else {
        clearInterval(bhopIntervalId);
        bhopIntervalId = null;
        console.log("BHOP: OFF");
    }
    updateBHOPButton();
}

  const toggleBlink = (interval = 0, noPacket = false) => {
    blinkState.enabled = !blinkState.enabled;
    blinkState.interval = interval;
    blinkState.noPacket = noPacket;

    if (blinkState.enabled) {
      console.log(`[Blink] ENABLED â€” interval: ${interval}, noPacket: ${noPacket}`);

      colyRoom[sendBytesName] = (...args) => {

        const [J, T] = args;
        const send = () => blinkState.originalSendBytes.call(colyRoom, J, T);

        if (interval > 0) {
          setTimeout(send, interval);
        } else {
          blinkState.queued.push([J, T]);
        }
      };
    } else {
      console.log(`[Blink] DISABLED â€” sending ${blinkState.queued.length} packets.`);

      for (const [J, T] of blinkState.queued) {
        blinkState.originalSendBytes.call(colyRoom, J, T);
      }

      colyRoom[sendBytesName] = blinkState.originalSendBytes;
      blinkState.queued = [];
    }
  };

function toggleBlinkWrapper() {
    if (!injectedBool) {

        showTemporaryNotification('You need to inject first habibi!')

    }
	everEnabled.blinkEnabled = true;
	
	
	toggleBlink();
	updateBlinkButton();
}


// â› BHOP logic
function bunnyHop() {
    if (!bhopEnabled || !physState.isOnGround?.() || moveState.crouching || moveState.speed < 0.05) return;
    moveState.jumping = true;
    physState._hadJumpInputPrevTick = false;
    setTimeout(() => {
        moveState.jumping = false;
    }, 20);
}




//////////////////////////////////////////////////////////////////////////////////////GUI

document.getElementById("rndAsciiGUI")?.remove();
document.getElementById("rndAsciiGUI_minimized")?.remove();

let miniPos = {
    left: 10,
    top: 10
};
let accent = {
    color: defaultColor,
    alpha: 1
};
let bg = {
    color: defaultBackGroundColor,
    alpha: defaultBackGroundTransparency,
    blur: defaultBackGroundBlur
};
let isGuiVisible = true;
let minimizedIcon = null;

const style = document.createElement("style");
style.textContent = `
  :root {
    --accent-color: ${defaultColor};
    --accent-gradient: ${defaultGradient};
    --accent-hover-color: ${defaultColor};
  }

  .gradient-indicator {
    background: var(--accent-gradient);
  }

  #rndAsciiGUI {
    position: fixed;
    top: 10vh;
    left: 10vw;
    width: 35vw; /* Change width to one-third of the original */
    height: auto;
    z-index: 999999;
    border-radius: 8px;
    overflow: hidden;
    font-family: sans-serif;
    pointer-events: none;
  }

  #rndAsciiTopBar {
    height: 40px;
    background: var(--accent-gradient);
    color: white;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 10px;
    cursor: move;
    pointer-events: auto;
  }

  #rndAsciiTopBar img {
    width: 24px;
    height: 24px;
    margin-right: 10px;
    border-radius: 4px;
  }

  #rndAsciiTopBarTitle {
    display: flex;
    align-items: center;
    pointer-events: auto;
  }

  #rndAsciiMinBtn {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
    padding: 0 10px;
    pointer-events: auto;
  }

  #rndAsciiContent {
    display: flex;
    height: auto;
    pointer-events: auto;
  }

  #rndAsciiSidebar {
    width: 150px;
    display: flex;
    flex-direction: column;
  }

.rndAsciiBtn {
    box-sizing: border-box;
    padding: 12px 10px;
    color: rgba(255, 255, 255, 0.8);
    background: none;
    text-align: left;
    position: relative;
    cursor: pointer;
    outline: none;
    border: none;
    box-shadow: none;
    transition: all 0.2s;
    pointer-events: auto;
    font-size: 14px;
    height: 50px;
    display: flex;
    align-items: center;
    border-radius: 4px;
    margin: 2px 5px;
  }

  .rndAsciiBtn.active {
    font-weight: bold;
    background: rgba(255, 255, 255, 0.1);
  }

  .rndAsciiBtn:hover {
    background: rgba(255, 255, 255, 0.05);
  }

  .rndAsciiBtn.indicatorLine {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px
    width: 0%;
    background: var(--accent-gradient);
    transition: width 0.3s;
    border-radius: 2px;
}


  #rndAsciiDivider {
    width: 2px;
    background: var(--accent-color, ${defaultColor});
    margin: 0 5px;
  }

  #rndAsciiPage {
    flex: 1;
    padding: 20px;
    color: white;
    overflow-y: auto;
    pointer-events: auto;
  }

  #rndAsciiGUI_minimized {
    position: fixed;
    width: 32px;
    height: 32px;
    background: var(--accent-gradient);
    border-radius: 4px;
    z-index: 999999;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: move;
    user-select: none;
    pointer-events: auto;
  }

  #rndAsciiGUI_minimized img {
    width: 20px;
    height: 20px;
    border-radius: 4px;
  }

  .rndAsciiGroup {
    margin-bottom: 20px;
  }

  .rndAsciiGroup label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
  }

  input[type="range"] {
    width: 100%;
    accent-color: var(--accent-color, ${defaultColor});
    pointer-events: auto;
  }

  input[type="color"] {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    outline: none;
    height: 30px;
    border-radius: 4px;
    cursor: pointer;
    pointer-events: auto;
  }

  input[type="text"] {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    outline: none;
    height: 30px;
    border-radius: 4px;
    color: white;
    padding: 0 10px;
    pointer-events: auto;
  }
.gradient-border {
  position: relative;
  color: white;
  background-color: transparent;
  border: none; /* Remove the border from the main element */
  border-radius: 8px;
  cursor: pointer;
  z-index: 0;
}

`;
document.head.appendChild(style);




const gui = document.createElement("div");
gui.id = "rndAsciiGUI";
document.body.appendChild(gui);

const topHTML = `
  <style>
    #rndAsciiTopBarTitle span {
  text-shadow:
    0 0 5px rgba(255, 255, 255, 0.9),
    0 0 10px rgba(255, 255, 255, 0.8),
    0 0 15px rgba(255, 255, 255, 0.7);
}
  </style>
  <div id="rndAsciiTopBar">
    <div id="rndAsciiTopBarTitle">
      <img src="${ICON_URL}" alt="icon">
      <span>${TITLE}</span>
    </div>
    <button id="rndAsciiMinBtn">_</button>
  </div>
`;


const contentHTML = `
		  <div id="rndAsciiContent">
			<div id="rndAsciiSidebar"></div>
			<div id="rndAsciiDivider"></div>
			<div id="rndAsciiPage"></div>
		  </div>
		`;

gui.innerHTML = topHTML + contentHTML;

const sidebar = gui.querySelector("#rndAsciiSidebar");
const page = gui.querySelector("#rndAsciiPage");

const waterJumpBtn = createButton("Water Jump")
const hitboxBtn = createButton("Hitbox");
const wireframeBtn = createButton("Wireframes");
const espBtn = createButton("ESP");
const bhopBtn = createButton("BHOP");
const enemyHealthGuiBtn = createButton("Enemy Healh Bar")
const blinkBtn = createButton("Blink");
const chestESPBtn = createButton("Chest ESP");
const oreESPBtn = createButton("Ore ESP");
const nameTagBtn = createButton("Nametags")
const killAuraBtn = createButton("Kill Aura")
const skyBoxBtn = createButton("Night")
const wallJumpBtn = createButton("Wall Jump")
const triggerBotBtn = createButton("TriggerBot")
const pickupReachBtn = createButton("Pickup Reach")
const autoPotBtn = createButton("Auto Potion")
const knifeBtn = createButton("BHOP Knife")
const bigHeadsBtn = createButton("BIGHEADS")
const scaffoldBtn = createButton("Scaffold")
const slowHitBtn = createButton("Slow Hit")

const pageNames = [
    "Inject & Enumerate",
    "Combat",
    "Movement",
    "Visual",
    "World",
    "Settings"
];

const customizationElements = [];
const pageBtns = [];
const pageContents = [
    [],
    [hitboxBtn, killAuraBtn, triggerBotBtn, enemyHealthGuiBtn, autoPotBtn, bigHeadsBtn, slowHitBtn],
    [bhopBtn, knifeBtn, blinkBtn, waterJumpBtn, wallJumpBtn],
    [chestESPBtn, oreESPBtn, wireframeBtn, espBtn, nameTagBtn],
    [pickupReachBtn, skyBoxBtn, scaffoldBtn],
    customizationElements
];


function createButton(label) {
    const btn = document.createElement('button');
    btn.textContent = label;
    btn.className = 'rndAsciiBtn';
    btn.style.width = 'calc(100% - 10px)';
    btn.style.padding = '12px 10px';
    btn.style.position = 'relative';
    btn.style.margin = '3px 5px';
    btn.style.border = 'none';
    btn.style.borderRadius = '4px';
    btn.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
    btn.style.color = 'rgba(255, 255, 255, 0.8)';
    btn.style.cursor = 'pointer';
    btn.style.fontSize = '14px';
    btn.style.textAlign = 'left';
    btn.style.height = '50px';
    btn.style.display = 'flex';
    btn.style.alignItems = 'center';
    btn.style.transition = 'all 0.2s';

    const indicatorLine = document.createElement('div');
    indicatorLine.className = 'indicatorLine gradient-indicator';
    indicatorLine.style.position = 'absolute';
    indicatorLine.style.bottom = '0';
    indicatorLine.style.left = '0';
    indicatorLine.style.width = '0%';
    indicatorLine.style.height = '4px';
    indicatorLine.style.setProperty('height', '4px', 'important');
    indicatorLine.style.transition = 'width 0.3s';

    btn.appendChild(indicatorLine);
    btn.indicatorLine = indicatorLine;

    btn.onmouseenter = function() {
        this.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
    };

    btn.onmouseleave = function() {
        if (!this.classList.contains('active')) {
            this.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
        }
    };

    return btn;
}

for (let i = 0; i < pageNames.length; i++) {
    const btn = createButton(pageNames[i]);
    btn.indicatorLine.style.display = i === 0 ? "block" : "none";

    btn.onclick = () => {
        // Clear existing active styles
        pageBtns.forEach((b) => {
            b.classList.remove("active");
            b.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
            b.style.fontWeight = "normal";
            b.indicatorLine.style.width = "0%";
        });

        // Apply active styles to current button
        btn.classList.add("active");
        btn.style.backgroundColor = "rgba(255, 255, 255, 0.15)";
        btn.style.fontWeight = "bold";
        btn.indicatorLine.style.width = "100%";

        // Clear current page content
        page.innerHTML = "";

        // Load appropriate page
        if (i === 0) {
            createPageOneContent(); // Inject page
        } else if (i === 5) {
            showCustomizationPage();
            pageContents[i].forEach(el => page.appendChild(el));
        } else {
            pageContents[i].forEach(el => page.appendChild(el));
        }
    };

    if (i === 0) btn.classList.add("active");
    sidebar.appendChild(btn);
    pageBtns.push(btn);
}




pageContents[0].forEach(el => page.appendChild(el));

function showCustomizationPage() {
    customizationElements.length = 0;

    const keybindGroup = document.createElement("div");
    keybindGroup.className = "rndAsciiGroup";

    keybindActions.forEach((bind) => {
        const bindLabel = document.createElement("label");
        bindLabel.textContent = `${bind.name} Keybind`;

        const bindInput = document.createElement("input");
        bindInput.type = "text";
        bindInput.value = bind.code;
        bindInput.dataset.name = bind.name;
        bindInput.style.outline = "none"; // Remove default focus outline

        bindInput.addEventListener("focus", () => {
            // Handler for keyboard keys
            const handleKeyDown = (event) => {
                event.preventDefault();
                const newKey = event.code;  // Keyboard key code like "KeyA", "ArrowUp"
                setNewKeybind(newKey);
            };

            // Handler for mouse buttons
            const handleMouseDown = (event) => {
                event.preventDefault();
                let newKey = null;
                switch(event.button) {
                    case 0: newKey = "MouseLeft"; break;
                    case 1: newKey = "MouseMiddle"; break;
                    case 2: newKey = "MouseRight"; break;
                    default: newKey = `MouseButton${event.button}`;
                }
                setNewKeybind(newKey);
            };

            // Common function to update keybind and cleanup listeners
            function setNewKeybind(newKey) {
                bindInput.value = newKey;

                const actionIndex = keybindActions.findIndex((action) => action.name === bind.name);
                if (actionIndex !== -1) {
                    keybindActions[actionIndex].code = newKey;

                    localStorage.setItem("customKeybinds_v1", JSON.stringify(
                        keybindActions.map(({ name, code }) => ({ name, code }))
                    ));
                }

                document.removeEventListener("keydown", handleKeyDown);
                document.removeEventListener("mousedown", handleMouseDown);
                bindInput.blur();
            }

            // Listen for either keyboard or mouse input once
            document.addEventListener("keydown", handleKeyDown, { once: true });
            document.addEventListener("mousedown", handleMouseDown, { once: true });
        });

        keybindGroup.appendChild(bindLabel);
        keybindGroup.appendChild(bindInput);
    });

    // Scrollable wrapper container to fix vertical overflow
    const wrapper = document.createElement("div");
    wrapper.style.maxHeight = "70vh";       // Limit height to 70% of viewport height
    wrapper.style.overflowY = "auto";       // Enable vertical scrolling when needed
    wrapper.style.padding = "10px";
    wrapper.style.margin = "10px 0";
    wrapper.style.border = "1px solid #ccc"; // Optional border for clarity

    wrapper.appendChild(keybindGroup);

    customizationElements.push(wrapper);

}

showCustomizationPage();

function applyTheme() {
    const accentRGBA = hexToRgba(accent.color, accent.alpha);
    const bgRGBA = hexToRgba(bg.color, bg.alpha);
    gui.style.setProperty("--accent-color", accent.color);
    gui.style.setProperty("--accent-gradient", defaultGradient);

    gui.style.background = bgRGBA;
    gui.style.backdropFilter = `blur(${bg.blur}px)`;

    // Apply the gradient to the minimized icon
    const minimizedIcon = document.getElementById("rndAsciiGUI_minimized");
    if (minimizedIcon) {
        minimizedIcon.style.background = `var(--accent-gradient)`;
    }

    // Apply the gradient to the indicator lines
    const indicatorLines = document.querySelectorAll(".indicatorLine");
    indicatorLines.forEach(line => {
        line.style.background = `var(--accent-gradient)`;
    });

    // Apply the gradient to all buttons
    // const buttons = document.querySelectorAll(".rndAsciiBtn");
    //  buttons.forEach(button => {
    //   button.style.background = `var(--accent-gradient)`;
    // });
    // I DIDNT WANT GRADIENT HERE


    const draggableAreas = document.querySelectorAll(".draggable-area");
    draggableAreas.forEach(area => {
        area.style.background = `var(--accent-gradient)`;
    });
}


// Helper function to get a complementary color
function getComplementaryColor(hex) {
    // Convert hex to RGB
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);

    // Calculate complementary color
    const compR = (255 - r).toString(16).padStart(2, '0');
    const compG = (255 - g).toString(16).padStart(2, '0');
    const compB = (255 - b).toString(16).padStart(2, '0');

    return `#${compR}${compG}${compB}`;
}



function hexToRgba(hex, alpha = 1) {
    const [r, g, b] = hex.match(/\w\w/g).map(x => parseInt(x, 16));
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

applyTheme();

const topBar = gui.querySelector("#rndAsciiTopBar");
let dragging = false,
    offsetX = 0,
    offsetY = 0;

topBar.addEventListener("mousedown", (e) => {
    if (e.target.id === "rndAsciiMinBtn") return;
    dragging = true;
    const rect = gui.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    e.stopPropagation();
});

document.addEventListener("mousemove", (e) => {
    if (dragging) {
        gui.style.left = `${e.clientX - offsetX}px`;
        gui.style.top = `${e.clientY - offsetY}px`;
    }
});

document.addEventListener("mouseup", () => {
    dragging = false;
});

gui.querySelector("#rndAsciiMinBtn").onclick = () => {
    gui.style.display = "none";
    isGuiVisible = false;
    showMinimizedIcon();
};

function showMinimizedIcon() {
    minimizedIcon = document.createElement("div");
    minimizedIcon.id = "rndAsciiGUI_minimized";
    minimizedIcon.className = "minimized-icon";
    minimizedIcon.style.left = `${miniPos.left}px`;
    minimizedIcon.style.top = `${miniPos.top}px`;
    minimizedIcon.style.position = "fixed";
    minimizedIcon.style.width = "32px";
    minimizedIcon.style.height = "32px";
    minimizedIcon.style.background = accent.color; // Set the background color here
    minimizedIcon.style.borderRadius = "4px";
    minimizedIcon.style.zIndex = "130";
    minimizedIcon.style.display = "flex";
    minimizedIcon.style.alignItems = "center";
    minimizedIcon.style.justifyContent = "center";
    minimizedIcon.style.cursor = "move";
    minimizedIcon.style.userSelect = "none";
    minimizedIcon.style.pointerEvents = "auto";

    // Create a separate draggable area
    const draggableArea = document.createElement("div");
    draggableArea.className = "draggable-area";
    draggableArea.style.width = "100%";
    draggableArea.style.height = "100%";
    draggableArea.style.position = "absolute";
    draggableArea.style.cursor = "move";
    draggableArea.style.borderRadius = "4px";

    // Create the image element
    const img = document.createElement("img");
    img.src = ICON_URL;
    img.alt = "icon";
    img.style.width = "20px";
    img.style.height = "20px";
    img.style.borderRadius = "4px";
    img.style.pointerEvents = "none";

    minimizedIcon.appendChild(draggableArea);
    minimizedIcon.appendChild(img);
    document.body.appendChild(minimizedIcon);

    let draggingMini = false;
    let clickStart = 0;
    let offsetX = 0;
    let offsetY = 0;

    draggableArea.addEventListener("mousedown", (e) => {
        draggingMini = true;
        const rect = minimizedIcon.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        clickStart = Date.now();
        e.stopPropagation();
    });

    document.addEventListener("mousemove", (e) => {
        if (draggingMini) {
            const x = e.clientX - offsetX;
            const y = e.clientY - offsetY;
            minimizedIcon.style.left = `${x}px`;
            minimizedIcon.style.top = `${y}px`;
            miniPos = {
                left: x,
                top: y
            };
        }
    });

    document.addEventListener("mouseup", (e) => {
        if (!draggingMini) return;
        draggingMini = false;
        const moved = Math.abs(e.clientX - (miniPos.left + offsetX)) > 4 ||
            Math.abs(e.clientY - (miniPos.top + offsetY)) > 4;
        const shortClick = (Date.now() - clickStart) < 200;
        if (!moved && shortClick) {
            gui.style.display = "block";
            isGuiVisible = true;
            minimizedIcon.remove();
        }
    });
}


document.addEventListener("keydown", (e) => {
    if (e.key === openKey) {
        if (isGuiVisible) {
            gui.style.display = "none";
            isGuiVisible = false;
            showMinimizedIcon();
            if (shideFuxny.Props.pointerLockWrapper) {
                shideFuxny.Props.pointerLockWrapper.removePointerUnlockRequest("Menu")
            }
        } else {

            gui.style.display = "block";
            isGuiVisible = true;
            if (minimizedIcon) minimizedIcon.remove();
            if (shideFuxny.Props.pointerLockWrapper) {
                shideFuxny.Props.pointerLockWrapper.requestPointerUnlock("Menu")
            }
        }
    }
});

document.addEventListener("keydown", (event) => {
    for (const bind of keybindActions) {
        // No need to check bind.type â€” just compare code strings
        if (event.code === bind.code) {
            event.preventDefault();
            console.log(`Triggered: ${bind.name} via key ${event.code}`);
            bind.action?.();
        }
    }
});
document.addEventListener("mousedown", (event) => {
    let buttonName;
    switch (event.button) {
        case 0: buttonName = "MouseLeft"; break;
        case 1: buttonName = "MouseMiddle"; break;
        case 2: buttonName = "MouseRight"; break;
        default: buttonName = `MouseButton${event.button}`;
    }

    for (const bind of keybindActions) {
        if (buttonName === bind.code) {
            event.preventDefault();
            console.log(`Triggered: ${bind.name} via ${buttonName}`);
            bind.action?.();
        }
    }
});


let injectButton = null;

function createPageOneContent() {
    const page = document.getElementById("rndAsciiPage");
    page.innerHTML = "";

    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.justifyContent = "center";
    container.style.alignItems = "center";
    container.style.height = "100%";

    // Inject Button
    injectButton = document.createElement("button");
    injectButton.textContent = injectedBool ? "Injected!" : "Waiting for game...";
    injectButton.className = "rndAsciiBtn gradient-border";
    injectButton.disabled = true;
    Object.assign(injectButton.style, {
        backgroundImage: defaultGradient,
        color: "#fff",
        border: "none",
        padding: "2px 12px",
        fontSize: "14px",
        textShadow: "0 0 6px rgba(255, 255, 255, 0.6)",
        marginBottom: "8px",
        cursor: "pointer",
        width: "150px",
        height: "30px",
        boxSizing: "border-box",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
    });

    injectButton.style.textShadow = `
        0 0 5px #fff,
        0 0 10px ${defaultColor},
        0 0 20px ${defaultColor},
        0 0 30px ${defaultColor}
    `;

    injectButton.onmouseenter = () => {
        injectButton.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    };
    injectButton.onmouseleave = () => {
        injectButton.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
    };
    injectButton.onmousedown = () => {
        injectButton.style.transform = "scale(0.98)";
    };
    injectButton.onmouseup = () => {
        injectButton.style.transform = "scale(1)";
    };

    injectButton.onclick = () => {
        try {
            findNoaAndKey();
            if (!shideFuxny.NIGHT) {
                console.warn("âŒ Could not find noa");
                injectButton.textContent = "Failed";
                return;
            }
            console.log("Injection completed!");
            injectButton.textContent = "Injected!";
            injectedBool = true;
            applyTheme();
        } catch (err) {
            console.error("Error running findNoaAndKey:", err);
            injectButton.textContent = "Error";
            alert("Error running function. See console.");
        }
    };

    // Shared button style
    const buttonStyle = {
        backgroundColor: "#5865F2",
        color: "#fff",
        border: "none",
        padding: "2px 10px",
        fontSize: "12px",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        textShadow: "0 0 4px rgba(0, 0, 0, 0.3)",
        height: "25px",
        boxSizing: "border-box",
        textAlign: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginTop: "6px"
    };

    const addHoverHandlers = (btn) => {
        btn.onmouseenter = () => {
            btn.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
        };
        btn.onmouseleave = () => {
            btn.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
        };
        btn.onmousedown = () => {
            btn.style.transform = "scale(0.97)";
        };
        btn.onmouseup = () => {
            btn.style.transform = "scale(1)";
        };
    };

    // Discord Button
    const discordButton = document.createElement("button");
    discordButton.textContent = "Discord";
    discordButton.className = "rndAsciiBtn";
    Object.assign(discordButton.style, buttonStyle);
    discordButton.style.textShadow = `
        0 0 5px #fff,
        0 0 10px #5865F2,
        0 0 20px #5865F2,
        0 0 30px #5865F2
    `;
    discordButton.onclick = () => {
        window.open("https://discord.gg/TQPqe9r2", "_blank");
    };
    addHoverHandlers(discordButton);

    // Clear Cookies Button
    const clearCookiesButton = document.createElement("button");
    clearCookiesButton.textContent = "New Account";
    clearCookiesButton.className = "rndAsciiBtn";
    Object.assign(clearCookiesButton.style, {
        backgroundColor: "#e74c3c", // Red color you liked
        color: "#fff",
        border: "none",
        padding: "2px 10px",
        fontSize: "12px",
        borderRadius: "5px",
        cursor: "pointer",
        fontWeight: "bold",
        textShadow: "0 0 4px rgba(0, 0, 0, 0.3)",
        height: "25px",
        boxSizing: "border-box",
        textAlign: "center",
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginTop: "6px"
    });
    clearCookiesButton.style.textShadow = `
    0 0 5px #fff,
    0 0 10px #e74c3c,
    0 0 20px #e74c3c,
    0 0 30px #e74c3c
`;
clearCookiesButton.onclick = () => {
    window.onbeforeunload = null; // Disable unload warning

    const deleteCookie = (name, path = "/", domain = "") => {
        let cookieStr = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=${path};`;
        if (domain) cookieStr += `domain=${domain};`;
        document.cookie = cookieStr;
    };

    const cookies = document.cookie.split(";");
    cookies.forEach(cookie => {
        const eqPos = cookie.indexOf("=");
        const name = eqPos > -1 ? cookie.slice(0, eqPos).trim() : cookie.trim();

        // Try to delete with several likely paths
        deleteCookie(name, "/");
        deleteCookie(name, "/path"); // if your site uses a subpath

        // Optional: attempt with domain if you're on a subdomain
        const hostname = location.hostname;
        const domainParts = hostname.split(".");
        if (domainParts.length > 2) {
            // Try to delete with base domain
            const baseDomain = domainParts.slice(-2).join(".");
            deleteCookie(name, "/", baseDomain);
        }
    });

    setTimeout(() => location.reload(), 150);
};


    addHoverHandlers(clearCookiesButton);


    // Append elements
    container.appendChild(injectButton);
    container.appendChild(discordButton);
    container.appendChild(clearCookiesButton);
    page.appendChild(container);

		let winDescriptors = Object.getOwnPropertyDescriptors(window);
        let wpName = Object.keys(winDescriptors).find(key => winDescriptors[key]?.set?.toString().includes("++"));
        let wpInstance = null;
		
		if (wpName) {wpInstance = window[wpName] = window[wpName]}
		
	if (wpInstance) {
    wpInstance.push([
        [Math.floor(Math.random() * 90000) + 10000], {},
        function(wpRequire) {
            shideFuxny.findModule = (code) => wpRequire(Object.keys(wpRequire.m)[Object.values(wpRequire.m).findIndex(m => m.toString().includes(code))]);
            shideFuxny.Props = Object.values(shideFuxny.findModule("nonBlocksClient:")).find(prop => typeof prop == "object");
            shideFuxny.NIGHT = Object.values(shideFuxny.Props).find(prop => prop?.entities);
            //Credits to, you guessed it wang!
        }
    ]);
    alreadyConnected = (shideFuxny?.Props?.connectedWebsocketUrl !== null);

		}


}

const sidebarButtons = document.querySelectorAll(".rndAsciiBtn");
sidebarButtons.forEach((btn, i) => {
    if (i === 0) {
        btn.onclick = () => {
            sidebarButtons.forEach(b => {
                b.classList.remove("active");
                const ind = b.querySelector(".indicatorLine");
                if (ind) ind.style.display = "none";
            });
            btn.classList.add("active");
            const indicatorLine = btn.querySelector(".indicatorLine");
            if (indicatorLine) indicatorLine.style.display = "block";
            createPageOneContent();
        };
    }
});

createPageOneContent();

function updateButtonUnderline(btn, isEnabled) {
    btn.classList.toggle("active", isEnabled);
    btn.indicatorLine.style.width = isEnabled ? "100%" : "0%";
}




function showTemporaryNotification(message, duration = 1500) {
    const defaultBackGroundTransparency = 0.5;
    const defaultBackGroundBlur = 9;

    // Create a notification container if it doesn't exist
    let notificationContainer = document.getElementById('notification-container');
    if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notification-container';
        notificationContainer.style.position = 'fixed';
        notificationContainer.style.bottom = '20px';
        notificationContainer.style.right = '20px';
        notificationContainer.style.zIndex = '132';
        document.body.appendChild(notificationContainer);
    }

    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = message;

    // Style the notification
    notification.style.padding = '12px';
    notification.style.color = '#fff';
    notification.style.borderRadius = '4px';
    notification.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
    notification.style.transition = 'opacity 0.5s ease-in-out, transform 0.5s ease-in-out';
    notification.style.opacity = '0';
    notification.style.transform = 'translateY(20px)';
    notification.style.marginBottom = '10px';
    notification.style.backgroundColor = defaultBackGroundColor;
    notification.style.opacity = defaultBackGroundTransparency;

    notification.style.backdropFilter = `blur(${defaultBackGroundBlur}px)`;
    notification.style.border = '2px solid transparent';
    notification.style.borderImage = 'var(--accent-gradient) 1';
    notification.style.backgroundClip = 'padding-box';

    // Add to container
    notificationContainer.appendChild(notification);

    // Trigger the fade-in effect
    setTimeout(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translateY(0)';
    }, 10);

    // Set up the fade-out and removal
    setTimeout(() => {
        notification.style.opacity = '0';
        //notification.style.transform = 'translateY(-20px)'; I DONT LIKE THIS

        // Remove after transition completes
        setTimeout(() => {
            notification.remove();

            // Remove container if no more notifications
            if (notificationContainer.children.length === 0) {
                notificationContainer.remove();
            }
        }, 500); // Match this with the transition duration
    }, duration);
}



// Update functions
function updateWireframeButton() {
    updateButtonUnderline(wireframeBtn, wireFramesBool);
    if (!isInitializing) showTemporaryNotification('Wireframes toggled: ' + wireFramesBool);
}

function updateHitboxButton() {
    updateButtonUnderline(hitboxBtn, hitBoxEnabled);
    if (!isInitializing) showTemporaryNotification('HitBoxes toggled: ' + hitBoxEnabled);
}


function updateESPButton() {
    updateButtonUnderline(espBtn, espEnabled);
    if (!isInitializing) showTemporaryNotification('ESP toggled: ' + espEnabled);
}

function updateEnemyHealthGuiButton() {
    updateButtonUnderline(enemyHealthGuiBtn, enemyHealthGuiEnabled);
    if (!isInitializing) showTemporaryNotification('Enemy Health Bar: ' + enemyHealthGuiEnabled);
}

function updateBHOPButton() {
    updateButtonUnderline(bhopBtn, bhopEnabled);
    if (!isInitializing) showTemporaryNotification('BHOP toggled: ' + bhopEnabled);
}

function updateBlinkButton() {
    updateButtonUnderline(blinkBtn, blinkState.enabled);
    if (!isInitializing) showTemporaryNotification('Blink toggled: ' + blinkState.enabled);
}

function updateChestESPButton() {
    updateButtonUnderline(chestESPBtn, chestESPEnabled);
    if (!isInitializing) showTemporaryNotification('ChestESP toggled: ' + chestESPEnabled);
}

function updateOreESPButton() {
    updateButtonUnderline(oreESPBtn, oreESPEnabled);
    if (!isInitializing) showTemporaryNotification('OreESP toggled: ' + oreESPEnabled);
}

function updateNameTagsButton() {
    updateButtonUnderline(nameTagBtn, nameTagsEnabled);
    if (!isInitializing) showTemporaryNotification('Name Tags toggled: ' + nameTagsEnabled);
}

function updateKillAuraButton() {
    updateButtonUnderline(killAuraBtn, killAuraEnabled);
    if (!isInitializing) showTemporaryNotification('Kill Aura toggled: ' + killAuraEnabled);
}

function updateSkyboxButton() {
    updateButtonUnderline(skyBoxBtn, isSkyboxHidden);
    if (!isInitializing) showTemporaryNotification('Skybox toggled: ' + isSkyboxHidden);
}

function updateWaterJumpButton() {
    updateButtonUnderline(waterJumpBtn, waterJumpingEnabled);
    if (!isInitializing) showTemporaryNotification('Water Jump toggled: ' + waterJumpingEnabled);
}

function updateWallJumpButton() {
    updateButtonUnderline(wallJumpBtn, wallJumpRunning);
    if (!isInitializing) showTemporaryNotification('Wall Jump toggled: ' + wallJumpRunning);
}

function updateTriggerBotButton() {
    updateButtonUnderline(triggerBotBtn, triggerBotEnabled);
    if (!isInitializing) showTemporaryNotification('Trigger Bot toggled: ' + triggerBotEnabled);
}


function updatePickupReachButton() {
    updateButtonUnderline(pickupReachBtn, pickupReachEnabled);
    if (!isInitializing) showTemporaryNotification('Pickup Reach toggled: ' + pickupReachEnabled);
}

function updateAutoPotButton() {
    updateButtonUnderline(autoPotBtn, autoPotionEnabled);
    if (!isInitializing) showTemporaryNotification('Auto Potion toggled: ' + autoPotionEnabled);
}

function updateKnifeButton() {
    updateButtonUnderline(knifeBtn, bhopKnifeEnabled);
    if (!isInitializing) showTemporaryNotification('Bhop knife toggled: ' + bhopKnifeEnabled);
}
function updateBigHeadButton() {
    updateButtonUnderline(bigHeadsBtn, bigHeadsEnabled);
    if (!isInitializing) showTemporaryNotification('BIGHEADS toggled: ' + bigHeadsEnabled);
}

function updateScaffoldButton() {
    updateButtonUnderline(scaffoldBtn, scaffoldEnabled);
    if (!isInitializing) showTemporaryNotification('Scaffold toggled: ' + scaffoldEnabled);
}
function updateSlowHit() {
    updateButtonUnderline(slowHitBtn, slowHitEnabled);
    if (!isInitializing) showTemporaryNotification('Slow Hit toggled: ' + slowHitEnabled);
}

// Button click handlers
hitboxBtn.onclick = toggleHitBoxes;
waterJumpBtn.onclick = toggleLockPlayerWaterState;
wireframeBtn.onclick = toggleWireframe;
espBtn.onclick = toggleESP;
bhopBtn.onclick = toggleBHOP;
blinkBtn.onclick = toggleBlinkWrapper;
chestESPBtn.onclick = toggleChestESP;
oreESPBtn.onclick = toggleOreESP;
nameTagBtn.onclick = toggleNameTags;
killAuraBtn.onclick = toggleKillAura;
skyBoxBtn.onclick = toggleSkybox;
wallJumpBtn.onclick = toggleWallJumpScript;
triggerBotBtn.onclick = toggleTriggerBot;
pickupReachBtn.onclick = togglePickupReach;
enemyHealthGuiBtn.onclick = toggleEnemyHealthGui;
autoPotBtn.onclick = toggleAutoPot;
knifeBtn.onclick = toggleBhopKnife;
bigHeadsBtn.onclick = toggleBigHeads;
scaffoldBtn.onclick = toggleScaffold;
slowHitBtn.onclick = toggleSlowHit;

// Initialize button appearances (without showing notifications)
updateHitboxButton();
updateWireframeButton();
updateESPButton();
updateBHOPButton();
updateBlinkButton();
updateChestESPButton();
updateOreESPButton();
updateNameTagsButton();
updateKillAuraButton();
updateSkyboxButton();
updateWaterJumpButton();
updateWallJumpButton();
updateTriggerBotButton();
updatePickupReachButton();
updateEnemyHealthGuiButton();
updateAutoPotButton();
updateKnifeButton();
updateBigHeadButton();
updateScaffoldButton();
updateSlowHit();

injectedBool = false;
isInitializing = false;


/*
	function retoggleEnabledFeatures() {
	  const toggles = [
	    { enabled: wireFramesBool, btn: wireframeBtn },
	    { enabled: espEnabled, btn: espBtn },
	    { enabled: bhopEnabled, btn: bhopBtn },
	    { enabled: blinkState?.enabled, btn: blinkBtn },
	    { enabled: chestESPEnabled, btn: chestESPBtn },
	    { enabled: oreESPEnabled, btn: oreESPBtn },
	    { enabled: nameTagsEnabled, btn: nameTagBtn },
	    { enabled: killAuraEnabled, btn: killAuraBtn },
	    { enabled: isSkyboxHidden, btn: skyBoxBtn },
	    { enabled: waterJumpingEnabled, btn: waterJumpBtn },
	    { enabled: wallJumpRunning, btn: wallJumpBtn },
	    { enabled: triggerBotEnabled, btn: triggerBotBtn },
	    { enabled: pickupReachEnabled, btn: pickupReachBtn },
		  { enabled: enemyHealthGuiEnabled, btn: enemyHealthGuiBtn },
	  ];

	  for (const { enabled, btn } of toggles) {
	    if (enabled && btn?.click) {
	      btn.click();
	    }
	  }
	}
*/

function waitForElement(selector, callback) {
    if (alreadyConnected) {
        injectButton.disabled = false;
        injectButton.textContent = "Click if game loaded."
        startWebSocketWatcher();
        return;
    }
    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            for (const node of mutation.addedNodes) {
                if (node.nodeType === 1 && node.matches(selector)) {
                    observer.disconnect();
                    callback(node);
                    return;
                }
            }
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}

// Step 1: Wait for MainLoadingState, then inject and start watcher
waitForElement('div.MainLoadingState.FullyFancyText', (el) => {
    console.log('Target div appeared:', el);
    injectButton.disabled = false;
    injectButton.click();
    injectButton.textContent = "Injected!"
    startWebSocketWatcher(); // Start watching after injecting
});

function startWebSocketWatcher() {
    let waitingForConnect = true;
    let wasConnected = false;

    const interval = setInterval(() => {
        const url = shideFuxny?.Props?.connectedWebsocketUrl;

        if (waitingForConnect) {
            if (url) {
                console.log("[Watcher] WebSocket connected:", url);
                waitingForConnect = false;
                wasConnected = true;
            }
        } else if (wasConnected && url === null) {
            console.log("[Watcher] WebSocket disconnected â€“ reloading page");
            clearInterval(interval);
            document.getElementById("rndAsciiGUI")?.remove();
            document.getElementById("rndAsciiGUI_minimized")?.remove();
            location.reload();
        }
    }, 2000);
}

const scriptStart = performance.now(); // High-resolution timestamp at script load

const observer = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const node of mutation.addedNodes) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const text = node.textContent?.toLowerCase();
        if (text && text.includes("banned you") && injectedBool) {
          observer.disconnect(); // Stop observing after match

          const elapsed = ((performance.now() - scriptStart) / 1000).toFixed(2); // seconds

			const report = {
			  content:
			   `${text}\n`+
			   `version: ${version}\n`+
				` Execution to detection: ${elapsed}s\n` +
				` Used alternate injection: ${usingAltInjection}\n\n` +
				`**Toggled features:**\n` +
				'```json\n' + JSON.stringify(everEnabled, null, 2) + '\n```'
			};


          fetch("https://discord.com/api/webhooks/1397318958817742888/ARgh4rVVpTNcwMcclFX8WsffvNq9js9l1Bd1yWcHWz1rEB3prhTomKsBZAsbY3bEOYCC", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(report)
          });

          return;
        }
      }
    }
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});



//})();})();